{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to SurgeScript!\n\n\n\n\nSurgeScript is a scripting language for games. It has unique features that make it suitable for games - and it is extremely valuable for empowering users to generate their own content. Built originally for the Open Surge Engine, SurgeScript can be embedded into any C project.\n\n\nThe best way to try SurgeScript for the first time is to use the Open Surge Engine. However, a standalone version of the language is also available on \nGitHub\n.\n\n\nIt's such a joy to program in SurgeScript! You and your users will love it.\n\n\nSurgeScript in a nutshell\n\n\nSurgeScript is:\n\n\n\n\nA scripting language for games\n\n\nEasy for beginners, yet powerful to experts\n\n\nFree and open-source\n\n\nObject-oriented, dynamically typed and state-machine based\n\n\nThe only programming language in the world that allows you to tag objects with emoticons (natively! ;)\n\n\n\n\nYou can start your learning adventure by checking the \nHello World Tutorial\n.\n\n\nWhy SurgeScript?\n\n\nUnlike other programming languages, SurgeScript is designed for games. In SurgeScript, you have a collection of objects. Objects are units featuring data and code. Each object defines a state machine, as well as a parent-child relationship to other objects. This proves to be hugely valuable for games, specially if you are going to support user-generated content.\n\n\nCreating new things and customizing game behaviors is easier than ever before, yet the language is powerful enough to bring many of the programming constructs that you find in regular object-oriented languages. An infinite amount of flexibility can be achieved through object composition.\n\n\nThe motivation behind SurgeScript is to allow players to unleash their creativity and build their own content with ease, flexibility and massive amounts of power.\n\n\nWho did this?\n\n\nSurgeScript was originally conceived by Alexandre Martins, a developer from Brazil. Many thanks to the Open Surge community for the continued feedback.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#welcome-to-surgescript", 
            "text": "SurgeScript is a scripting language for games. It has unique features that make it suitable for games - and it is extremely valuable for empowering users to generate their own content. Built originally for the Open Surge Engine, SurgeScript can be embedded into any C project.  The best way to try SurgeScript for the first time is to use the Open Surge Engine. However, a standalone version of the language is also available on  GitHub .  It's such a joy to program in SurgeScript! You and your users will love it.", 
            "title": "Welcome to SurgeScript!"
        }, 
        {
            "location": "/#surgescript-in-a-nutshell", 
            "text": "SurgeScript is:   A scripting language for games  Easy for beginners, yet powerful to experts  Free and open-source  Object-oriented, dynamically typed and state-machine based  The only programming language in the world that allows you to tag objects with emoticons (natively! ;)   You can start your learning adventure by checking the  Hello World Tutorial .", 
            "title": "SurgeScript in a nutshell"
        }, 
        {
            "location": "/#why-surgescript", 
            "text": "Unlike other programming languages, SurgeScript is designed for games. In SurgeScript, you have a collection of objects. Objects are units featuring data and code. Each object defines a state machine, as well as a parent-child relationship to other objects. This proves to be hugely valuable for games, specially if you are going to support user-generated content.  Creating new things and customizing game behaviors is easier than ever before, yet the language is powerful enough to bring many of the programming constructs that you find in regular object-oriented languages. An infinite amount of flexibility can be achieved through object composition.  The motivation behind SurgeScript is to allow players to unleash their creativity and build their own content with ease, flexibility and massive amounts of power.", 
            "title": "Why SurgeScript?"
        }, 
        {
            "location": "/#who-did-this", 
            "text": "SurgeScript was originally conceived by Alexandre Martins, a developer from Brazil. Many thanks to the Open Surge community for the continued feedback.", 
            "title": "Who did this?"
        }, 
        {
            "location": "/tutorials/hello/", 
            "text": "Hello, World!\n\n\nSurgeScript creates automatically an object called \nApplication\n. That object is defined by the user. Let's see how we can use that to make a simple program:\n\n\nobject \nApplication\n\n{\n    state \nmain\n\n    {\n        Console.print(\nHello, world!\n);\n        Application.exit();\n    }\n}\n\n\n\n\nIn SurgeScript, each object defines a state machine (more on that later). The initial state is called \nmain\n. In the code presented, we display a \nHello, world!\n message and then exit the application.\n\n\nLet's go on and read \nIntroduction to objects\n. Or, alternatively, you may want to \ntest your scripts\n.", 
            "title": "Hello, World!"
        }, 
        {
            "location": "/tutorials/hello/#hello-world", 
            "text": "SurgeScript creates automatically an object called  Application . That object is defined by the user. Let's see how we can use that to make a simple program:  object  Application \n{\n    state  main \n    {\n        Console.print( Hello, world! );\n        Application.exit();\n    }\n}  In SurgeScript, each object defines a state machine (more on that later). The initial state is called  main . In the code presented, we display a  Hello, world!  message and then exit the application.  Let's go on and read  Introduction to objects . Or, alternatively, you may want to  test your scripts .", 
            "title": "Hello, World!"
        }, 
        {
            "location": "/tutorials/testing/", 
            "text": "Testing your scripts\n\n\nThere are two main ways of testing your scripts: using the Open Surge Engine or using only the standalone version of SurgeScript (without the game engine).\n\n\nTesting on Open Surge\n\n\nTODO\n\n\nUsing the standalone version\n\n\nIf you downloaded the standalone version of the language (i.e., SurgeScript without the full game engine):\n\n\n\n\nFirst of all, save the following script to a file named \nhello.ss\n. This file should be placed on the same directory as the surgescript executable.\n\n\n\n\nobject \nApplication\n\n{\n    state \nmain\n\n    {\n        Console.print(\nHello, world!\n);\n        Application.exit();\n    }\n}\n\n\n\n\n\n\nThen, open up a Terminal and type:\n\n\n\n\ncd /path/to/surgescript\n./surgescript hello.ss\n\n\n\n\n\n\nIf you're using Microsoft Windows, open up a Command Prompt and type:\n\n\n\n\ncd C:\\path\\to\\surgescript\nsurgescript.exe hello.ss\n\n\n\n\n\n\nYou should see the output of the script as a result:\n\n\n\n\nHello, world!", 
            "title": "Testing your scripts"
        }, 
        {
            "location": "/tutorials/testing/#testing-your-scripts", 
            "text": "There are two main ways of testing your scripts: using the Open Surge Engine or using only the standalone version of SurgeScript (without the game engine).", 
            "title": "Testing your scripts"
        }, 
        {
            "location": "/tutorials/testing/#testing-on-open-surge", 
            "text": "TODO", 
            "title": "Testing on Open Surge"
        }, 
        {
            "location": "/tutorials/testing/#using-the-standalone-version", 
            "text": "If you downloaded the standalone version of the language (i.e., SurgeScript without the full game engine):   First of all, save the following script to a file named  hello.ss . This file should be placed on the same directory as the surgescript executable.   object  Application \n{\n    state  main \n    {\n        Console.print( Hello, world! );\n        Application.exit();\n    }\n}   Then, open up a Terminal and type:   cd /path/to/surgescript\n./surgescript hello.ss   If you're using Microsoft Windows, open up a Command Prompt and type:   cd C:\\path\\to\\surgescript\nsurgescript.exe hello.ss   You should see the output of the script as a result:   Hello, world!", 
            "title": "Using the standalone version"
        }, 
        {
            "location": "/tutorials/objects/", 
            "text": "Introduction to objects\n\n\nIn SurgeScript, objects are units of code and data. Each object define a finite state machine, a mathematical construct used to describe the behavior of in-game objects. But what's a finite state machine?\n\n\nState machines\n\n\nA finite state machine is a mathematical abstraction composed of a finite number of \nstates\n and by \ntransitions\n between these states. Only one state can be active at any given time.\n\n\nAs a concrete example, suppose that you want to create a door in your game. You, the developer, may open or close the door at will.\n\n\nThat is said to be an \ninformal\n description of the problem. We need to transform it in something more rigorous. What is a door? We'll show one possible solution here.\n\n\nA door is an object with two states (see Figure below):\n\n\n\n\nOpened\n\n\nClosed\n\n\n\n\n\n\nFrom the Opened state, only one transition is possible: Close. Once the Close transition is called, the door will go to the Closed state. Conversely, from the Closed state, only one transition is available: Open. When the Open transition is executed, the door will return to the Opened state.\n\n\nObjects in SurgeScript\n\n\nIn SurgeScript, each object has a name. Objects may have any number of states you'd like. The initial active state is always called \nmain\n. The syntax is as follows:\n\n\nobject \nname of the object\n\n{\n    state \nstate name\n\n    {\n        // code goes here\n    }\n}\n\n\n\n\nThe following code shows an example of a door that opens and closes (it keep changing states) every 2 seconds:\n\n\nobject \nCosmic Door\n\n{\n    state \nmain\n\n    {\n        // the object starts at the main state\n        state = \nopened\n; // go to the opened state\n    }\n\n    state \nopened\n\n    {\n        if(timeout(2)) // if we have been on the opened state for 2 seconds\n            state = \nclosed\n; // go to the closed state\n    }\n\n    state \nclosed\n\n    {\n        if(timeout(2))\n            state = \nopened\n;\n    }\n}\n\n\n\n\nNotice how the code just shown defines states and transitions between these states.\n\n\nNote:\n once a state is active, its code will be repeated (at every frame) until the state changes or until the object is destroyed.", 
            "title": "Introduction to objects"
        }, 
        {
            "location": "/tutorials/objects/#introduction-to-objects", 
            "text": "In SurgeScript, objects are units of code and data. Each object define a finite state machine, a mathematical construct used to describe the behavior of in-game objects. But what's a finite state machine?", 
            "title": "Introduction to objects"
        }, 
        {
            "location": "/tutorials/objects/#state-machines", 
            "text": "A finite state machine is a mathematical abstraction composed of a finite number of  states  and by  transitions  between these states. Only one state can be active at any given time.  As a concrete example, suppose that you want to create a door in your game. You, the developer, may open or close the door at will.  That is said to be an  informal  description of the problem. We need to transform it in something more rigorous. What is a door? We'll show one possible solution here.  A door is an object with two states (see Figure below):   Opened  Closed    From the Opened state, only one transition is possible: Close. Once the Close transition is called, the door will go to the Closed state. Conversely, from the Closed state, only one transition is available: Open. When the Open transition is executed, the door will return to the Opened state.", 
            "title": "State machines"
        }, 
        {
            "location": "/tutorials/objects/#objects-in-surgescript", 
            "text": "In SurgeScript, each object has a name. Objects may have any number of states you'd like. The initial active state is always called  main . The syntax is as follows:  object  name of the object \n{\n    state  state name \n    {\n        // code goes here\n    }\n}  The following code shows an example of a door that opens and closes (it keep changing states) every 2 seconds:  object  Cosmic Door \n{\n    state  main \n    {\n        // the object starts at the main state\n        state =  opened ; // go to the opened state\n    }\n\n    state  opened \n    {\n        if(timeout(2)) // if we have been on the opened state for 2 seconds\n            state =  closed ; // go to the closed state\n    }\n\n    state  closed \n    {\n        if(timeout(2))\n            state =  opened ;\n    }\n}  Notice how the code just shown defines states and transitions between these states.  Note:  once a state is active, its code will be repeated (at every frame) until the state changes or until the object is destroyed.", 
            "title": "Objects in SurgeScript"
        }, 
        {
            "location": "/tutorials/variables/", 
            "text": "Variables\n\n\nVariables are used to store data. SurgeScript features five primitive types (number, string, boolean, null and object). Variables can also point to more complex data structures (such as arrays and dictionaries), but these are always objects.\n\n\nTypes\n\n\nPrimitive types\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nExamples\n\n\n\n\n\n\n\n\n\n\nNumber\n\n\nA floating-point number\n\n\n1, 2, 3, 3.14159\n\n\n\n\n\n\nString\n\n\nSome text\n\n\n\"Hello, world!\", 'single-quoted'\n\n\n\n\n\n\nBoolean\n\n\nTrue or false\n\n\ntrue, false\n\n\n\n\n\n\nNull\n\n\nAn empty value\n\n\nnull\n\n\n\n\n\n\nObject\n\n\nReference to an object\n\n\nApplication, this\n\n\n\n\n\n\n\n\nAs an example, the script below features an object with 3 variables that may be accessed throughout the whole object:\n\n\nobject \nSurge\n\n{\n    name = \nSurge the Rabbit\n;\n    age = 23;\n    underage = false;\n\n    state \nmain\n\n    {\n        Console.print(name); // Surge the Rabbit\n        Console.print(age + \n years old\n); // 23 years old\n    }\n}\n\n\n\n\nBuilt-in data structures\n\n\nArrays\n\n\nArrays are collections of values that you may access using a zero-based index. Example:\n\n\nobject \nApplication\n\n{\n    // The 'characters' array hold 3 strings\n    characters = [ \nSurge\n, \nNeon\n, \nCharge\n ];\n\n    state \nmain\n\n    {\n        // who are the characters?\n        Console.print(\nThe characters are:\n);\n        Console.print(characters[0]); // will print Surge\n        Console.print(characters[1]); // will print Neon\n        Console.print(characters[2]); // will print Charge\n\n        // how many characters?\n        Console.print(\nNumber of characters:\n);\n        Console.print(characters.length); // will print 3\n    }\n}\n\n\n\n\nArrays have many interesting properties and operations that you can see in the \nLanguage Reference\n.\n\n\nDictionaries\n\n\nDictionaries are collections of key-value pairs. In some programming languages, these are known as associative arrays or simply hash tables. Here's the syntax:\n\n\nobject \nSurge\n\n{\n    // A dictionary that stores the weight (kg) of each character\n    weight = {\n        \nSurge\n: 35,\n        \nNeon\n: 20,\n        \nCharge\n: 37.5,\n        \nGimacian\n: 70\n    };\n\n    // print the weights\n    state \nmain\n\n    {\n        Console.print(\nSurge weighs \n + weight[\nSurge\n] + \n kg.\n);\n        Console.print(\nNeon weighs \n + weight[\nNeon\n] + \n kg.\n);\n        Console.print(\nCharge weighs \n + weight[\nCharge\n] + \n kg.\n);\n        Console.print(\nGimacian weighs \n + weight[\nGimacian\n] + \n kg.\n);\n    }\n}\n\n\n\n\nDictionaries have many interesting properties and operations that you can see in the \nLanguage Reference\n.\n\n\nCautionary note\n\n\nWhenever you define an array or a dictionary, you spawn a new object. One is advised to \nNOT\n define arrays or dictionaries within states, because the code within states run continuously. Therefore, new objects will be created at every frame, not just once.\n\n\nobject \nApplication\n\n{\n    // arr will be instantiated once the object is created\n    arr = [ 1, 2, 3 ]; // RIGHT!\n\n    state \nmain\n\n    {\n        // err is instantiated at every frame of the application,\n        // thus wasting memory with duplicate objects\n        err = [ \ndon't\n, \ndo\n, \nthis\n ]; // WRONG!\n    }\n}\n\n\n\n\nScoping\n\n\nVariables that are defined before any state or function are \nobject-level\n variables. This means that they can be accessed throughout the whole object. On the other hand, variables used exclusively inside states or functions are \nlocal variables\n. This means that their lifespan is restricted to their own block of code.\n\n\nobject \nSurge\n\n{\n    name = \nSurge the Rabbit\n; // object-level variable\n\n    state \nmain\n\n    {\n        weight = 35; // local variable\n        state = \nprint-data\n; // change the state\n    }\n\n    state \nprint-data\n\n    {\n        Console.print(name); // Surge the Rabbit\n        Console.print(weight); // ERROR: weight is not defined\n    }\n}\n\n\n\n\nFurthermore, \nobject-level\n variables may only be accessed within the object. Other objects may not read or write the variables directly (in other words, variables are \nprivate\n to the objects). You need to define \nfunctions\n or \ngetters and setters\n for that.", 
            "title": "Variables"
        }, 
        {
            "location": "/tutorials/variables/#variables", 
            "text": "Variables are used to store data. SurgeScript features five primitive types (number, string, boolean, null and object). Variables can also point to more complex data structures (such as arrays and dictionaries), but these are always objects.", 
            "title": "Variables"
        }, 
        {
            "location": "/tutorials/variables/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/tutorials/variables/#primitive-types", 
            "text": "Type  Description  Examples      Number  A floating-point number  1, 2, 3, 3.14159    String  Some text  \"Hello, world!\", 'single-quoted'    Boolean  True or false  true, false    Null  An empty value  null    Object  Reference to an object  Application, this     As an example, the script below features an object with 3 variables that may be accessed throughout the whole object:  object  Surge \n{\n    name =  Surge the Rabbit ;\n    age = 23;\n    underage = false;\n\n    state  main \n    {\n        Console.print(name); // Surge the Rabbit\n        Console.print(age +   years old ); // 23 years old\n    }\n}", 
            "title": "Primitive types"
        }, 
        {
            "location": "/tutorials/variables/#built-in-data-structures", 
            "text": "", 
            "title": "Built-in data structures"
        }, 
        {
            "location": "/tutorials/variables/#arrays", 
            "text": "Arrays are collections of values that you may access using a zero-based index. Example:  object  Application \n{\n    // The 'characters' array hold 3 strings\n    characters = [  Surge ,  Neon ,  Charge  ];\n\n    state  main \n    {\n        // who are the characters?\n        Console.print( The characters are: );\n        Console.print(characters[0]); // will print Surge\n        Console.print(characters[1]); // will print Neon\n        Console.print(characters[2]); // will print Charge\n\n        // how many characters?\n        Console.print( Number of characters: );\n        Console.print(characters.length); // will print 3\n    }\n}  Arrays have many interesting properties and operations that you can see in the  Language Reference .", 
            "title": "Arrays"
        }, 
        {
            "location": "/tutorials/variables/#dictionaries", 
            "text": "Dictionaries are collections of key-value pairs. In some programming languages, these are known as associative arrays or simply hash tables. Here's the syntax:  object  Surge \n{\n    // A dictionary that stores the weight (kg) of each character\n    weight = {\n         Surge : 35,\n         Neon : 20,\n         Charge : 37.5,\n         Gimacian : 70\n    };\n\n    // print the weights\n    state  main \n    {\n        Console.print( Surge weighs   + weight[ Surge ] +   kg. );\n        Console.print( Neon weighs   + weight[ Neon ] +   kg. );\n        Console.print( Charge weighs   + weight[ Charge ] +   kg. );\n        Console.print( Gimacian weighs   + weight[ Gimacian ] +   kg. );\n    }\n}  Dictionaries have many interesting properties and operations that you can see in the  Language Reference .", 
            "title": "Dictionaries"
        }, 
        {
            "location": "/tutorials/variables/#cautionary-note", 
            "text": "Whenever you define an array or a dictionary, you spawn a new object. One is advised to  NOT  define arrays or dictionaries within states, because the code within states run continuously. Therefore, new objects will be created at every frame, not just once.  object  Application \n{\n    // arr will be instantiated once the object is created\n    arr = [ 1, 2, 3 ]; // RIGHT!\n\n    state  main \n    {\n        // err is instantiated at every frame of the application,\n        // thus wasting memory with duplicate objects\n        err = [  don't ,  do ,  this  ]; // WRONG!\n    }\n}", 
            "title": "Cautionary note"
        }, 
        {
            "location": "/tutorials/variables/#scoping", 
            "text": "Variables that are defined before any state or function are  object-level  variables. This means that they can be accessed throughout the whole object. On the other hand, variables used exclusively inside states or functions are  local variables . This means that their lifespan is restricted to their own block of code.  object  Surge \n{\n    name =  Surge the Rabbit ; // object-level variable\n\n    state  main \n    {\n        weight = 35; // local variable\n        state =  print-data ; // change the state\n    }\n\n    state  print-data \n    {\n        Console.print(name); // Surge the Rabbit\n        Console.print(weight); // ERROR: weight is not defined\n    }\n}  Furthermore,  object-level  variables may only be accessed within the object. Other objects may not read or write the variables directly (in other words, variables are  private  to the objects). You need to define  functions  or  getters and setters  for that.", 
            "title": "Scoping"
        }, 
        {
            "location": "/tutorials/functions/", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/tutorials/tags/", 
            "text": "", 
            "title": "Tags"
        }, 
        {
            "location": "/tutorials/objects/", 
            "text": "Introduction to objects\n\n\nIn SurgeScript, objects are units of code and data. Each object define a finite state machine, a mathematical construct used to describe the behavior of in-game objects. But what's a finite state machine?\n\n\nState machines\n\n\nA finite state machine is a mathematical abstraction composed of a finite number of \nstates\n and by \ntransitions\n between these states. Only one state can be active at any given time.\n\n\nAs a concrete example, suppose that you want to create a door in your game. You, the developer, may open or close the door at will.\n\n\nThat is said to be an \ninformal\n description of the problem. We need to transform it in something more rigorous. What is a door? We'll show one possible solution here.\n\n\nA door is an object with two states (see Figure below):\n\n\n\n\nOpened\n\n\nClosed\n\n\n\n\n\n\nFrom the Opened state, only one transition is possible: Close. Once the Close transition is called, the door will go to the Closed state. Conversely, from the Closed state, only one transition is available: Open. When the Open transition is executed, the door will return to the Opened state.\n\n\nObjects in SurgeScript\n\n\nIn SurgeScript, each object has a name. Objects may have any number of states you'd like. The initial active state is always called \nmain\n. The syntax is as follows:\n\n\nobject \nname of the object\n\n{\n    state \nstate name\n\n    {\n        // code goes here\n    }\n}\n\n\n\n\nThe following code shows an example of a door that opens and closes (it keep changing states) every 2 seconds:\n\n\nobject \nCosmic Door\n\n{\n    state \nmain\n\n    {\n        // the object starts at the main state\n        state = \nopened\n; // go to the opened state\n    }\n\n    state \nopened\n\n    {\n        if(timeout(2)) // if we have been on the opened state for 2 seconds\n            state = \nclosed\n; // go to the closed state\n    }\n\n    state \nclosed\n\n    {\n        if(timeout(2))\n            state = \nopened\n;\n    }\n}\n\n\n\n\nNotice how the code just shown defines states and transitions between these states.\n\n\nNote:\n once a state is active, its code will be repeated (at every frame) until the state changes or until the object is destroyed.", 
            "title": "Entity-component-system"
        }, 
        {
            "location": "/tutorials/objects/#introduction-to-objects", 
            "text": "In SurgeScript, objects are units of code and data. Each object define a finite state machine, a mathematical construct used to describe the behavior of in-game objects. But what's a finite state machine?", 
            "title": "Introduction to objects"
        }, 
        {
            "location": "/tutorials/objects/#state-machines", 
            "text": "A finite state machine is a mathematical abstraction composed of a finite number of  states  and by  transitions  between these states. Only one state can be active at any given time.  As a concrete example, suppose that you want to create a door in your game. You, the developer, may open or close the door at will.  That is said to be an  informal  description of the problem. We need to transform it in something more rigorous. What is a door? We'll show one possible solution here.  A door is an object with two states (see Figure below):   Opened  Closed    From the Opened state, only one transition is possible: Close. Once the Close transition is called, the door will go to the Closed state. Conversely, from the Closed state, only one transition is available: Open. When the Open transition is executed, the door will return to the Opened state.", 
            "title": "State machines"
        }, 
        {
            "location": "/tutorials/objects/#objects-in-surgescript", 
            "text": "In SurgeScript, each object has a name. Objects may have any number of states you'd like. The initial active state is always called  main . The syntax is as follows:  object  name of the object \n{\n    state  state name \n    {\n        // code goes here\n    }\n}  The following code shows an example of a door that opens and closes (it keep changing states) every 2 seconds:  object  Cosmic Door \n{\n    state  main \n    {\n        // the object starts at the main state\n        state =  opened ; // go to the opened state\n    }\n\n    state  opened \n    {\n        if(timeout(2)) // if we have been on the opened state for 2 seconds\n            state =  closed ; // go to the closed state\n    }\n\n    state  closed \n    {\n        if(timeout(2))\n            state =  opened ;\n    }\n}  Notice how the code just shown defines states and transitions between these states.  Note:  once a state is active, its code will be repeated (at every frame) until the state changes or until the object is destroyed.", 
            "title": "Objects in SurgeScript"
        }, 
        {
            "location": "/tutorials/getters_and_setters/", 
            "text": "Getters and setters\n\n\nThere are no public variables in SurgeScript. This means that variables may only be accessed from the objects that defined them. However, SurgeScript has a \nsyntax sugar\n that allows objects to modify other objects' data in a way that looks like dealing with regular variables.\n\n\nSuppose you have an object called \nAnimal\n with a variable called \nsound\n and a function called \ntalk()\n:\n\n\nobject \nAnimal\n\n{\n    sound = \nmeow!\n;\n\n    fun talk()\n    {\n        Console.print(sound);\n    }\n}\n\n\n\n\nThis object can only say \nmeow!\n Let's see:\n\n\nobject \nApplication\n\n{\n    animal = spawn(\nAnimal\n);\n\n    state \nmain\n\n    {\n        animal.talk();\n    }\n}\n\n\n\n\nRun this script and you'll see:\n\n\nmeow!\n\n\n\n\nWhat if an external object could modify the sound of the animal? Trying to access \nanimal.sound\n externally will trigger an error, unless we define getters and setters:\n\n\nobject \nAnimal\n\n{\n    sound = \nmeow!\n;\n\n    fun talk()\n    {\n        Console.print(sound);\n    }\n\n    fun setSound(value)\n    {\n        sound = value;\n    }\n\n    fun getSound()\n    {\n        return sound;\n    }\n}\n\n\n\n\nNow, external objects may modify the \nsound\n variable. In reality, they are calling \nsetSound()\n and \ngetSound()\n behind the scenes, but the syntax sugar makes it much neater.\n\n\nobject \nApplication\n\n{\n    animal = spawn(\nAnimal\n);\n\n    state \nmain\n\n    {\n        animal.sound = 'rrrrgh!!!';\n        animal.talk();\n    }\n}\n\n\n\n\nAn advantage of defining getters and setters is that you control what goes inside the objects. You may want to validate the data before changing the internal variables of the objects, for example.", 
            "title": "Getters & setters"
        }, 
        {
            "location": "/tutorials/getters_and_setters/#getters-and-setters", 
            "text": "There are no public variables in SurgeScript. This means that variables may only be accessed from the objects that defined them. However, SurgeScript has a  syntax sugar  that allows objects to modify other objects' data in a way that looks like dealing with regular variables.  Suppose you have an object called  Animal  with a variable called  sound  and a function called  talk() :  object  Animal \n{\n    sound =  meow! ;\n\n    fun talk()\n    {\n        Console.print(sound);\n    }\n}  This object can only say  meow!  Let's see:  object  Application \n{\n    animal = spawn( Animal );\n\n    state  main \n    {\n        animal.talk();\n    }\n}  Run this script and you'll see:  meow!  What if an external object could modify the sound of the animal? Trying to access  animal.sound  externally will trigger an error, unless we define getters and setters:  object  Animal \n{\n    sound =  meow! ;\n\n    fun talk()\n    {\n        Console.print(sound);\n    }\n\n    fun setSound(value)\n    {\n        sound = value;\n    }\n\n    fun getSound()\n    {\n        return sound;\n    }\n}  Now, external objects may modify the  sound  variable. In reality, they are calling  setSound()  and  getSound()  behind the scenes, but the syntax sugar makes it much neater.  object  Application \n{\n    animal = spawn( Animal );\n\n    state  main \n    {\n        animal.sound = 'rrrrgh!!!';\n        animal.talk();\n    }\n}  An advantage of defining getters and setters is that you control what goes inside the objects. You may want to validate the data before changing the internal variables of the objects, for example.", 
            "title": "Getters and setters"
        }, 
        {
            "location": "/tutorials/objects/", 
            "text": "Introduction to objects\n\n\nIn SurgeScript, objects are units of code and data. Each object define a finite state machine, a mathematical construct used to describe the behavior of in-game objects. But what's a finite state machine?\n\n\nState machines\n\n\nA finite state machine is a mathematical abstraction composed of a finite number of \nstates\n and by \ntransitions\n between these states. Only one state can be active at any given time.\n\n\nAs a concrete example, suppose that you want to create a door in your game. You, the developer, may open or close the door at will.\n\n\nThat is said to be an \ninformal\n description of the problem. We need to transform it in something more rigorous. What is a door? We'll show one possible solution here.\n\n\nA door is an object with two states (see Figure below):\n\n\n\n\nOpened\n\n\nClosed\n\n\n\n\n\n\nFrom the Opened state, only one transition is possible: Close. Once the Close transition is called, the door will go to the Closed state. Conversely, from the Closed state, only one transition is available: Open. When the Open transition is executed, the door will return to the Opened state.\n\n\nObjects in SurgeScript\n\n\nIn SurgeScript, each object has a name. Objects may have any number of states you'd like. The initial active state is always called \nmain\n. The syntax is as follows:\n\n\nobject \nname of the object\n\n{\n    state \nstate name\n\n    {\n        // code goes here\n    }\n}\n\n\n\n\nThe following code shows an example of a door that opens and closes (it keep changing states) every 2 seconds:\n\n\nobject \nCosmic Door\n\n{\n    state \nmain\n\n    {\n        // the object starts at the main state\n        state = \nopened\n; // go to the opened state\n    }\n\n    state \nopened\n\n    {\n        if(timeout(2)) // if we have been on the opened state for 2 seconds\n            state = \nclosed\n; // go to the closed state\n    }\n\n    state \nclosed\n\n    {\n        if(timeout(2))\n            state = \nopened\n;\n    }\n}\n\n\n\n\nNotice how the code just shown defines states and transitions between these states.\n\n\nNote:\n once a state is active, its code will be repeated (at every frame) until the state changes or until the object is destroyed.", 
            "title": "Best practices"
        }, 
        {
            "location": "/tutorials/objects/#introduction-to-objects", 
            "text": "In SurgeScript, objects are units of code and data. Each object define a finite state machine, a mathematical construct used to describe the behavior of in-game objects. But what's a finite state machine?", 
            "title": "Introduction to objects"
        }, 
        {
            "location": "/tutorials/objects/#state-machines", 
            "text": "A finite state machine is a mathematical abstraction composed of a finite number of  states  and by  transitions  between these states. Only one state can be active at any given time.  As a concrete example, suppose that you want to create a door in your game. You, the developer, may open or close the door at will.  That is said to be an  informal  description of the problem. We need to transform it in something more rigorous. What is a door? We'll show one possible solution here.  A door is an object with two states (see Figure below):   Opened  Closed    From the Opened state, only one transition is possible: Close. Once the Close transition is called, the door will go to the Closed state. Conversely, from the Closed state, only one transition is available: Open. When the Open transition is executed, the door will return to the Opened state.", 
            "title": "State machines"
        }, 
        {
            "location": "/tutorials/objects/#objects-in-surgescript", 
            "text": "In SurgeScript, each object has a name. Objects may have any number of states you'd like. The initial active state is always called  main . The syntax is as follows:  object  name of the object \n{\n    state  state name \n    {\n        // code goes here\n    }\n}  The following code shows an example of a door that opens and closes (it keep changing states) every 2 seconds:  object  Cosmic Door \n{\n    state  main \n    {\n        // the object starts at the main state\n        state =  opened ; // go to the opened state\n    }\n\n    state  opened \n    {\n        if(timeout(2)) // if we have been on the opened state for 2 seconds\n            state =  closed ; // go to the closed state\n    }\n\n    state  closed \n    {\n        if(timeout(2))\n            state =  opened ;\n    }\n}  Notice how the code just shown defines states and transitions between these states.  Note:  once a state is active, its code will be repeated (at every frame) until the state changes or until the object is destroyed.", 
            "title": "Objects in SurgeScript"
        }, 
        {
            "location": "/reference/application/", 
            "text": "", 
            "title": "Application"
        }
    ]
}