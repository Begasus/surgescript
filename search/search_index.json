{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to SurgeScript!\n\n\n\n\nUnleash your creativity!\n\n\nSurgeScript is a scripting language for games. It lets you unleash your creativity and build your own amazing interactive content! It's such a joy to use SurgeScript! You will love it!\n\n\n\n\n\n\nHow do I learn SurgeScript?\n\n\nCheck out the \nSurgeScript Crash Course\n! Also take a look on the \nvideo tutorials\n and on the examples folder that comes with the software.\n\n\nSurgeScript in a nutshell\n\n\nSurgeScript is:\n\n\n\n\nA scripting language for games\n\n\nEasy for beginners, powerful for experts\n\n\nObject-oriented, dynamically typed and based on state machines\n\n\nFree and open source software\n\n\nBuilt in C, which is nearly universal\n\n\nNamed after a really charismatic character: Surge! - from \nOpen Surge\n\n\nThe only programming language in the world that natively allows you to tag objects with emoticons ;)\n\n\n\n\nWhy use SurgeScript?\n\n\nUnlike other programming languages, SurgeScript has been designed with the specific needs of games in mind. Its features include:\n\n\n\n\nThe state-machine pattern: objects are state machines\n\n\nThe composition approach: you may design complex objects and behaviors by means of composition\n\n\nThe hierarchy system: objects have a parent and may have children, in a tree-like structure\n\n\nThe game loop: it's defined implicitly\n\n\n\n\nOther benefits include:\n\n\n\n\nSmall footprint, easy to integrate\n\n\nC-like syntax, including plenty of features\n\n\nAutomatic garbage collection\n\n\nEasy to extend via Plugins\n\n\nIt's free and open source software\n\n\n\n\nThese features come from the experience of the developer dealing with game engines, applications related to computer graphics and so on. Some of the best practices have been incorporated into the language itself, making things really easy for developers and modders.\n\n\nWho created SurgeScript?\n\n\nSurgeScript has been created by \nAlexandre Martins\n, a computer scientist from Brazil. He has also created the \nOpen Surge game engine\n, hence the name SurgeScript.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#welcome-to-surgescript", 
            "text": "", 
            "title": "Welcome to SurgeScript!"
        }, 
        {
            "location": "/#unleash-your-creativity", 
            "text": "SurgeScript is a scripting language for games. It lets you unleash your creativity and build your own amazing interactive content! It's such a joy to use SurgeScript! You will love it!", 
            "title": "Unleash your creativity!"
        }, 
        {
            "location": "/#how-do-i-learn-surgescript", 
            "text": "Check out the  SurgeScript Crash Course ! Also take a look on the  video tutorials  and on the examples folder that comes with the software.", 
            "title": "How do I learn SurgeScript?"
        }, 
        {
            "location": "/#surgescript-in-a-nutshell", 
            "text": "SurgeScript is:   A scripting language for games  Easy for beginners, powerful for experts  Object-oriented, dynamically typed and based on state machines  Free and open source software  Built in C, which is nearly universal  Named after a really charismatic character: Surge! - from  Open Surge  The only programming language in the world that natively allows you to tag objects with emoticons ;)", 
            "title": "SurgeScript in a nutshell"
        }, 
        {
            "location": "/#why-use-surgescript", 
            "text": "Unlike other programming languages, SurgeScript has been designed with the specific needs of games in mind. Its features include:   The state-machine pattern: objects are state machines  The composition approach: you may design complex objects and behaviors by means of composition  The hierarchy system: objects have a parent and may have children, in a tree-like structure  The game loop: it's defined implicitly   Other benefits include:   Small footprint, easy to integrate  C-like syntax, including plenty of features  Automatic garbage collection  Easy to extend via Plugins  It's free and open source software   These features come from the experience of the developer dealing with game engines, applications related to computer graphics and so on. Some of the best practices have been incorporated into the language itself, making things really easy for developers and modders.", 
            "title": "Why use SurgeScript?"
        }, 
        {
            "location": "/#who-created-surgescript", 
            "text": "SurgeScript has been created by  Alexandre Martins , a computer scientist from Brazil. He has also created the  Open Surge game engine , hence the name SurgeScript.", 
            "title": "Who created SurgeScript?"
        }, 
        {
            "location": "/download/", 
            "text": "Download SurgeScript\n\n\nThere are two ways to get SurgeScript:\n\n\n\n\nThe first is to \nget Open Surge\n. This is recommended for most users.\n\n\nThe second is to \nget the standalone version\n of the language. This is useful if you're a developer and want to integrate SurgeScript into your own projects.\n\n\n\n\nOpen Surge\n\n\nTo get Open Surge, visit \nopensurge2d.org\n and follow the instructions there.\n\n\nWhen you get Open Surge, you also get a full game engine featuring SurgeScript. This allows you to create your own scripts and games with plenty of interactivity and ease.\n\n\nOnce you download Open Surge, the next step is to \ncreate your first script\n.\n\n\nStandalone version\n\n\nTo get the standalone version, go to the \nSurgeScript page on GitHub\n. There you'll find instructions on how to compile SurgeScript.\n\n\nWhen you compile SurgeScript, you'll end up with a text-only program. There are no graphics and no game engine is attached to it. You can try your scripts using the command line.\n\n\nOnce you get the standalone version, the next step is to \ncreate your first script\n.", 
            "title": "Download"
        }, 
        {
            "location": "/download/#download-surgescript", 
            "text": "There are two ways to get SurgeScript:   The first is to  get Open Surge . This is recommended for most users.  The second is to  get the standalone version  of the language. This is useful if you're a developer and want to integrate SurgeScript into your own projects.", 
            "title": "Download SurgeScript"
        }, 
        {
            "location": "/download/#open-surge", 
            "text": "To get Open Surge, visit  opensurge2d.org  and follow the instructions there.  When you get Open Surge, you also get a full game engine featuring SurgeScript. This allows you to create your own scripts and games with plenty of interactivity and ease.  Once you download Open Surge, the next step is to  create your first script .", 
            "title": "Open Surge"
        }, 
        {
            "location": "/download/#standalone-version", 
            "text": "To get the standalone version, go to the  SurgeScript page on GitHub . There you'll find instructions on how to compile SurgeScript.  When you compile SurgeScript, you'll end up with a text-only program. There are no graphics and no game engine is attached to it. You can try your scripts using the command line.  Once you get the standalone version, the next step is to  create your first script .", 
            "title": "Standalone version"
        }, 
        {
            "location": "/tutorials/hello/", 
            "text": "Hello, World!\n\n\nSurgeScript creates automatically an object called \nApplication\n. That object is defined by the user. Let's see how we can use that to make a simple program:\n\n\nobject \nApplication\n\n{\n    state \nmain\n\n    {\n        Console.print(\nHello, world!\n);\n        Application.exit();\n    }\n}\n\n\n\n\nIn SurgeScript, each object defines a state machine (more on that later). The initial state is called \nmain\n. In the code just presented, we display a \nHello, world!\n message and then exit the app.\n\n\nNow let's \ntest your scripts\n.", 
            "title": "Hello, World!"
        }, 
        {
            "location": "/tutorials/hello/#hello-world", 
            "text": "SurgeScript creates automatically an object called  Application . That object is defined by the user. Let's see how we can use that to make a simple program:  object  Application \n{\n    state  main \n    {\n        Console.print( Hello, world! );\n        Application.exit();\n    }\n}  In SurgeScript, each object defines a state machine (more on that later). The initial state is called  main . In the code just presented, we display a  Hello, world!  message and then exit the app.  Now let's  test your scripts .", 
            "title": "Hello, World!"
        }, 
        {
            "location": "/tutorials/testing/", 
            "text": "Testing your scripts\n\n\nThere are two main ways to test your scripts:\n\n\n\n\nusing the \nOpen Surge\n game engine;\n\n\nusing the \nSurgeScript standalone runtime\n (i.e., the version without a game engine).\n\n\n\n\nUsing Open Surge\n\n\nTo test a script on Open Surge, place it on the \nscripts/\n folder and start the engine. Your test script must include an object called \nApplication\n. Please remove the script after you're done with the testing.\n\n\nAs an example, save the following script to \nscripts/hello.ss\n and start the engine:\n\n\n// hello.ss: test script\n// Please remove this file after you're done\nobject \nApplication\n\n{\n    state \nmain\n\n    {\n        Console.print(\nHello, world!\n);\n        state = \nblank\n;\n    }\n\n    state \nblank\n\n    {\n    }\n}\n\n\n\n\nYou should see the \nHello, world!\n message as a result.\n\n\nReady to proceed? Let's go to \nIntroduction to objects\n!\n\n\nUsing the standalone version\n\n\nIf you've downloaded the standalone version of the language:\n\n\n\n\nFirst of all, save the following script to a file named \nhello.ss\n. For testing purposes, please place the file on the same directory as the surgescript executable.\n\n\n\n\n// hello.ss: test script\nobject \nApplication\n\n{\n    state \nmain\n\n    {\n        Console.print(\nHello, world!\n);\n        Application.exit();\n    }\n}\n\n\n\n\n\n\nThen, open up a Terminal and type:\n\n\n\n\ncd /path/to/surgescript\n./surgescript hello.ss\n\n\n\n\n\n\nIf you're using Microsoft Windows, open up a Command Prompt and type:\n\n\n\n\ncd C:\\path\\to\\surgescript\nsurgescript.exe hello.ss\n\n\n\n\n\n\nYou should see the output of the script as a result:\n\n\n\n\nHello, world!\n\n\n\n\nTo begin our learning adventure, let's go to \nIntroduction to objects\n.", 
            "title": "Testing your scripts"
        }, 
        {
            "location": "/tutorials/testing/#testing-your-scripts", 
            "text": "There are two main ways to test your scripts:   using the  Open Surge  game engine;  using the  SurgeScript standalone runtime  (i.e., the version without a game engine).", 
            "title": "Testing your scripts"
        }, 
        {
            "location": "/tutorials/testing/#using-open-surge", 
            "text": "To test a script on Open Surge, place it on the  scripts/  folder and start the engine. Your test script must include an object called  Application . Please remove the script after you're done with the testing.  As an example, save the following script to  scripts/hello.ss  and start the engine:  // hello.ss: test script\n// Please remove this file after you're done\nobject  Application \n{\n    state  main \n    {\n        Console.print( Hello, world! );\n        state =  blank ;\n    }\n\n    state  blank \n    {\n    }\n}  You should see the  Hello, world!  message as a result.  Ready to proceed? Let's go to  Introduction to objects !", 
            "title": "Using Open Surge"
        }, 
        {
            "location": "/tutorials/testing/#using-the-standalone-version", 
            "text": "If you've downloaded the standalone version of the language:   First of all, save the following script to a file named  hello.ss . For testing purposes, please place the file on the same directory as the surgescript executable.   // hello.ss: test script\nobject  Application \n{\n    state  main \n    {\n        Console.print( Hello, world! );\n        Application.exit();\n    }\n}   Then, open up a Terminal and type:   cd /path/to/surgescript\n./surgescript hello.ss   If you're using Microsoft Windows, open up a Command Prompt and type:   cd C:\\path\\to\\surgescript\nsurgescript.exe hello.ss   You should see the output of the script as a result:   Hello, world!  To begin our learning adventure, let's go to  Introduction to objects .", 
            "title": "Using the standalone version"
        }, 
        {
            "location": "/tutorials/objects/", 
            "text": "Introduction to objects\n\n\nIn SurgeScript, objects are units of code and data. Each object define a finite state machine, a mathematical construct used to describe the behavior of in-game objects.\n\n\n\n\nDid you know?\n\n\nGames implement what is called a game loop. In SurgeScript, the game loop is defined implicitly via state machines. State machines are one of the key features of SurgeScript.\n\n\n\n\nState machines\n\n\nA finite state machine is a mathematical abstraction composed of a finite number of \nstates\n and by \ntransitions\n between these states. Only one state can be active at any given time (we'll call it the active state). There must be one \ninitial state\n (i.e., the first one to be active). A transition is a change of the active state that is triggered when a certain condition is met.\n\n\nAs a concrete example, suppose that you want to create a door in your game. You, the developer, may open or close the door at will. But what is a door? We have just given \ninformal\n description of the problem. However, we need to transform it in something more rigorous. Example:\n\n\nA door is an object with two states (see the Figure below):\n\n\n\n\nOpened (initial state)\n\n\nClosed\n\n\n\n\n\n\nFrom the Opened state, only one transition is possible: Close. Once the Close transition is called, the door will go to the Closed state. Conversely, from the Closed state, only one transition is available: Open. When the Open transition is executed, the door will return to the Opened state.\n\n\nObjects in SurgeScript\n\n\nIn SurgeScript, each object has a name. Objects may have any number of states you'd like. The initial state is always called \nmain\n. The syntax is as follows:\n\n\nobject \nname of the object\n\n{\n    state \nstate name\n\n    {\n        // code goes here\n    }\n}\n\n\n\n\nThe following code shows an example of a door that opens and closes (it keep changing states) every 2 seconds:\n\n\nobject \nCosmic Door\n\n{\n    state \nmain\n\n    {\n        // the object starts at the main state\n        state = \nopened\n; // go to the opened state\n    }\n\n    state \nopened\n\n    {\n        if(timeout(2)) // if we have been on the opened state for 2+ seconds\n            state = \nclosed\n; // go to the closed state\n    }\n\n    state \nclosed\n\n    {\n        if(timeout(2))\n            state = \nopened\n;\n    }\n}\n\n\n\n\nNotice how the code just shown defines states and transitions between these states. Each state contains its own code.\n\n\nNote:\n once a state is active, its code will be repeated (at every frame of the application) until the state changes or until the object is destroyed.", 
            "title": "Introduction to objects"
        }, 
        {
            "location": "/tutorials/objects/#introduction-to-objects", 
            "text": "In SurgeScript, objects are units of code and data. Each object define a finite state machine, a mathematical construct used to describe the behavior of in-game objects.   Did you know?  Games implement what is called a game loop. In SurgeScript, the game loop is defined implicitly via state machines. State machines are one of the key features of SurgeScript.", 
            "title": "Introduction to objects"
        }, 
        {
            "location": "/tutorials/objects/#state-machines", 
            "text": "A finite state machine is a mathematical abstraction composed of a finite number of  states  and by  transitions  between these states. Only one state can be active at any given time (we'll call it the active state). There must be one  initial state  (i.e., the first one to be active). A transition is a change of the active state that is triggered when a certain condition is met.  As a concrete example, suppose that you want to create a door in your game. You, the developer, may open or close the door at will. But what is a door? We have just given  informal  description of the problem. However, we need to transform it in something more rigorous. Example:  A door is an object with two states (see the Figure below):   Opened (initial state)  Closed    From the Opened state, only one transition is possible: Close. Once the Close transition is called, the door will go to the Closed state. Conversely, from the Closed state, only one transition is available: Open. When the Open transition is executed, the door will return to the Opened state.", 
            "title": "State machines"
        }, 
        {
            "location": "/tutorials/objects/#objects-in-surgescript", 
            "text": "In SurgeScript, each object has a name. Objects may have any number of states you'd like. The initial state is always called  main . The syntax is as follows:  object  name of the object \n{\n    state  state name \n    {\n        // code goes here\n    }\n}  The following code shows an example of a door that opens and closes (it keep changing states) every 2 seconds:  object  Cosmic Door \n{\n    state  main \n    {\n        // the object starts at the main state\n        state =  opened ; // go to the opened state\n    }\n\n    state  opened \n    {\n        if(timeout(2)) // if we have been on the opened state for 2+ seconds\n            state =  closed ; // go to the closed state\n    }\n\n    state  closed \n    {\n        if(timeout(2))\n            state =  opened ;\n    }\n}  Notice how the code just shown defines states and transitions between these states. Each state contains its own code.  Note:  once a state is active, its code will be repeated (at every frame of the application) until the state changes or until the object is destroyed.", 
            "title": "Objects in SurgeScript"
        }, 
        {
            "location": "/tutorials/variables/", 
            "text": "Variables\n\n\nVariables are used to store data. SurgeScript features five primitive types (number, string, boolean, null and object handle). Variables can also point to more complex data structures (such as arrays and dictionaries), but these are always objects.\n\n\nTypes\n\n\nPrimitive types\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nExamples\n\n\n\n\n\n\n\n\n\n\nNumber\n\n\nA floating-point number\n\n\n1, 2, 3, 3.14159\n\n\n\n\n\n\nString\n\n\nSome text\n\n\n\"Hello, world!\", 'single-quoted'\n\n\n\n\n\n\nBoolean\n\n\nTrue or false\n\n\ntrue, false\n\n\n\n\n\n\nObject\n\n\nReference to an object\n\n\nApplication, this, [ ]\n\n\n\n\n\n\nNull\n\n\nAn empty value\n\n\nnull\n\n\n\n\n\n\n\n\nAs an example, the script below features an object with 3 variables that may be accessed throughout the whole object:\n\n\nobject \nApplication\n\n{\n    name = \nSurge the Rabbit\n;\n    age = 23;\n    underage = false;\n\n    state \nmain\n\n    {\n        Console.print(name); // Surge the Rabbit\n        Console.print(age); // 23\n    }\n}\n\n\n\n\nAbstract types\n\n\nArrays\n\n\nArrays are collections of values that you may access using a zero-based index. Example:\n\n\nobject \nApplication\n\n{\n    // The 'characters' array hold 3 strings\n    characters = [ \nSurge\n, \nNeon\n, \nCharge\n ];\n\n    state \nmain\n\n    {\n        // who are the characters?\n        Console.print(\nThe characters are:\n);\n        Console.print(characters[0]); // will print Surge\n        Console.print(characters[1]); // will print Neon\n        Console.print(characters[2]); // will print Charge\n\n        // how many characters?\n        Console.print(\nNumber of characters:\n);\n        Console.print(characters.length); // will print 3\n    }\n}\n\n\n\n\nArrays have many interesting properties and operations that you can see in the \nLanguage Reference\n.\n\n\nDictionaries\n\n\nDictionaries are collections of key-value pairs. In some programming languages, these are known as associative arrays or hash tables. Here's the syntax:\n\n\nobject \nApplication\n\n{\n    // A dictionary that stores the weight (kg) of each character\n    weight = {\n        \nSurge\n: 35,\n        \nNeon\n: 20,\n        \nCharge\n: 37.5,\n        \nGimacian\n: 70\n    };\n\n    // print the weights\n    state \nmain\n\n    {\n        Console.print(\nSurge weighs \n + weight[\nSurge\n] + \n kg.\n);\n        Console.print(\nNeon weighs \n + weight[\nNeon\n] + \n kg.\n);\n        Console.print(\nCharge weighs \n + weight[\nCharge\n] + \n kg.\n);\n        Console.print(\nGimacian weighs \n + weight[\nGimacian\n] + \n kg.\n);\n    }\n}\n\n\n\n\nDictionaries have many interesting properties and operations that you can see in the \nLanguage Reference\n.\n\n\n\n\nCautionary note\n\n\nWhenever you define an array or a dictionary, you spawn a new object. One is advised to \nNOT\n define arrays or dictionaries within states, because the code within states run continuously. Therefore, new objects will be created at every frame, not just once.\n\n\n\n\nobject \nApplication\n\n{\n    // arr will be instantiated once the object is created\n    arr = [ 1, 2, 3 ]; // RIGHT!\n\n    state \nmain\n\n    {\n        // err is instantiated at every frame of the application,\n        // thus memory is wasted with duplicate objects\n        err = [ \ndon't\n, \ndo\n, \nthis\n ]; // WRONG!\n    }\n}\n\n\n\n\nCasting\n\n\nYou can use type-casting to change the type of values from number to string, from string to number, from boolean to string and so on. Casting values is as simple as calling \nNumber(value)\n, \nString(value)\n or \nBoolean(value)\n. Example:\n\n\n// Convert string to number\nstr = \n2\n;\nval = Number(str); // val is 2\n\n// Convert number to string\nval = 123;\nstr = String(val); // str is \n123\n\n\n\n\n\nWhen converting an object to a string, SurgeScript will implicitly call \nobject.toString()\n.\n\n\nScoping\n\n\nVariables that are defined before any state or function are \nobject-level\n variables. They can be accessed throughout the whole object. On the other hand, variables used exclusively inside states or functions are \nlocal variables\n. This means that their lifespan is restricted to their own locus of code.\n\n\nobject \nScopeTest\n\n{\n    name = \nSurge the Rabbit\n; // object-level variable\n\n    state \nmain\n\n    {\n        weight = 35; // local variable\n        state = \nprint-data\n; // change the state\n    }\n\n    state \nprint-data\n\n    {\n        Console.print(name); // Surge the Rabbit\n        Console.print(weight); // ERROR: weight is not defined\n    }\n}\n\n\n\n\nFurthermore, \nobject-level\n variables may only be accessed within the object. Other objects may not read or write the variables directly (in other words, variables are \nprivate\n to the objects). You need to define \nfunctions\n or \ngetters and setters\n to accomplish that.", 
            "title": "Variables"
        }, 
        {
            "location": "/tutorials/variables/#variables", 
            "text": "Variables are used to store data. SurgeScript features five primitive types (number, string, boolean, null and object handle). Variables can also point to more complex data structures (such as arrays and dictionaries), but these are always objects.", 
            "title": "Variables"
        }, 
        {
            "location": "/tutorials/variables/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/tutorials/variables/#primitive-types", 
            "text": "Type  Description  Examples      Number  A floating-point number  1, 2, 3, 3.14159    String  Some text  \"Hello, world!\", 'single-quoted'    Boolean  True or false  true, false    Object  Reference to an object  Application, this, [ ]    Null  An empty value  null     As an example, the script below features an object with 3 variables that may be accessed throughout the whole object:  object  Application \n{\n    name =  Surge the Rabbit ;\n    age = 23;\n    underage = false;\n\n    state  main \n    {\n        Console.print(name); // Surge the Rabbit\n        Console.print(age); // 23\n    }\n}", 
            "title": "Primitive types"
        }, 
        {
            "location": "/tutorials/variables/#abstract-types", 
            "text": "", 
            "title": "Abstract types"
        }, 
        {
            "location": "/tutorials/variables/#arrays", 
            "text": "Arrays are collections of values that you may access using a zero-based index. Example:  object  Application \n{\n    // The 'characters' array hold 3 strings\n    characters = [  Surge ,  Neon ,  Charge  ];\n\n    state  main \n    {\n        // who are the characters?\n        Console.print( The characters are: );\n        Console.print(characters[0]); // will print Surge\n        Console.print(characters[1]); // will print Neon\n        Console.print(characters[2]); // will print Charge\n\n        // how many characters?\n        Console.print( Number of characters: );\n        Console.print(characters.length); // will print 3\n    }\n}  Arrays have many interesting properties and operations that you can see in the  Language Reference .", 
            "title": "Arrays"
        }, 
        {
            "location": "/tutorials/variables/#dictionaries", 
            "text": "Dictionaries are collections of key-value pairs. In some programming languages, these are known as associative arrays or hash tables. Here's the syntax:  object  Application \n{\n    // A dictionary that stores the weight (kg) of each character\n    weight = {\n         Surge : 35,\n         Neon : 20,\n         Charge : 37.5,\n         Gimacian : 70\n    };\n\n    // print the weights\n    state  main \n    {\n        Console.print( Surge weighs   + weight[ Surge ] +   kg. );\n        Console.print( Neon weighs   + weight[ Neon ] +   kg. );\n        Console.print( Charge weighs   + weight[ Charge ] +   kg. );\n        Console.print( Gimacian weighs   + weight[ Gimacian ] +   kg. );\n    }\n}  Dictionaries have many interesting properties and operations that you can see in the  Language Reference .   Cautionary note  Whenever you define an array or a dictionary, you spawn a new object. One is advised to  NOT  define arrays or dictionaries within states, because the code within states run continuously. Therefore, new objects will be created at every frame, not just once.   object  Application \n{\n    // arr will be instantiated once the object is created\n    arr = [ 1, 2, 3 ]; // RIGHT!\n\n    state  main \n    {\n        // err is instantiated at every frame of the application,\n        // thus memory is wasted with duplicate objects\n        err = [  don't ,  do ,  this  ]; // WRONG!\n    }\n}", 
            "title": "Dictionaries"
        }, 
        {
            "location": "/tutorials/variables/#casting", 
            "text": "You can use type-casting to change the type of values from number to string, from string to number, from boolean to string and so on. Casting values is as simple as calling  Number(value) ,  String(value)  or  Boolean(value) . Example:  // Convert string to number\nstr =  2 ;\nval = Number(str); // val is 2\n\n// Convert number to string\nval = 123;\nstr = String(val); // str is  123   When converting an object to a string, SurgeScript will implicitly call  object.toString() .", 
            "title": "Casting"
        }, 
        {
            "location": "/tutorials/variables/#scoping", 
            "text": "Variables that are defined before any state or function are  object-level  variables. They can be accessed throughout the whole object. On the other hand, variables used exclusively inside states or functions are  local variables . This means that their lifespan is restricted to their own locus of code.  object  ScopeTest \n{\n    name =  Surge the Rabbit ; // object-level variable\n\n    state  main \n    {\n        weight = 35; // local variable\n        state =  print-data ; // change the state\n    }\n\n    state  print-data \n    {\n        Console.print(name); // Surge the Rabbit\n        Console.print(weight); // ERROR: weight is not defined\n    }\n}  Furthermore,  object-level  variables may only be accessed within the object. Other objects may not read or write the variables directly (in other words, variables are  private  to the objects). You need to define  functions  or  getters and setters  to accomplish that.", 
            "title": "Scoping"
        }, 
        {
            "location": "/tutorials/expressions/", 
            "text": "Expressions\n\n\nSurgeScript supports many kinds of expressions. Expressions may involve strings, numbers or booleans. Let's study each case:\n\n\nConstants\n\n\nConstants are types of expressions. They may be numbers, strings, booleans... You may attribute constant values to variables using the assignment operator (\n=\n):\n\n\n// strings\nname = \nSurge\n; // variable name receives string \nSurge\n\nmessage = \nSurge's home\n;\notherMessage = 'Single-quoted strings are also allowed';\n\n// numbers\nweight = 35;\nspeed = 42.2;\n\n// booleans\nlike = true;\ncrazy = false;\n\n// null\nnext = null;\n\n\n\n\nArithmetic operators\n\n\nSurgeScript can perform basic arithmetic. The operators are as follows:\n\n\n\n\n\n\n\n\nOperator\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n+\n\n\nAddition\n\n\n\n\n\n\n-\n\n\nSubtraction\n\n\n\n\n\n\n*\n\n\nMultiplication\n\n\n\n\n\n\n/\n\n\nDivision\n\n\n\n\n\n\n%\n\n\nRemainder\n\n\n\n\n\n\n\n\nThe multiplication, division and remainder operators have precedence over the addition and the subtraction operators.\n\n\nExamples:\n\n\ntwo = 1 + 1;\nten = 5 * 2;\neleven = 5 * 2 + 1;\nfour = two * two;\nfifteen = eleven + four;\nthree = fifteen / 5;\npositive = +5;\nnegative = -1;\nzero = 15 - 10 - 5;\none = 15 - (10 + 4);\ntwelve = (2 + 2) * 3;\nprime = -(-15 + 8);\nseven = 5 + 5 % 3;\nnegativeTwo = -5 % 3;\n\n\n\n\nComparison operators\n\n\nComparison operators compare two operands.\n\n\n\n\n\n\n\n\nOperator\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n==\n\n\nEquality operator\n\n\n\n\n\n\n!=\n\n\nInequality operator\n\n\n\n\n\n\n\n\nLess than\n\n\n\n\n\n\n=\n\n\nLess or equal\n\n\n\n\n\n\n>\n\n\nGreater than\n\n\n\n\n\n\n>=\n\n\nGreater or equal\n\n\n\n\n\n\n===\n\n\nStrong equality\n\n\n\n\n\n\n!==\n\n\nStrong inequality\n\n\n\n\n\n\n\n\nExamples:\n\n\nx = 1;\ny = (x == 1); // y is true\nz = (x != 1); // z is false\nw = x \n 1; // w is false\nt = x \n= 1; // t is true\n\n\n\n\n\n\nPay attention!\n\n\nNotice that the equality operator, used for comparing expressions for equality, is \n==\n. Pay attention! Don't confuse the equality operator (\n==\n) with the assignment operator (\n=\n). The expression \n(x = 1)\n always evaluates to 1, whereas \n(x == 1)\n is \ntrue\n only if x equals 1.\n\n\nStrong equality\n\n\nUnlike their counterparts, strong equality/inequality operators compare not only the content of the operands, but also their type. While \n\"1\" == 1\n evalutes to \ntrue\n, \n\"1\" === 1\n does not.\n\n\n\n\nLogical operators\n\n\nLogical operators involve booleans (\ntrue\n or \nfalse\n values). While the \nnot\n operator requires only one operand, operators \nand\n and \nor\n require two.\n\n\n\n\n\n\n\n\nOperator\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n\n\nand\n\n\n\n\n\n\n||\n\n\nor\n\n\n\n\n\n\n!\n\n\nnot\n\n\n\n\n\n\n\n\nThe table below summarizes the basic logical expressions:\n\n\n\n\n\n\n\n\nExpression\n\n\nResult\n\n\n\n\n\n\n\n\n\n\na \n b\n\n\ntrue\n only if both a and b are true\n\n\n\n\n\n\na || b\n\n\ntrue\n if either a or b are true (or both)\n\n\n\n\n\n\n!a\n\n\ntrue\n if a is false, \nfalse\n if a is true\n\n\n\n\n\n\n\n\nNotice that \nnot\n has higher precedence than the other two operators. Examples:\n\n\nx = 5 \n 2; // evaluates to false\ny = !x; // evaluates to true\nz = 18 \n 35 || x; // evaluates to true\nw = (z \n x) || true; // evaluates to true\nt = !x \n x; // evaluates to false\n\n\n\n\nTextual expressions\n\n\nYou may concatenate strings with the \n+\n operator. Example:\n\n\nmessage = \nSurge\n + \n rocks!\n; // evaluates to \nSurge rocks!\n\n\n\n\n\nOther data types, such as numbers and booleans, may also be implicitly converted to strings when using this feature. Example:\n\n\ngroup = \nJackson \n + 5; // evaluates to \nJackson 5\n\n\n\n\n\nAssignment operators\n\n\nThe attribution operator (\n=\n) may be used to attribute data to variables. However, there's more to that. The expression \nvariable = \"data\"\n is itself evaluated to string \n\"data\"\n.\n\n\nLikewise, the expression \nvariable = variable + 5\n is evaluated to \nvariable + 5\n and may be shortened to \nvariable += 5\n.\n\n\nLet's see what kind of assignment expressions we have:\n\n\n\n\n\n\n\n\nExpression\n\n\nTranslates to\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nx = value\n\n\nx = value\n\n\nAssigns \nvalue\n to \nx\n\n\n\n\n\n\nx += value\n\n\nx = x + value\n\n\nAdds \nvalue\n to \nx\n\n\n\n\n\n\nx -= value\n\n\nx = x - value\n\n\nSubtracts \nvalue\n from \nx\n\n\n\n\n\n\nx *= value\n\n\nx = x * value\n\n\nMultiplies \nx\n by \nvalue\n\n\n\n\n\n\nx /= value\n\n\nx = x / value\n\n\nDivides \nx\n by \nvalue\n\n\n\n\n\n\nx %= value\n\n\nx = x % value\n\n\nSets \nx\n to the remainder of \nx / value\n\n\n\n\n\n\n\n\nExample:\n\n\nlanguage = \nSurge\n;\nlanguage += \nScript\n;\n// language now evaluates to \nSurgeScript\n\n\nnumber = 5;\nnumber += 2;\n// number now evaluates to 7\n\n\n\n\nIncrement and decrement\n\n\nIncrement and decrement operators should be used only on numeric variables.\n\n\n\n\n\n\n\n\nExpression\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nx++\n\n\nIncrements x by 1 and returns the old value of x\n\n\n\n\n\n\nx--\n\n\nDecrements x by 1 and returns the old value of x\n\n\n\n\n\n\n++x\n\n\nIncrements x by 1 and returns the new value of x\n\n\n\n\n\n\n--x\n\n\nDecrements x by 1 and returns the new value of x\n\n\n\n\n\n\n\n\nExample:\n\n\nx = 1;   // x is 1\ny = x++; // y is 1\nz = ++x; // z is 3\nw = --x; // w is 2\nt = --x; // t is 1\nConsole.print(x); // prints 1\n\n\n\n\nChained expressions\n\n\nYou may chain assignment operations:\n\n\nx = y = z = 1;\n\n\n\n\nUsing commas will evaluate all expressions between then and return the right-most one:\n\n\nx = 1; // x is 1\ny = x++, 2; // y is 2\nz = y--, --x; // z is 1\n// x, y and z end up equal to 1\n\n\n\n\nOther expressions\n\n\nthis\n\n\nThe keyword \nthis\n represents the object in which it appears. Example:\n\n\nthis.destroy(); // destroys this object\n\n\n\n\ntypeof\n\n\nThe expression \ntypeof(expr)\n (or simply \ntypeof expr\n), is evaluated to a string informing the type of \nexpr\n. The possible types are: \nnumber\n, \nstring\n, \nboolean\n, \nnull\n, \nobject\n. Example:\n\n\nt = typeof 5; // t will hold the string \nnumber\n\n\n\n\n\ntimeout\n\n\nThe expression \ntimeout(seconds)\n is a handy feature of SurgeScript. It is evaluated to \ntrue\n if the object has been on the same state for the specified amount of time or more. It can only be used inside states. Example:\n\n\nobject \nApplication\n\n{\n    state \nmain\n\n    {\n        if(timeout(2.0)) {\n            Console.print(\n2 seconds have passed\n);\n            state = \ndone\n;\n        }\n    }\n\n    state \ndone\n\n    {\n        Application.exit();\n    }\n}", 
            "title": "Expressions"
        }, 
        {
            "location": "/tutorials/expressions/#expressions", 
            "text": "SurgeScript supports many kinds of expressions. Expressions may involve strings, numbers or booleans. Let's study each case:", 
            "title": "Expressions"
        }, 
        {
            "location": "/tutorials/expressions/#constants", 
            "text": "Constants are types of expressions. They may be numbers, strings, booleans... You may attribute constant values to variables using the assignment operator ( = ):  // strings\nname =  Surge ; // variable name receives string  Surge \nmessage =  Surge's home ;\notherMessage = 'Single-quoted strings are also allowed';\n\n// numbers\nweight = 35;\nspeed = 42.2;\n\n// booleans\nlike = true;\ncrazy = false;\n\n// null\nnext = null;", 
            "title": "Constants"
        }, 
        {
            "location": "/tutorials/expressions/#arithmetic-operators", 
            "text": "SurgeScript can perform basic arithmetic. The operators are as follows:     Operator  Meaning      +  Addition    -  Subtraction    *  Multiplication    /  Division    %  Remainder     The multiplication, division and remainder operators have precedence over the addition and the subtraction operators.  Examples:  two = 1 + 1;\nten = 5 * 2;\neleven = 5 * 2 + 1;\nfour = two * two;\nfifteen = eleven + four;\nthree = fifteen / 5;\npositive = +5;\nnegative = -1;\nzero = 15 - 10 - 5;\none = 15 - (10 + 4);\ntwelve = (2 + 2) * 3;\nprime = -(-15 + 8);\nseven = 5 + 5 % 3;\nnegativeTwo = -5 % 3;", 
            "title": "Arithmetic operators"
        }, 
        {
            "location": "/tutorials/expressions/#comparison-operators", 
            "text": "Comparison operators compare two operands.     Operator  Meaning      ==  Equality operator    !=  Inequality operator     Less than    =  Less or equal    >  Greater than    >=  Greater or equal    ===  Strong equality    !==  Strong inequality     Examples:  x = 1;\ny = (x == 1); // y is true\nz = (x != 1); // z is false\nw = x   1; // w is false\nt = x  = 1; // t is true   Pay attention!  Notice that the equality operator, used for comparing expressions for equality, is  == . Pay attention! Don't confuse the equality operator ( == ) with the assignment operator ( = ). The expression  (x = 1)  always evaluates to 1, whereas  (x == 1)  is  true  only if x equals 1.  Strong equality  Unlike their counterparts, strong equality/inequality operators compare not only the content of the operands, but also their type. While  \"1\" == 1  evalutes to  true ,  \"1\" === 1  does not.", 
            "title": "Comparison operators"
        }, 
        {
            "location": "/tutorials/expressions/#logical-operators", 
            "text": "Logical operators involve booleans ( true  or  false  values). While the  not  operator requires only one operand, operators  and  and  or  require two.     Operator  Meaning       and    ||  or    !  not     The table below summarizes the basic logical expressions:     Expression  Result      a   b  true  only if both a and b are true    a || b  true  if either a or b are true (or both)    !a  true  if a is false,  false  if a is true     Notice that  not  has higher precedence than the other two operators. Examples:  x = 5   2; // evaluates to false\ny = !x; // evaluates to true\nz = 18   35 || x; // evaluates to true\nw = (z   x) || true; // evaluates to true\nt = !x   x; // evaluates to false", 
            "title": "Logical operators"
        }, 
        {
            "location": "/tutorials/expressions/#textual-expressions", 
            "text": "You may concatenate strings with the  +  operator. Example:  message =  Surge  +   rocks! ; // evaluates to  Surge rocks!   Other data types, such as numbers and booleans, may also be implicitly converted to strings when using this feature. Example:  group =  Jackson   + 5; // evaluates to  Jackson 5", 
            "title": "Textual expressions"
        }, 
        {
            "location": "/tutorials/expressions/#assignment-operators", 
            "text": "The attribution operator ( = ) may be used to attribute data to variables. However, there's more to that. The expression  variable = \"data\"  is itself evaluated to string  \"data\" .  Likewise, the expression  variable = variable + 5  is evaluated to  variable + 5  and may be shortened to  variable += 5 .  Let's see what kind of assignment expressions we have:     Expression  Translates to  Meaning      x = value  x = value  Assigns  value  to  x    x += value  x = x + value  Adds  value  to  x    x -= value  x = x - value  Subtracts  value  from  x    x *= value  x = x * value  Multiplies  x  by  value    x /= value  x = x / value  Divides  x  by  value    x %= value  x = x % value  Sets  x  to the remainder of  x / value     Example:  language =  Surge ;\nlanguage +=  Script ;\n// language now evaluates to  SurgeScript \n\nnumber = 5;\nnumber += 2;\n// number now evaluates to 7", 
            "title": "Assignment operators"
        }, 
        {
            "location": "/tutorials/expressions/#increment-and-decrement", 
            "text": "Increment and decrement operators should be used only on numeric variables.     Expression  Meaning      x++  Increments x by 1 and returns the old value of x    x--  Decrements x by 1 and returns the old value of x    ++x  Increments x by 1 and returns the new value of x    --x  Decrements x by 1 and returns the new value of x     Example:  x = 1;   // x is 1\ny = x++; // y is 1\nz = ++x; // z is 3\nw = --x; // w is 2\nt = --x; // t is 1\nConsole.print(x); // prints 1", 
            "title": "Increment and decrement"
        }, 
        {
            "location": "/tutorials/expressions/#chained-expressions", 
            "text": "You may chain assignment operations:  x = y = z = 1;  Using commas will evaluate all expressions between then and return the right-most one:  x = 1; // x is 1\ny = x++, 2; // y is 2\nz = y--, --x; // z is 1\n// x, y and z end up equal to 1", 
            "title": "Chained expressions"
        }, 
        {
            "location": "/tutorials/expressions/#other-expressions", 
            "text": "", 
            "title": "Other expressions"
        }, 
        {
            "location": "/tutorials/expressions/#this", 
            "text": "The keyword  this  represents the object in which it appears. Example:  this.destroy(); // destroys this object", 
            "title": "this"
        }, 
        {
            "location": "/tutorials/expressions/#typeof", 
            "text": "The expression  typeof(expr)  (or simply  typeof expr ), is evaluated to a string informing the type of  expr . The possible types are:  number ,  string ,  boolean ,  null ,  object . Example:  t = typeof 5; // t will hold the string  number", 
            "title": "typeof"
        }, 
        {
            "location": "/tutorials/expressions/#timeout", 
            "text": "The expression  timeout(seconds)  is a handy feature of SurgeScript. It is evaluated to  true  if the object has been on the same state for the specified amount of time or more. It can only be used inside states. Example:  object  Application \n{\n    state  main \n    {\n        if(timeout(2.0)) {\n            Console.print( 2 seconds have passed );\n            state =  done ;\n        }\n    }\n\n    state  done \n    {\n        Application.exit();\n    }\n}", 
            "title": "timeout"
        }, 
        {
            "location": "/tutorials/conditionals/", 
            "text": "Conditionals\n\n\nIntroduction\n\n\nConditionals are \nif ... then ...\n expressions. If a certain condition is \ntrue\n, execute a block of code. If not, don't execute it.\n\n\nif(condition) {\n    // this will be executed only if\n    // the condition is true\n}\n\n\n\n\nAlternatively, we may include an \nelse\n statement followed by a block of code that will only be executed if the condition is \nnot\n true:\n\n\nif(condition) {\n    // this will be executed only if\n    // the condition is true\n}\nelse {\n    // this will be executed only if\n    // the condition is false\n}\n\n\n\n\nExample\n\n\nThe following example will print \nunderaged\n if variable \nage\n is less than 18, or \nadult\n otherwise:\n\n\nobject \nApplication\n\n{\n    age = 23;\n\n    state \nmain\n\n    {\n        if(age \n 18) {\n            // variable age is less than 18\n            Console.print(\nunderaged\n);\n        }\n        else {\n            // variable age is not less than 18\n            Console.print(\nadult\n);\n        }\n\n        // we're done!\n        Application.exit();\n    }\n}\n\n\n\n\nInline conditionals\n\n\nJust like other languages with C-based syntax, the expression \ncondition ? true_value : false_value\n evaluates to \ntrue_value\n if \ncondition\n is \ntrue\n and to \nfalse_value\n if \ncondition\n is \nfalse\n.\n\n\nFor example, the script below will print \nunderaged\n if variable \nage\n is less than 18, or \nadult\n otherwise:\n\n\nobject \nApplication\n\n{\n    age = 23;\n    message = age \n 18 ? \nunderaged\n : \nadult\n;\n\n    state \nmain\n\n    {\n        Console.print(message);\n        Application.exit();\n    }\n}", 
            "title": "Conditionals"
        }, 
        {
            "location": "/tutorials/conditionals/#conditionals", 
            "text": "", 
            "title": "Conditionals"
        }, 
        {
            "location": "/tutorials/conditionals/#introduction", 
            "text": "Conditionals are  if ... then ...  expressions. If a certain condition is  true , execute a block of code. If not, don't execute it.  if(condition) {\n    // this will be executed only if\n    // the condition is true\n}  Alternatively, we may include an  else  statement followed by a block of code that will only be executed if the condition is  not  true:  if(condition) {\n    // this will be executed only if\n    // the condition is true\n}\nelse {\n    // this will be executed only if\n    // the condition is false\n}", 
            "title": "Introduction"
        }, 
        {
            "location": "/tutorials/conditionals/#example", 
            "text": "The following example will print  underaged  if variable  age  is less than 18, or  adult  otherwise:  object  Application \n{\n    age = 23;\n\n    state  main \n    {\n        if(age   18) {\n            // variable age is less than 18\n            Console.print( underaged );\n        }\n        else {\n            // variable age is not less than 18\n            Console.print( adult );\n        }\n\n        // we're done!\n        Application.exit();\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/tutorials/conditionals/#inline-conditionals", 
            "text": "Just like other languages with C-based syntax, the expression  condition ? true_value : false_value  evaluates to  true_value  if  condition  is  true  and to  false_value  if  condition  is  false .  For example, the script below will print  underaged  if variable  age  is less than 18, or  adult  otherwise:  object  Application \n{\n    age = 23;\n    message = age   18 ?  underaged  :  adult ;\n\n    state  main \n    {\n        Console.print(message);\n        Application.exit();\n    }\n}", 
            "title": "Inline conditionals"
        }, 
        {
            "location": "/tutorials/loops/", 
            "text": "Loops\n\n\nWhile loops\n\n\nIn a while loop, you execute a certain block of code while a condition is true. The syntax is as follows:\n\n\nwhile(condition) {\n    // block of code\n    // to be executed\n}\n\n\n\n\nThe example below counts from 1 to 10:\n\n\ni = 1;\nwhile(i \n= 10) {\n    Console.print(i);\n    i = i + 1;\n}\n\n\n\n\nFor loops\n\n\nA for loop is a more controlled repetition structure when compared to the while loop. For loops support an initialization command, a condition and an increment command. The syntax is as follows:\n\n\nfor(initialization; condition; increment) {\n    // block of code\n    // to be executed\n}\n\n\n\n\nThe code just displayed is equivalent to:\n\n\ninitialization;\nwhile(condition) {\n    // block of code\n    // to be executed\n\n    increment;\n}\n\n\n\n\nThe example below counts from 1 to 10:\n\n\nfor(i = 1; i \n= 10; i++) {\n    Console.print(i);\n}\n\n\n\n\nForeach\n\n\nForeach loops are used to iterate throughout collections (such as Arrays). Basically: for each element \nx\n in the collection, do something with \nx\n. The syntax is as follows:\n\n\nforeach(element in collection) {\n    // block of code\n    // to be executed\n}\n\n\n\n\nThe example below counts from 1 to 10:\n\n\ncollection = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nforeach(x in collection) {\n    Console.print(x);\n}", 
            "title": "Loops"
        }, 
        {
            "location": "/tutorials/loops/#loops", 
            "text": "", 
            "title": "Loops"
        }, 
        {
            "location": "/tutorials/loops/#while-loops", 
            "text": "In a while loop, you execute a certain block of code while a condition is true. The syntax is as follows:  while(condition) {\n    // block of code\n    // to be executed\n}  The example below counts from 1 to 10:  i = 1;\nwhile(i  = 10) {\n    Console.print(i);\n    i = i + 1;\n}", 
            "title": "While loops"
        }, 
        {
            "location": "/tutorials/loops/#for-loops", 
            "text": "A for loop is a more controlled repetition structure when compared to the while loop. For loops support an initialization command, a condition and an increment command. The syntax is as follows:  for(initialization; condition; increment) {\n    // block of code\n    // to be executed\n}  The code just displayed is equivalent to:  initialization;\nwhile(condition) {\n    // block of code\n    // to be executed\n\n    increment;\n}  The example below counts from 1 to 10:  for(i = 1; i  = 10; i++) {\n    Console.print(i);\n}", 
            "title": "For loops"
        }, 
        {
            "location": "/tutorials/loops/#foreach", 
            "text": "Foreach loops are used to iterate throughout collections (such as Arrays). Basically: for each element  x  in the collection, do something with  x . The syntax is as follows:  foreach(element in collection) {\n    // block of code\n    // to be executed\n}  The example below counts from 1 to 10:  collection = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nforeach(x in collection) {\n    Console.print(x);\n}", 
            "title": "Foreach"
        }, 
        {
            "location": "/tutorials/functions/", 
            "text": "Functions\n\n\nFunctions are blocks of code that you can reuse throughout your program. They may receive input parameters and they always output something. The syntax is as follows:\n\n\nfun function_name(param_1, param_2, param_3, ..., param_n)\n{\n    // block of code\n    // to be executed\n}\n\n\n\n\nFunctions may be associated to objects. Any function associated to an object may be used (called) by the object itself or by other objects. This means that functions are \npublic\n (they are visible to the outside world).\n\n\nNote:\n functions should be defined after the states.\n\n\nReturn statement\n\n\nUse the \nreturn\n statement to stop executing the function and to return some value to the caller. Example:\n\n\n// This function will return the double of input parameter x\nfun double(x)\n{\n    return 2 * x;\n    Console.print(\nThis line will never be executed.\n);\n}\n\n\n\n\nIf no value is specified after the \nreturn\n keyword, the function will be stopped and its return value will be \nnull\n. Additionally, if no \nreturn\n statement is found, then the return value will also be \nnull\n.\n\n\nNote\n: an object state may also contain one or more \nreturn\n statements to stop the execution of its code. However, return values must not be specified in that context, since states do not return values.\n\n\nSimple example\n\n\nIn the example below, we have an object called \nCalculator\n with two functions: \ngreet()\n and \nsum()\n. \ngreet()\n takes no input parameters and just greets the user. On the other hand, \nsum()\n takes two input parameters, \na\n and \nb\n, and returns the sum \na\n + \nb\n:\n\n\nobject \nCalculator\n\n{\n    fun greet()\n    {\n        Console.print(\nHello! I am a Calculator!\n);\n    }\n\n    fun sum(a, b)\n    {\n        return a + b;\n    }\n}\n\n\n\n\nIn function \nsum()\n, variables \na\n and \nb\n hold the input data and are only visible inside the function.\n\n\nNow, let's create a program that uses this \nCalculator\n. Remember that the functions defined above can be called by any object, including \nApplication\n:\n\n\nobject \nApplication\n\n{\n    calculator = spawn(\nCalculator\n);\n\n    state \nmain\n\n    {\n        // greet the user\n        calculator.greet();\n\n        // do some computation\n        result = calculator.sum(5, 7);\n        Console.print(result);\n\n        // we're done!\n        Application.exit();\n    }\n}\n\n\n\n\nThe output of the above program is:\n\n\nHello! I am a Calculator!\n12\n\n\n\n\nNotice that the \nApplication\n does not need to know \nhow\n the functions of the \nCalculator\n are implemented. It just needs to know \nwhat\n they do. This means that you may change the implementation of the \nCalculator\n without changing the \nApplication\n, and the end-result will stay the same.\n\n\nRecursive functions\n\n\nIn SurgeScript, a function is said to be \nrecursive\n when it calls itself within its code. Recursion can be useful in many ways; namely, when you define a problem in terms of itself. In mathematics, the factorial of a non-negative integer number \nn\n, denoted as \nn!\n, is such an example:\n\n\nn! = { n * (n-1)!    if n \n 1\n     { 1             otherwise\n\n\n\n\nOne interesting example of recursion that arises in computer science is called the \nbinary search\n algorithm. Given a sorted \nArray\n, the binary search finds the position of a target value without having to inspect the whole collection. In the example below, \nbsearch()\n is a recursive function:\n\n\nobject \nBinarySearch\n\n{\n    // Given an array *sorted in ascending order*, find()\n    // finds the position of the target value in the array.\n    // It returns its index, or -1 if the target is not found.\n    fun find(array, value)\n    {\n        return bsearch(array, value, 0, array.length - 1);\n    }\n\n    // Performs a binary search in array[start..end]\n    fun bsearch(array, value, start, end)\n    {\n        // get the middle point\n        mid = start + Math.floor((end - start) / 2);\n\n        // compare the middle point to the target value\n        if(start \n end)\n            return -1; // target not found\n        else if(value == array[mid])\n            return mid; // found the target value\n        else if(value \n array[mid])\n            return bsearch(array, value, start, mid - 1);\n        else\n            return bsearch(array, value, mid + 1, end);\n    }\n}\n\n\n\n\nRecursive functions must have at least one base case. A base case is a scenario that does not need recursion to solve the problem. In the factorial example, the base case is \nn \n= 1\n (the factorial is 1). In the binary search example, the base case is \nstart \n end\n, meaning that the array is empty and the target value cannot be found, or \nvalue == array[mid]\n, meaning that the target value has been found at \nmid\n.\n\n\nAs the sages say: \nto understand recursion, you must first understand recursion\n.\n\n\nConstructors and destructors\n\n\nIn SurgeScript, constructors and destructors are special functions that are called whenever objects are created and destroyed, respectively. It's not mandatory to define them, but it may be useful to do so (to set up things, for example). Neither may receive any arguments.\n\n\nLet's take our \nCalculator\n again. In the following example, \nconstructor()\n is called automatically whenever a \nCalculator\n object is created. Likewise, \ndestructor()\n is called automatically when the object is destroyed.\n\n\nobject \nCalculator\n\n{\n    fun constructor()\n    {\n        Console.print(\nCreating a Calculator...\n);\n    }\n\n    fun destructor()\n    {\n        Console.print(\nDestroying a Calculator...\n);\n    }\n\n    fun greet()\n    {\n        Console.print(\nHello! I am a Calculator!\n);\n    }\n\n    fun sum(a, b)\n    {\n        return a + b;\n    }\n}\n\n\n\n\nNow, if we run the \nApplication\n of the previous section without any modification, the output of the program will be:\n\n\nCreating a Calculator...\nHello! I am a Calculator!\n12\nDestroying a Calculator...\n\n\n\n\nPlease note that, for any object, its \nconstructor()\n runs \nbefore\n its main state.", 
            "title": "Functions"
        }, 
        {
            "location": "/tutorials/functions/#functions", 
            "text": "Functions are blocks of code that you can reuse throughout your program. They may receive input parameters and they always output something. The syntax is as follows:  fun function_name(param_1, param_2, param_3, ..., param_n)\n{\n    // block of code\n    // to be executed\n}  Functions may be associated to objects. Any function associated to an object may be used (called) by the object itself or by other objects. This means that functions are  public  (they are visible to the outside world).  Note:  functions should be defined after the states.", 
            "title": "Functions"
        }, 
        {
            "location": "/tutorials/functions/#return-statement", 
            "text": "Use the  return  statement to stop executing the function and to return some value to the caller. Example:  // This function will return the double of input parameter x\nfun double(x)\n{\n    return 2 * x;\n    Console.print( This line will never be executed. );\n}  If no value is specified after the  return  keyword, the function will be stopped and its return value will be  null . Additionally, if no  return  statement is found, then the return value will also be  null .  Note : an object state may also contain one or more  return  statements to stop the execution of its code. However, return values must not be specified in that context, since states do not return values.", 
            "title": "Return statement"
        }, 
        {
            "location": "/tutorials/functions/#simple-example", 
            "text": "In the example below, we have an object called  Calculator  with two functions:  greet()  and  sum() .  greet()  takes no input parameters and just greets the user. On the other hand,  sum()  takes two input parameters,  a  and  b , and returns the sum  a  +  b :  object  Calculator \n{\n    fun greet()\n    {\n        Console.print( Hello! I am a Calculator! );\n    }\n\n    fun sum(a, b)\n    {\n        return a + b;\n    }\n}  In function  sum() , variables  a  and  b  hold the input data and are only visible inside the function.  Now, let's create a program that uses this  Calculator . Remember that the functions defined above can be called by any object, including  Application :  object  Application \n{\n    calculator = spawn( Calculator );\n\n    state  main \n    {\n        // greet the user\n        calculator.greet();\n\n        // do some computation\n        result = calculator.sum(5, 7);\n        Console.print(result);\n\n        // we're done!\n        Application.exit();\n    }\n}  The output of the above program is:  Hello! I am a Calculator!\n12  Notice that the  Application  does not need to know  how  the functions of the  Calculator  are implemented. It just needs to know  what  they do. This means that you may change the implementation of the  Calculator  without changing the  Application , and the end-result will stay the same.", 
            "title": "Simple example"
        }, 
        {
            "location": "/tutorials/functions/#recursive-functions", 
            "text": "In SurgeScript, a function is said to be  recursive  when it calls itself within its code. Recursion can be useful in many ways; namely, when you define a problem in terms of itself. In mathematics, the factorial of a non-negative integer number  n , denoted as  n! , is such an example:  n! = { n * (n-1)!    if n   1\n     { 1             otherwise  One interesting example of recursion that arises in computer science is called the  binary search  algorithm. Given a sorted  Array , the binary search finds the position of a target value without having to inspect the whole collection. In the example below,  bsearch()  is a recursive function:  object  BinarySearch \n{\n    // Given an array *sorted in ascending order*, find()\n    // finds the position of the target value in the array.\n    // It returns its index, or -1 if the target is not found.\n    fun find(array, value)\n    {\n        return bsearch(array, value, 0, array.length - 1);\n    }\n\n    // Performs a binary search in array[start..end]\n    fun bsearch(array, value, start, end)\n    {\n        // get the middle point\n        mid = start + Math.floor((end - start) / 2);\n\n        // compare the middle point to the target value\n        if(start   end)\n            return -1; // target not found\n        else if(value == array[mid])\n            return mid; // found the target value\n        else if(value   array[mid])\n            return bsearch(array, value, start, mid - 1);\n        else\n            return bsearch(array, value, mid + 1, end);\n    }\n}  Recursive functions must have at least one base case. A base case is a scenario that does not need recursion to solve the problem. In the factorial example, the base case is  n  = 1  (the factorial is 1). In the binary search example, the base case is  start   end , meaning that the array is empty and the target value cannot be found, or  value == array[mid] , meaning that the target value has been found at  mid .  As the sages say:  to understand recursion, you must first understand recursion .", 
            "title": "Recursive functions"
        }, 
        {
            "location": "/tutorials/functions/#constructors-and-destructors", 
            "text": "In SurgeScript, constructors and destructors are special functions that are called whenever objects are created and destroyed, respectively. It's not mandatory to define them, but it may be useful to do so (to set up things, for example). Neither may receive any arguments.  Let's take our  Calculator  again. In the following example,  constructor()  is called automatically whenever a  Calculator  object is created. Likewise,  destructor()  is called automatically when the object is destroyed.  object  Calculator \n{\n    fun constructor()\n    {\n        Console.print( Creating a Calculator... );\n    }\n\n    fun destructor()\n    {\n        Console.print( Destroying a Calculator... );\n    }\n\n    fun greet()\n    {\n        Console.print( Hello! I am a Calculator! );\n    }\n\n    fun sum(a, b)\n    {\n        return a + b;\n    }\n}  Now, if we run the  Application  of the previous section without any modification, the output of the program will be:  Creating a Calculator...\nHello! I am a Calculator!\n12\nDestroying a Calculator...  Please note that, for any object, its  constructor()  runs  before  its main state.", 
            "title": "Constructors and destructors"
        }, 
        {
            "location": "/tutorials/comments/", 
            "text": "Comments\n\n\nComments are used to make your code more human-readable. They are ignored by the computer. SurgeScript allows two kinds of comments: single-line comments and multi-line comments.\n\n\nSingle-line comments\n\n\nSingle-line comments start with a \n//\n. Example:\n\n\n// This line has no effect on the code (it's just for improved readability)\nx = 3 + 4; // x is now 7\n\n\n\n\nMulti-line comments\n\n\nMulti-line comments start with a \n/*\n and end with a \n*/\n. Example:\n\n\n/*\n * Comments can, but don't have to, take\n * multiple lines if you use this form.\n */\nx = 3 + 4; /* x is now 7 */\n\n\n\n\nComments of this form cannot be nested.", 
            "title": "Comments"
        }, 
        {
            "location": "/tutorials/comments/#comments", 
            "text": "Comments are used to make your code more human-readable. They are ignored by the computer. SurgeScript allows two kinds of comments: single-line comments and multi-line comments.", 
            "title": "Comments"
        }, 
        {
            "location": "/tutorials/comments/#single-line-comments", 
            "text": "Single-line comments start with a  // . Example:  // This line has no effect on the code (it's just for improved readability)\nx = 3 + 4; // x is now 7", 
            "title": "Single-line comments"
        }, 
        {
            "location": "/tutorials/comments/#multi-line-comments", 
            "text": "Multi-line comments start with a  /*  and end with a  */ . Example:  /*\n * Comments can, but don't have to, take\n * multiple lines if you use this form.\n */\nx = 3 + 4; /* x is now 7 */  Comments of this form cannot be nested.", 
            "title": "Multi-line comments"
        }, 
        {
            "location": "/tutorials/tags/", 
            "text": "Tags\n\n\nYou may tag objects with as many tags as you want. Tags are a way of attributing categories to different objects.\n\n\nTags should be placed right after the object name. Example:\n\n\nobject \nHorse\n is \nanimal\n, \nvehicle\n\n{\n    state \nmain\n\n    {\n    }\n}\n\nobject \nCat\n is \nanimal\n\n{\n    state \nmain\n\n    {\n    }\n}\n\nobject \nCar\n is \nvehicle\n\n{\n    state \nmain\n\n    {\n    }\n}\n\n\n\n\nWe may check if an object has a particular tag with the \nhasTag()\n function (see the \nObject reference\n for more details):\n\n\nobject \nApplication\n\n{\n    horse = spawn(\nHorse\n);\n    cat = spawn(\nCat\n);\n    car = spawn(\nCar\n);\n\n    state \nmain\n\n    {\n        // Horse is both an animal and a vehicle\n        Console.print(horse.hasTag(\nanimal\n)); // true\n        Console.print(horse.hasTag(\nvehicle\n)); // true\n\n        // Cat is an animal, but not a vehicle\n        Console.print(cat.hasTag(\nanimal\n)); // true\n        Console.print(cat.hasTag(\nvehicle\n)); // false\n\n        // Car is a vehicle, but not an animal\n        Console.print(car.hasTag(\nanimal\n)); // false\n        Console.print(car.hasTag(\nvehicle\n)); // true\n    }\n}\n\n\n\n\nYou may also tag objects with emoticons. The syntax is as follows:\n\n\nobject \nGood Day\n is \nhappy\n, \nsunny\n :)\n{\n    ...\n}\n\nobject \nGood Night\n is \n3\n{\n    ...\n}\n\n\n\n\nThe following emoticons are available for your pleasure:\n\n\n\n\n\n\n\n\nEmoticon\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n$_$\n\n\nFeelin' Rich\n\n\n\n\n\n\n3\n\n\nLovin' it\n\n\n\n\n\n\n:)\n\n\nHappy\n\n\n\n\n\n\n:(\n\n\nSad\n\n\n\n\n\n\n:P\n\n\nD'oh", 
            "title": "Tags"
        }, 
        {
            "location": "/tutorials/tags/#tags", 
            "text": "You may tag objects with as many tags as you want. Tags are a way of attributing categories to different objects.  Tags should be placed right after the object name. Example:  object  Horse  is  animal ,  vehicle \n{\n    state  main \n    {\n    }\n}\n\nobject  Cat  is  animal \n{\n    state  main \n    {\n    }\n}\n\nobject  Car  is  vehicle \n{\n    state  main \n    {\n    }\n}  We may check if an object has a particular tag with the  hasTag()  function (see the  Object reference  for more details):  object  Application \n{\n    horse = spawn( Horse );\n    cat = spawn( Cat );\n    car = spawn( Car );\n\n    state  main \n    {\n        // Horse is both an animal and a vehicle\n        Console.print(horse.hasTag( animal )); // true\n        Console.print(horse.hasTag( vehicle )); // true\n\n        // Cat is an animal, but not a vehicle\n        Console.print(cat.hasTag( animal )); // true\n        Console.print(cat.hasTag( vehicle )); // false\n\n        // Car is a vehicle, but not an animal\n        Console.print(car.hasTag( animal )); // false\n        Console.print(car.hasTag( vehicle )); // true\n    }\n}  You may also tag objects with emoticons. The syntax is as follows:  object  Good Day  is  happy ,  sunny  :)\n{\n    ...\n}\n\nobject  Good Night  is  3\n{\n    ...\n}  The following emoticons are available for your pleasure:     Emoticon  Meaning      $_$  Feelin' Rich    3  Lovin' it    :)  Happy    :(  Sad    :P  D'oh", 
            "title": "Tags"
        }, 
        {
            "location": "/tutorials/object_tree/", 
            "text": "Object tree\n\n\nIn SurgeScript, objects have a hierarchical relationship. Suppose that object P spawns (or \ninstantiates\n) object C. We say that object P is the \nparent\n of C. Similarly, object C is a \nchild\n of P.\n\n\nAn object may spawn many children. However, all objects have only one parent. This relationship between objects form a hierarchy (or a tree). The Figure below shows an example:\n\n\n\n\nIn this example, Level is the parent of GameItem1 and GameItem2. Components A and B are children of GameItem1, but not of GameItem2. Level has two children and GameItem2 has zero.\n\n\nIn SurgeScript, the root of the hierarchy is a predefined object called \nSystem\n. Its parent is itself. All other objects are descendants of \nSystem\n.\n\n\nSpawning objects\n\n\nYou can use \nspawn()\n to instantiate an object. Example:\n\n\nobject \nParent\n\n{\n    child = spawn(\nChild\n);\n\n    state \nmain\n\n    {\n    }\n}\n\nobject \nChild\n\n{\n    state \nmain\n\n    {\n    }\n}\n\n\n\n\nFunction \nspawn()\n may be invoked on objects other than the caller. In this case, the caller won't be the parent of the newly created object:\n\n\nobject \nParent\n\n{\n    child = spawn(\nChild\n);\n    grandChild = child.spawn(\nChild\n);\n\n    state \nmain\n\n    {\n    }\n}\n\n\n\n\n\n\nAutomatic Garbage Collection\n\n\nWhen you spawn an object, make sure you store a reference to it somewhere.\n\n\nIf an object cannot be reached from the root (no reachable object has any references to it), it will be automatically destroyed by SurgeScript's Garbage Collector.\n\n\n\n\nDestroying objects\n\n\nObjects can be destroyed manually by calling \ndestroy()\n. Whenever an object is destroyed, its children are destroyed as well.\n\n\nobject \nFoo\n\n{\n    state \nmain\n\n    {\n        Console.print(\nThis object does nothing.\n);\n        destroy();\n    }\n}\n\n\n\n\nTraversing the hierarchy\n\n\nRelevant data about the object hierarchy can be obtained using the following properties and functions (read more on the \nObject reference\n):\n\n\n\n\n\n\n\n\nFunction / property\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nobj.parent\n (read-only)\n\n\nThe parent object\n\n\n\n\n\n\nobj.childCount\n (read-only)\n\n\nNumber of immediate children\n\n\n\n\n\n\nobj.child(name)\n\n\nGets a child object named \nname\n\n\n\n\n\n\nobj.findObject(name)\n\n\nFinds* a descendant named \nname\n\n\n\n\n\n\nobj.sibling(name)\n\n\nGets a sibling** named \nname\n\n\n\n\n\n\n\n\n\n\nNotes:\n\n\n* findObject() may be slow, as it performs a deep search within the object tree. One is encouraged to cache the result of this function (for example, in the object constructor) and to avoid using it in states or loops.\n\n\n** We say that two distinct objects are siblings if they share the same parent.\n\n\n\n\nExample:\n\n\nobject \nParent\n\n{\n    child = spawn(\nChild\n);\n    otherChild = spawn(\nChild\n);\n\n    state \nmain\n\n    {\n        Console.print(\nThis object has \n + childCount + \n children.\n);\n        destroy();\n    }\n}\n\n\n\n\nThe output is as follows:\n\n\nThis object has 2 children.", 
            "title": "Object tree"
        }, 
        {
            "location": "/tutorials/object_tree/#object-tree", 
            "text": "In SurgeScript, objects have a hierarchical relationship. Suppose that object P spawns (or  instantiates ) object C. We say that object P is the  parent  of C. Similarly, object C is a  child  of P.  An object may spawn many children. However, all objects have only one parent. This relationship between objects form a hierarchy (or a tree). The Figure below shows an example:   In this example, Level is the parent of GameItem1 and GameItem2. Components A and B are children of GameItem1, but not of GameItem2. Level has two children and GameItem2 has zero.  In SurgeScript, the root of the hierarchy is a predefined object called  System . Its parent is itself. All other objects are descendants of  System .", 
            "title": "Object tree"
        }, 
        {
            "location": "/tutorials/object_tree/#spawning-objects", 
            "text": "You can use  spawn()  to instantiate an object. Example:  object  Parent \n{\n    child = spawn( Child );\n\n    state  main \n    {\n    }\n}\n\nobject  Child \n{\n    state  main \n    {\n    }\n}  Function  spawn()  may be invoked on objects other than the caller. In this case, the caller won't be the parent of the newly created object:  object  Parent \n{\n    child = spawn( Child );\n    grandChild = child.spawn( Child );\n\n    state  main \n    {\n    }\n}   Automatic Garbage Collection  When you spawn an object, make sure you store a reference to it somewhere.  If an object cannot be reached from the root (no reachable object has any references to it), it will be automatically destroyed by SurgeScript's Garbage Collector.", 
            "title": "Spawning objects"
        }, 
        {
            "location": "/tutorials/object_tree/#destroying-objects", 
            "text": "Objects can be destroyed manually by calling  destroy() . Whenever an object is destroyed, its children are destroyed as well.  object  Foo \n{\n    state  main \n    {\n        Console.print( This object does nothing. );\n        destroy();\n    }\n}", 
            "title": "Destroying objects"
        }, 
        {
            "location": "/tutorials/object_tree/#traversing-the-hierarchy", 
            "text": "Relevant data about the object hierarchy can be obtained using the following properties and functions (read more on the  Object reference ):     Function / property  Description      obj.parent  (read-only)  The parent object    obj.childCount  (read-only)  Number of immediate children    obj.child(name)  Gets a child object named  name    obj.findObject(name)  Finds* a descendant named  name    obj.sibling(name)  Gets a sibling** named  name      Notes:  * findObject() may be slow, as it performs a deep search within the object tree. One is encouraged to cache the result of this function (for example, in the object constructor) and to avoid using it in states or loops.  ** We say that two distinct objects are siblings if they share the same parent.   Example:  object  Parent \n{\n    child = spawn( Child );\n    otherChild = spawn( Child );\n\n    state  main \n    {\n        Console.print( This object has   + childCount +   children. );\n        destroy();\n    }\n}  The output is as follows:  This object has 2 children.", 
            "title": "Traversing the hierarchy"
        }, 
        {
            "location": "/tutorials/components/", 
            "text": "Components\n\n\nEntity Component System (ECS) is a software pattern used in game development. The idea is that in-game objects (called \nentities\n) can be customized by adding or removing objects (called \ncomponents\n) at runtime. Components add functionalities or behaviors to the entities to which they are attached to. In SurgeScript, both entities and components are objects - the difference is conceptual.\n\n\nAs an example, consider an in-game object called \nParrot\n. Objects by themselves are empty; they do nothing. However, an interesting behavior of parrots is that they are blabbers: they keep repeating the same thing over and over again. So, let's create an empty object \nParrot\n and spawn on it the \nBlabber\n component:\n\n\nobject \nParrot\n\n{\n    blabber = spawn(\nBlabber\n);\n\n    state \nmain\n\n    {\n    }\n}\n\nobject \nBlabber\n\n{\n    state \nmain\n\n    {\n        if(timeout(2)) // blab every 2 seconds\n            state = \nblab\n;\n    }\n\n    state \nblab\n\n    {\n        Console.print(\nHello!\n);\n        state = \nmain\n;\n    }\n}\n\n\n\n\nNow, whenever you spawn a Parrot, it will keep blabbing (\nparroting\n) unceasingly:\n\n\nHello!\nHello!\nHello!\n...\n\n\n\n\nSuppose now that your Parrot is a Kamikaze Robot: it blabs so much that it will explode itself after some time. We'll attach a \nTime Bomb\n to the parroting robot, so that it will stop blabbing after a while:\n\n\nobject \nTime Bomb\n\n{\n    state \nmain\n\n    {\n        if(timeout(15)) // explode after 15 seconds\n            state = \nexplode\n;\n    }\n\n    state \nexplode\n\n    {\n        Console.print(\nBOOOM!\n);\n        parent.destroy(); // destroy the parent object\n    }\n}\n\nobject \nParrot\n\n{\n    blabber = spawn(\nBlabber\n);\n    bomb = spawn(\nTime Bomb\n);\n\n    state \nmain\n\n    {\n    }\n}\n\n\n\n\nNow, here's the result:\n\n\nHello!\nHello!\nHello!\nHello!\nHello!\nHello!\nHello!\nBOOOM!\n\n\n\n\nIn this example, \nParrot\n is an entity and \nBlabber\n and \nTime Bomb\n are its components. Once the entity is destroyed, its components (its children) are also destroyed automatically.\n\n\nDesign considerations\n\n\nIn some implementations of ECS, entities are implemented as integers and components consist of raw data only. The game logic is executed by the System layer, which iterates throughout all entities continuously and executes the logic according to the components attached to them.\n\n\nIn SurgeScript, components execute their own code and can be attached to entities simply by spawning them as children. Still, you can use the former approach if you wish to do so.\n\n\nComposition over inheritance\n\n\nSurgeScript does not support inheritance, a feature found in other object-oriented languages. The usage of components is encouraged instead. SurgeScript favors composition over inheritance, allowing for greater flexibility when defining in-game objects.", 
            "title": "Components"
        }, 
        {
            "location": "/tutorials/components/#components", 
            "text": "Entity Component System (ECS) is a software pattern used in game development. The idea is that in-game objects (called  entities ) can be customized by adding or removing objects (called  components ) at runtime. Components add functionalities or behaviors to the entities to which they are attached to. In SurgeScript, both entities and components are objects - the difference is conceptual.  As an example, consider an in-game object called  Parrot . Objects by themselves are empty; they do nothing. However, an interesting behavior of parrots is that they are blabbers: they keep repeating the same thing over and over again. So, let's create an empty object  Parrot  and spawn on it the  Blabber  component:  object  Parrot \n{\n    blabber = spawn( Blabber );\n\n    state  main \n    {\n    }\n}\n\nobject  Blabber \n{\n    state  main \n    {\n        if(timeout(2)) // blab every 2 seconds\n            state =  blab ;\n    }\n\n    state  blab \n    {\n        Console.print( Hello! );\n        state =  main ;\n    }\n}  Now, whenever you spawn a Parrot, it will keep blabbing ( parroting ) unceasingly:  Hello!\nHello!\nHello!\n...  Suppose now that your Parrot is a Kamikaze Robot: it blabs so much that it will explode itself after some time. We'll attach a  Time Bomb  to the parroting robot, so that it will stop blabbing after a while:  object  Time Bomb \n{\n    state  main \n    {\n        if(timeout(15)) // explode after 15 seconds\n            state =  explode ;\n    }\n\n    state  explode \n    {\n        Console.print( BOOOM! );\n        parent.destroy(); // destroy the parent object\n    }\n}\n\nobject  Parrot \n{\n    blabber = spawn( Blabber );\n    bomb = spawn( Time Bomb );\n\n    state  main \n    {\n    }\n}  Now, here's the result:  Hello!\nHello!\nHello!\nHello!\nHello!\nHello!\nHello!\nBOOOM!  In this example,  Parrot  is an entity and  Blabber  and  Time Bomb  are its components. Once the entity is destroyed, its components (its children) are also destroyed automatically.", 
            "title": "Components"
        }, 
        {
            "location": "/tutorials/components/#design-considerations", 
            "text": "In some implementations of ECS, entities are implemented as integers and components consist of raw data only. The game logic is executed by the System layer, which iterates throughout all entities continuously and executes the logic according to the components attached to them.  In SurgeScript, components execute their own code and can be attached to entities simply by spawning them as children. Still, you can use the former approach if you wish to do so.", 
            "title": "Design considerations"
        }, 
        {
            "location": "/tutorials/components/#composition-over-inheritance", 
            "text": "SurgeScript does not support inheritance, a feature found in other object-oriented languages. The usage of components is encouraged instead. SurgeScript favors composition over inheritance, allowing for greater flexibility when defining in-game objects.", 
            "title": "Composition over inheritance"
        }, 
        {
            "location": "/tutorials/properties/", 
            "text": "Properties\n\n\nIn SurgeScript, \nobject-level variables\n are private. This means that these variables can only be accessed from the objects that defined them. However, SurgeScript features a \nsyntactic sugar\n that allows objects to read and/or modify other objects' data in a way that looks like dealing with regular (public) variables. We'll call these variables \nproperties\n.\n\n\nDefining properties\n\n\nSuppose you have an object called \nAnimal\n with a variable called \nsound\n and a function named \nspeak()\n:\n\n\nobject \nAnimal\n\n{\n    sound = \nmeow!\n;\n\n    fun speak()\n    {\n        Console.print(sound);\n    }\n}\n\n\n\n\nThis object can only speak \nmeow!\n Let's see:\n\n\nobject \nApplication\n\n{\n    animal = spawn(\nAnimal\n);\n\n    state \nmain\n\n    {\n        animal.speak();\n    }\n}\n\n\n\n\nRun this script and you'll see:\n\n\nmeow!\nmeow!\nmeow!\nmeow!\n...\n\n\n\n\nWhat if an external object could modify the sound of the animal? Trying to access \nanimal.sound\n externally will trigger an error, unless you add the \npublic\n specifier to your variable:\n\n\nobject \nAnimal\n\n{\n    public sound = \nmeow!\n;\n\n    fun speak()\n    {\n        Console.print(sound);\n    }\n}\n\n\n\n\nNow, external objects may access (read and write) the \nsound\n variable (or \nproperty\n):\n\n\nobject \nApplication\n\n{\n    animal = spawn(\nAnimal\n);\n\n    state \nmain\n\n    {\n        animal.sound = \nwoof!\n;\n        animal.speak();\n    }\n}\n\n\n\n\nSince SurgeScript 0.5.3, you may add the \nreadonly\n modifier after the \npublic\n specifier. Doing so disallows the modification of the property by external objects:\n\n\nobject \nAnimal\n\n{\n    public readonly sound = \nmeow!\n;\n\n    fun speak()\n    {\n        Console.print(sound);\n    }\n}\n\nobject \nApplication\n\n{\n    animal = spawn(\nAnimal\n);\n\n    state \nmain\n\n    {\n        //animal.sound = \nwoof!\n; // will trigger an error\n        //Console.print(animal.sound); // this is allowed\n        animal.speak();\n    }\n}\n\n\n\n\nUsing getters and setters\n\n\nIn reality, however, there are no public variables in SurgeScript. Behind the scenes, the language defines special functions called \ngetters\n and \nsetters\n that will perform the read/write logic for you. Rather than using \npublic\n, you may want to define the getters and the setters yourself:\n\n\nobject \nAnimal\n\n{\n    sound = \nmeow!\n;\n\n    fun speak()\n    {\n        Console.print(sound);\n    }\n\n    fun set_sound(value)\n    {\n        sound = value;\n    }\n\n    fun get_sound()\n    {\n        return sound;\n    }\n}\n\n\n\n\nThis code is semantically the same; it's just a bit longer.\n\n\nAn advantage of defining getters and setters by yourself is that you control how the data passes through the objects. You may want to validate the data before changing the internal variables of the objects, for example.", 
            "title": "Properties"
        }, 
        {
            "location": "/tutorials/properties/#properties", 
            "text": "In SurgeScript,  object-level variables  are private. This means that these variables can only be accessed from the objects that defined them. However, SurgeScript features a  syntactic sugar  that allows objects to read and/or modify other objects' data in a way that looks like dealing with regular (public) variables. We'll call these variables  properties .", 
            "title": "Properties"
        }, 
        {
            "location": "/tutorials/properties/#defining-properties", 
            "text": "Suppose you have an object called  Animal  with a variable called  sound  and a function named  speak() :  object  Animal \n{\n    sound =  meow! ;\n\n    fun speak()\n    {\n        Console.print(sound);\n    }\n}  This object can only speak  meow!  Let's see:  object  Application \n{\n    animal = spawn( Animal );\n\n    state  main \n    {\n        animal.speak();\n    }\n}  Run this script and you'll see:  meow!\nmeow!\nmeow!\nmeow!\n...  What if an external object could modify the sound of the animal? Trying to access  animal.sound  externally will trigger an error, unless you add the  public  specifier to your variable:  object  Animal \n{\n    public sound =  meow! ;\n\n    fun speak()\n    {\n        Console.print(sound);\n    }\n}  Now, external objects may access (read and write) the  sound  variable (or  property ):  object  Application \n{\n    animal = spawn( Animal );\n\n    state  main \n    {\n        animal.sound =  woof! ;\n        animal.speak();\n    }\n}  Since SurgeScript 0.5.3, you may add the  readonly  modifier after the  public  specifier. Doing so disallows the modification of the property by external objects:  object  Animal \n{\n    public readonly sound =  meow! ;\n\n    fun speak()\n    {\n        Console.print(sound);\n    }\n}\n\nobject  Application \n{\n    animal = spawn( Animal );\n\n    state  main \n    {\n        //animal.sound =  woof! ; // will trigger an error\n        //Console.print(animal.sound); // this is allowed\n        animal.speak();\n    }\n}", 
            "title": "Defining properties"
        }, 
        {
            "location": "/tutorials/properties/#using-getters-and-setters", 
            "text": "In reality, however, there are no public variables in SurgeScript. Behind the scenes, the language defines special functions called  getters  and  setters  that will perform the read/write logic for you. Rather than using  public , you may want to define the getters and the setters yourself:  object  Animal \n{\n    sound =  meow! ;\n\n    fun speak()\n    {\n        Console.print(sound);\n    }\n\n    fun set_sound(value)\n    {\n        sound = value;\n    }\n\n    fun get_sound()\n    {\n        return sound;\n    }\n}  This code is semantically the same; it's just a bit longer.  An advantage of defining getters and setters by yourself is that you control how the data passes through the objects. You may want to validate the data before changing the internal variables of the objects, for example.", 
            "title": "Using getters and setters"
        }, 
        {
            "location": "/tutorials/plugins/", 
            "text": "Plugins\n\n\nPlugins are objects that allow you to extend the functionalities of the language. Once declared, they can be imported anywhere in the code. They can also be easily shared with others, so everyone benefits.\n\n\nAvailable since:\n SurgeScript 0.5.2\n\n\nBasic example\n\n\nSuppose you want to extend the language by adding new routines related to string manipulation. The routines you want will be used frequently throughout your project, and you'd like easy access to them. This makes it perfect for implementing them as a plugin.\n\n\nWe'll define an object called \nStringUtils\n with a \nreverse()\n function that reverses a string. We make the object a plugin by annotating it with \n@Plugin\n. Please see in the example below:\n\n\n// File: stringutils.ss\n\n@Plugin\nobject \nStringUtils\n\n{\n    fun reverse(str)\n    {\n        buf = \n;\n        for(i = str.length - 1; i \n= 0; i--)\n            buf += str[i];\n        return buf;\n    }\n}\n\n\n\n\nWhen you annotate an object definition with \n@Plugin\n, SurgeScript will spawn an instance of such an object before spawning the \nApplication\n. Additionally, the plugin object may be imported anywhere with the \nusing\n keyword:\n\n\n// File: app.ss\nusing StringUtils;\n\nobject \nApplication\n\n{\n    state \nmain\n\n    {\n        str = StringUtils.reverse(\nalucard\n);\n        Console.print(str); // will print \ndracula\n\n        exit();\n    }\n}\n\n\n\n\nNote:\n it's recommended not to include any special characters in the name of your plugins, otherwise you may have trouble importing them.\n\n\nIn the example above, \nApplication\n and \nStringUtils\n are located in two separate files. If you want to test them using the SurgeScript command line utility, pass both files as parameters:\n\n\nsurgescript plugin.ss app.ss\n\n\n\n\n\n\nSpawning order\n\n\nAlthough plugins are spawned before the \nApplication\n object, for the time being they are spawned in no particular order. You may not access a plugin from within the constructor of another plugin, as of now there is no dependency resolver implemented. Use the \nmain\n state.\n\n\n\n\nPackage example\n\n\nYou may use the Plugin system to create an independent package (or namespace) that aggregates many functionalities. This lets you separate your code in coherent, logical units and also helps you to distribute it.\n\n\nSuppose that user \nParrot\n, the owner of \nParrotSoft\n, created SurgeScript utilities related to string manipulation, matrix math and complex numbers. He decided to share his code as a single package called \nParrotSoft\n. Since he implemented getters for each of his utilities (see the code below), his package provides easy access to all of them. Furthermore, he annotated his package with \n@Plugin\n (but \nnot\n the individual utilities), so his package can be accessed anywhere.\n\n\n// File: parrotsoft.ss\n\n@Plugin\nobject \nParrotSoft\n\n{\n    matrices = spawn(\nParrotMatrices\n);\n    complex = spawn(\nParrotComplexNumbers\n);\n    stringUtils = spawn(\nParrotStringUtils\n);\n\n    fun get_Matrices()\n    {\n        return matrices;\n    }\n\n    fun get_Complex()\n    {\n        return complex;\n    }\n\n    fun get_StringUtils()\n    {\n        return stringUtils;\n    }\n}\n\n// ...\n\n\n\n\nA user of the \nParrotSoft\n package may import \nParrot\n's utilities simply by importing the plugin. Individual utilities may also be imported. The code below shows a usage example:\n\n\nusing ParrotSoft.Matrices.Matrix2;\nusing ParrotSoft.Complex;\nusing ParrotSoft;\n\nobject \nApplication\n\n{\n    state \nmain\n\n    {\n        identity = Matrix2([[1, 0], [0, 1]]); // 2x2 matrix\n        z = Complex(2, 3); // 2 + 3i\n        neon = ParrotSoft.StringUtils.reverse(\nnoen\n);\n        exit();\n    }\n}\n\n\n\n\nIn the example above, writing \nComplex\n is equivalent to writing \nParrotSoft.Complex\n, since we imported this utility with \nusing ParrotSoft.Complex\n. Notice that \nParrotSoft\n implements a getter for \nComplex\n. Additionally, \nParrotSoft\n has been annotated with \n@Plugin\n, but \nComplex\n has \nnot\n. This means that the statement \nusing Complex\n will \nnot\n yield correct results - and it shouldn't, since \nComplex\n is a part of the \nParrotSoft\n package that can only be accessed from it. Finally, since we haven't imported \nStringUtils\n explicitly, we type \nParrotSoft.StringUtils\n to access it.", 
            "title": "Plugins"
        }, 
        {
            "location": "/tutorials/plugins/#plugins", 
            "text": "Plugins are objects that allow you to extend the functionalities of the language. Once declared, they can be imported anywhere in the code. They can also be easily shared with others, so everyone benefits.  Available since:  SurgeScript 0.5.2", 
            "title": "Plugins"
        }, 
        {
            "location": "/tutorials/plugins/#basic-example", 
            "text": "Suppose you want to extend the language by adding new routines related to string manipulation. The routines you want will be used frequently throughout your project, and you'd like easy access to them. This makes it perfect for implementing them as a plugin.  We'll define an object called  StringUtils  with a  reverse()  function that reverses a string. We make the object a plugin by annotating it with  @Plugin . Please see in the example below:  // File: stringutils.ss\n\n@Plugin\nobject  StringUtils \n{\n    fun reverse(str)\n    {\n        buf =  ;\n        for(i = str.length - 1; i  = 0; i--)\n            buf += str[i];\n        return buf;\n    }\n}  When you annotate an object definition with  @Plugin , SurgeScript will spawn an instance of such an object before spawning the  Application . Additionally, the plugin object may be imported anywhere with the  using  keyword:  // File: app.ss\nusing StringUtils;\n\nobject  Application \n{\n    state  main \n    {\n        str = StringUtils.reverse( alucard );\n        Console.print(str); // will print  dracula \n        exit();\n    }\n}  Note:  it's recommended not to include any special characters in the name of your plugins, otherwise you may have trouble importing them.  In the example above,  Application  and  StringUtils  are located in two separate files. If you want to test them using the SurgeScript command line utility, pass both files as parameters:  surgescript plugin.ss app.ss   Spawning order  Although plugins are spawned before the  Application  object, for the time being they are spawned in no particular order. You may not access a plugin from within the constructor of another plugin, as of now there is no dependency resolver implemented. Use the  main  state.", 
            "title": "Basic example"
        }, 
        {
            "location": "/tutorials/plugins/#package-example", 
            "text": "You may use the Plugin system to create an independent package (or namespace) that aggregates many functionalities. This lets you separate your code in coherent, logical units and also helps you to distribute it.  Suppose that user  Parrot , the owner of  ParrotSoft , created SurgeScript utilities related to string manipulation, matrix math and complex numbers. He decided to share his code as a single package called  ParrotSoft . Since he implemented getters for each of his utilities (see the code below), his package provides easy access to all of them. Furthermore, he annotated his package with  @Plugin  (but  not  the individual utilities), so his package can be accessed anywhere.  // File: parrotsoft.ss\n\n@Plugin\nobject  ParrotSoft \n{\n    matrices = spawn( ParrotMatrices );\n    complex = spawn( ParrotComplexNumbers );\n    stringUtils = spawn( ParrotStringUtils );\n\n    fun get_Matrices()\n    {\n        return matrices;\n    }\n\n    fun get_Complex()\n    {\n        return complex;\n    }\n\n    fun get_StringUtils()\n    {\n        return stringUtils;\n    }\n}\n\n// ...  A user of the  ParrotSoft  package may import  Parrot 's utilities simply by importing the plugin. Individual utilities may also be imported. The code below shows a usage example:  using ParrotSoft.Matrices.Matrix2;\nusing ParrotSoft.Complex;\nusing ParrotSoft;\n\nobject  Application \n{\n    state  main \n    {\n        identity = Matrix2([[1, 0], [0, 1]]); // 2x2 matrix\n        z = Complex(2, 3); // 2 + 3i\n        neon = ParrotSoft.StringUtils.reverse( noen );\n        exit();\n    }\n}  In the example above, writing  Complex  is equivalent to writing  ParrotSoft.Complex , since we imported this utility with  using ParrotSoft.Complex . Notice that  ParrotSoft  implements a getter for  Complex . Additionally,  ParrotSoft  has been annotated with  @Plugin , but  Complex  has  not . This means that the statement  using Complex  will  not  yield correct results - and it shouldn't, since  Complex  is a part of the  ParrotSoft  package that can only be accessed from it. Finally, since we haven't imported  StringUtils  explicitly, we type  ParrotSoft.StringUtils  to access it.", 
            "title": "Package example"
        }, 
        {
            "location": "/tutorials/advanced_features/", 
            "text": "Advanced features\n\n\nThis section describes advanced features of SurgeScript.\n\n\nLookup operator\n\n\nSome programming languages, such as C++, have a feature called \noperator overloading\n. It's a \nsyntactic sugar\n that allows the programmer to attribute custom implementations to different operators.\n\n\nIn SurgeScript, the \n[ ]\n operator (also called the \nlookup operator\n), used by Arrays and Dictionaries, is used to \nget\n and \nset\n values from/to the data structure. In fact, the \n[ ]\n operator can be used by any object, for any purpose. It is necessary to define, in your object, functions \nget()\n and \nset()\n with the following signature:\n\n\nfun get(key)\n{\n    // custom implementation\n}\n\nfun set(key, value)\n{\n    // custom implementation\n}\n\n\n\n\nGiven an object \nobj\n, the expression \nx = obj[key]\n is equivalent to \nx = obj.get(key)\n. Similarly, \nobj[key] = value\n is equivalent to \nobj.set(key, value)\n.\n\n\nAssertions\n\n\nThe \nassert(condition)\n statement specifies a \ncondition\n that you expect to be true at a certain point in your code. If that condition turns out to be false, the code will be interrupted with an \nassertion failed\n error. Example:\n\n\nassert(name == \nSurge\n); // will crash if name isn't \nSurge\n\n\n\n\n\nFunctors\n\n\nIn SurgeScript, objects can be made to behave like functions. We call these objects \nfunctors\n (or function objects). To make an object behave like a function, you have to overload the \n( )\n operator (also known as the \nfunction operator\n). This is done by defining function \ncall()\n in your object:\n\n\nfun call()\n{\n    // custom implementation\n}\n\n\n\n\nFunction \ncall()\n may take any number of parameters. Given an object \nf\n, the expression \ny = f(x)\n is equivalent to \ny = f.call(x)\n. Notice that, since \nf\n is an object, you may exchange its implementation during runtime.\n\n\nFactory\n\n\nIn SurgeScript, a factory is a functor that spawns an object for you. The object can be spawned and configured in a single call. In the example below, factory \nGreeter\n spawns and configures \nGreeting\n objects. We annotate the factory with \n@Plugin\n, so it can be imported anywhere in the code.\n\n\nTo the end-user, calling \nGreeter()\n is simpler than manually spawning and configuring a \nGreeting\n every time it is needed.\n\n\n// Factory example\nusing Greeter; // import the factory\n\nobject \nApplication\n\n{\n    state \nmain\n\n    {\n        // This will print:\n        // Hello, alex!\n        g = Greeter(\nalex\n);\n        g.greet();\n        exit();\n    }\n}\n\n// File: greeting.ss\nobject \nGreeting\n\n{\n    public name = \nanon\n;\n\n    fun greet()\n    {\n        Console.print(\nHello, \n + name + \n!\n);\n    }\n}\n\n@Plugin\nobject \nGreeter\n\n{\n    // Greeter is a factory. It spawns and configures\n    // a Greeting object for you. Being a plugin,\n    // Greeter can be used anywhere in the code.\n    fun call(name)\n    {\n        g = spawn(\nGreeting\n);\n        g.name = name;\n        return g;\n    }\n}\n\n\n\n\nPlease note: in the example above, objects spawned by the factory will be children of the factory. If you need the parent of the spawned object to be the caller object, then you might simply write \ng = caller.spawn(\"Greeter\")\n. Keyword \ncaller\n points to the object that called the function (or \nnull\n if not applicable).\n\n\nIterators\n\n\nAs seen in the \nloops\n section, the foreach loop may be used to iterate through a collection. In SurgeScript, a collection is an object (but the opposite is not always true). You may implement your own collections by implementing function \niterator()\n. If you have ever used Java, you'll find this to be familiar.\n\n\nobject \nMyCollection\n\n{\n    fun iterator()\n    {\n        // function iterator() takes no arguments and \n        // should return a new iterator object\n    }\n}\n\n\n\n\nFor each collection you define, you should also define its iterator object. The iterator object should implement functions \nnext()\n and \nhasNext()\n (both take no arguments):\n\n\nobject \nMyIterator\n\n{\n    fun next()\n    {\n        // returns the next element of the collection\n        // and advances the iteration pointer\n        // the collection is usually the parent object\n    }\n\n    function hasNext()\n    {\n        // returns true if the enumeration isn't over\n        // returns false if there are no more elements\n    }\n}\n\n\n\n\nYou may iterate through a collection using the following code:\n\n\nit = collection.iterator();\nwhile(it.hasNext()) {\n    x = it.next();\n\n    // do something with x\n    // x is an element of the collection\n    Console.print(x);\n}\n\n\n\n\nOr, alternatively, using the compact foreach:\n\n\nforeach(x in collection) {\n    Console.print(x);\n}\n\n\n\n\nFor the sake of completion, the following code demonstrates how to implement a custom collection that hold even numbers from 0 up to 20.\n\n\nobject \nApplication\n\n{\n    evenNumbers = spawn(\nEvenNumbers\n);\n\n    state \nmain\n\n    {\n        // iterate through the collection\n        foreach(number in evenNumbers)\n            Console.print(number);\n\n        // exit the app\n        Application.exit();\n    }\n}\n\nobject \nEvenNumbers\n\n{\n    fun iterator()\n    {\n        return spawn(\nEvenIterator\n);\n    }\n}\n\nobject \nEvenIterator\n\n{\n    nextNumber = 0;\n\n    fun next()\n    {\n        currentNumber = nextNumber;\n        nextNumber += 2;\n        return currentNumber;\n    }\n\n    fun hasNext()\n    {\n        return nextNumber \n= 20;\n    }\n}\n\n\n\n\nThe result of this code is:\n\n\n0\n2\n4\n6\n8\n10\n12\n14\n16\n18\n20", 
            "title": "Advanced features"
        }, 
        {
            "location": "/tutorials/advanced_features/#advanced-features", 
            "text": "This section describes advanced features of SurgeScript.", 
            "title": "Advanced features"
        }, 
        {
            "location": "/tutorials/advanced_features/#lookup-operator", 
            "text": "Some programming languages, such as C++, have a feature called  operator overloading . It's a  syntactic sugar  that allows the programmer to attribute custom implementations to different operators.  In SurgeScript, the  [ ]  operator (also called the  lookup operator ), used by Arrays and Dictionaries, is used to  get  and  set  values from/to the data structure. In fact, the  [ ]  operator can be used by any object, for any purpose. It is necessary to define, in your object, functions  get()  and  set()  with the following signature:  fun get(key)\n{\n    // custom implementation\n}\n\nfun set(key, value)\n{\n    // custom implementation\n}  Given an object  obj , the expression  x = obj[key]  is equivalent to  x = obj.get(key) . Similarly,  obj[key] = value  is equivalent to  obj.set(key, value) .", 
            "title": "Lookup operator"
        }, 
        {
            "location": "/tutorials/advanced_features/#assertions", 
            "text": "The  assert(condition)  statement specifies a  condition  that you expect to be true at a certain point in your code. If that condition turns out to be false, the code will be interrupted with an  assertion failed  error. Example:  assert(name ==  Surge ); // will crash if name isn't  Surge", 
            "title": "Assertions"
        }, 
        {
            "location": "/tutorials/advanced_features/#functors", 
            "text": "In SurgeScript, objects can be made to behave like functions. We call these objects  functors  (or function objects). To make an object behave like a function, you have to overload the  ( )  operator (also known as the  function operator ). This is done by defining function  call()  in your object:  fun call()\n{\n    // custom implementation\n}  Function  call()  may take any number of parameters. Given an object  f , the expression  y = f(x)  is equivalent to  y = f.call(x) . Notice that, since  f  is an object, you may exchange its implementation during runtime.", 
            "title": "Functors"
        }, 
        {
            "location": "/tutorials/advanced_features/#factory", 
            "text": "In SurgeScript, a factory is a functor that spawns an object for you. The object can be spawned and configured in a single call. In the example below, factory  Greeter  spawns and configures  Greeting  objects. We annotate the factory with  @Plugin , so it can be imported anywhere in the code.  To the end-user, calling  Greeter()  is simpler than manually spawning and configuring a  Greeting  every time it is needed.  // Factory example\nusing Greeter; // import the factory\n\nobject  Application \n{\n    state  main \n    {\n        // This will print:\n        // Hello, alex!\n        g = Greeter( alex );\n        g.greet();\n        exit();\n    }\n}\n\n// File: greeting.ss\nobject  Greeting \n{\n    public name =  anon ;\n\n    fun greet()\n    {\n        Console.print( Hello,   + name +  ! );\n    }\n}\n\n@Plugin\nobject  Greeter \n{\n    // Greeter is a factory. It spawns and configures\n    // a Greeting object for you. Being a plugin,\n    // Greeter can be used anywhere in the code.\n    fun call(name)\n    {\n        g = spawn( Greeting );\n        g.name = name;\n        return g;\n    }\n}  Please note: in the example above, objects spawned by the factory will be children of the factory. If you need the parent of the spawned object to be the caller object, then you might simply write  g = caller.spawn(\"Greeter\") . Keyword  caller  points to the object that called the function (or  null  if not applicable).", 
            "title": "Factory"
        }, 
        {
            "location": "/tutorials/advanced_features/#iterators", 
            "text": "As seen in the  loops  section, the foreach loop may be used to iterate through a collection. In SurgeScript, a collection is an object (but the opposite is not always true). You may implement your own collections by implementing function  iterator() . If you have ever used Java, you'll find this to be familiar.  object  MyCollection \n{\n    fun iterator()\n    {\n        // function iterator() takes no arguments and \n        // should return a new iterator object\n    }\n}  For each collection you define, you should also define its iterator object. The iterator object should implement functions  next()  and  hasNext()  (both take no arguments):  object  MyIterator \n{\n    fun next()\n    {\n        // returns the next element of the collection\n        // and advances the iteration pointer\n        // the collection is usually the parent object\n    }\n\n    function hasNext()\n    {\n        // returns true if the enumeration isn't over\n        // returns false if there are no more elements\n    }\n}  You may iterate through a collection using the following code:  it = collection.iterator();\nwhile(it.hasNext()) {\n    x = it.next();\n\n    // do something with x\n    // x is an element of the collection\n    Console.print(x);\n}  Or, alternatively, using the compact foreach:  foreach(x in collection) {\n    Console.print(x);\n}  For the sake of completion, the following code demonstrates how to implement a custom collection that hold even numbers from 0 up to 20.  object  Application \n{\n    evenNumbers = spawn( EvenNumbers );\n\n    state  main \n    {\n        // iterate through the collection\n        foreach(number in evenNumbers)\n            Console.print(number);\n\n        // exit the app\n        Application.exit();\n    }\n}\n\nobject  EvenNumbers \n{\n    fun iterator()\n    {\n        return spawn( EvenIterator );\n    }\n}\n\nobject  EvenIterator \n{\n    nextNumber = 0;\n\n    fun next()\n    {\n        currentNumber = nextNumber;\n        nextNumber += 2;\n        return currentNumber;\n    }\n\n    fun hasNext()\n    {\n        return nextNumber  = 20;\n    }\n}  The result of this code is:  0\n2\n4\n6\n8\n10\n12\n14\n16\n18\n20", 
            "title": "Iterators"
        }, 
        {
            "location": "/tutorials/best_practices/", 
            "text": "Best Practices\n\n\n\n\nRead the \nComponents\n section. It's crucial that you understand it.\n\n\nFollow the golden rule: objects should \nnot\n mess with each others' internals!\n\n\nObjects should \nnot\n change other objects' variables or states directly (won't allow it!)\n\n\nObjects should define \nfunctions\n that can be operated upon by the external world (API)\n\n\n\n\n\n\nUse \ncamelCase\n names for both variables and functions.\n\n\nUse \n4 spaces\n when indenting your code.\n\n\nCombine related \nplugins\n into a single package.\n\n\nDo \nnot\n pollute the global namespace.\n\n\n\n\n\n\nRead the \nSurgeScript documentation\n often.", 
            "title": "Best practices"
        }, 
        {
            "location": "/tutorials/best_practices/#best-practices", 
            "text": "Read the  Components  section. It's crucial that you understand it.  Follow the golden rule: objects should  not  mess with each others' internals!  Objects should  not  change other objects' variables or states directly (won't allow it!)  Objects should define  functions  that can be operated upon by the external world (API)    Use  camelCase  names for both variables and functions.  Use  4 spaces  when indenting your code.  Combine related  plugins  into a single package.  Do  not  pollute the global namespace.    Read the  SurgeScript documentation  often.", 
            "title": "Best Practices"
        }, 
        {
            "location": "/reference/application/", 
            "text": "Application\n\n\nRepresents the Application. You do not need to instantiate it, as it is instantiated automatically. This object can be accessed by any other object, in any script, simply by typing \nApplication\n.\n\n\nProperties\n\n\nargs\n\n\nargs\n: \nArguments\n object, read-only.\n\n\nUse this property to read the command line arguments.\n\n\nFunctions\n\n\nexit\n\n\nexit()\n\n\nExits the Application.\n\n\ncrash\n\n\ncrash(message)\n\n\nExits the Application with an error message.\n\n\nArguments\n\n\n\n\nmessage\n: string. The message to be displayed to the user.\n\n\n\n\ndestroy\n\n\ndestroy()\n\n\nA synonym for \nApplication.exit()\n.", 
            "title": "Application"
        }, 
        {
            "location": "/reference/application/#application", 
            "text": "Represents the Application. You do not need to instantiate it, as it is instantiated automatically. This object can be accessed by any other object, in any script, simply by typing  Application .", 
            "title": "Application"
        }, 
        {
            "location": "/reference/application/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/reference/application/#args", 
            "text": "args :  Arguments  object, read-only.  Use this property to read the command line arguments.", 
            "title": "args"
        }, 
        {
            "location": "/reference/application/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/reference/application/#exit", 
            "text": "exit()  Exits the Application.", 
            "title": "exit"
        }, 
        {
            "location": "/reference/application/#crash", 
            "text": "crash(message)  Exits the Application with an error message.  Arguments   message : string. The message to be displayed to the user.", 
            "title": "crash"
        }, 
        {
            "location": "/reference/application/#destroy", 
            "text": "destroy()  A synonym for  Application.exit() .", 
            "title": "destroy"
        }, 
        {
            "location": "/reference/arguments/", 
            "text": "Arguments\n\n\nIf you've launched your application via the command-line, this Array-like object can be used to read command-line arguments. This is available at \nApplication.args\n.\n\n\nThe example below prints all the arguments to the screen:\n\n\n// Method 1 (foreach)\nforeach(argument in Application.args)\n    Console.print(argument);\n\n// Method 2 (for loops)\nfor(i = 0; i \n Application.args.length; i++)\n    Console.print(Application.args[i]);\n\n// Or, alternatively:\nConsole.print(Application.args);\n\n\n\n\nProperties\n\n\nlength\n\n\nlength\n: number, read-only.\n\n\nThe number of command-line arguments, including the executable.\n\n\nFunctions\n\n\nget\n\n\nget(index)\n\n\nGets the specified command-line argument. Instead of calling \nget()\n, one may use equivalently the \n[ ]\n operator.\n\n\nArguments\n\n\n\n\nindex\n: integer number between 0 and \nApplication.args.length - 1\n, inclusive.\n\n\n\n\nReturns\n\n\nA string with the specified command-line argument, or \nnull\n if there is no such argument.\n\n\nExample\n\n\n// Suppose that you run surgescript via the command-line:\n// surgescript test_args.ss\nexecutable = Application.args[0]; // \nsurgescript\n\nscript_file = Application.args[1]; // \ntest_args.ss\n\n\n\n\n\noption\n\n\noption(optionName)\n\n\nGets the value of a certain command-line option.\n\n\nArguments\n\n\n\n\noptionName\n: string. The option you want to read.\n\n\n\n\nReturns\n\n\nA string featuring the value of the desired command-line option, or \nnull\n if such an option hasn't been provided by the user.\n\n\nExample\n\n\n// Suppose that you run surgescript via the command-line:\n// surgescript test_args.ss --my-option 12345\nmy_option = Application.args.option(\n--my-option\n);\n\n// Options -p and --port are equivalent\n// surgescript test_args.ss -p 80\n// surgescript test_args.ss --port 80\nport = Application.args.option(\n--port\n) || Application.args.option(\n-p\n);\n\n// Default values (useful if the option is not present)\n// surgescript test_args.ss\n// surgescript test_args.ss --name alice\nname = Application.args.option(\n--name\n) || \nanonymous\n;\n\n\n\n\nhasOption\n\n\nhasOption(optionName)\n\n\nChecks if the specified option is present in the command-line.\n\n\nArguments\n\n\n\n\noptionName\n: string.\n\n\n\n\nReturns\n\n\nReturns \ntrue\n if the specified option is present in the command-line; or \nfalse\n otherwise.\n\n\niterator\n\n\niterator()\n\n\nSpawns an iterator.\n\n\nReturns\n\n\nAn iterator to loop through the command-line arguments.\n\n\ntoString\n\n\ntoString()\n\n\nConverts the command-line arguments to a string.\n\n\nReturns\n\n\nA string featuring the command-line arguments.", 
            "title": "Arguments"
        }, 
        {
            "location": "/reference/arguments/#arguments", 
            "text": "If you've launched your application via the command-line, this Array-like object can be used to read command-line arguments. This is available at  Application.args .  The example below prints all the arguments to the screen:  // Method 1 (foreach)\nforeach(argument in Application.args)\n    Console.print(argument);\n\n// Method 2 (for loops)\nfor(i = 0; i   Application.args.length; i++)\n    Console.print(Application.args[i]);\n\n// Or, alternatively:\nConsole.print(Application.args);", 
            "title": "Arguments"
        }, 
        {
            "location": "/reference/arguments/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/reference/arguments/#length", 
            "text": "length : number, read-only.  The number of command-line arguments, including the executable.", 
            "title": "length"
        }, 
        {
            "location": "/reference/arguments/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/reference/arguments/#get", 
            "text": "get(index)  Gets the specified command-line argument. Instead of calling  get() , one may use equivalently the  [ ]  operator.  Arguments   index : integer number between 0 and  Application.args.length - 1 , inclusive.   Returns  A string with the specified command-line argument, or  null  if there is no such argument.  Example  // Suppose that you run surgescript via the command-line:\n// surgescript test_args.ss\nexecutable = Application.args[0]; //  surgescript \nscript_file = Application.args[1]; //  test_args.ss", 
            "title": "get"
        }, 
        {
            "location": "/reference/arguments/#option", 
            "text": "option(optionName)  Gets the value of a certain command-line option.  Arguments   optionName : string. The option you want to read.   Returns  A string featuring the value of the desired command-line option, or  null  if such an option hasn't been provided by the user.  Example  // Suppose that you run surgescript via the command-line:\n// surgescript test_args.ss --my-option 12345\nmy_option = Application.args.option( --my-option );\n\n// Options -p and --port are equivalent\n// surgescript test_args.ss -p 80\n// surgescript test_args.ss --port 80\nport = Application.args.option( --port ) || Application.args.option( -p );\n\n// Default values (useful if the option is not present)\n// surgescript test_args.ss\n// surgescript test_args.ss --name alice\nname = Application.args.option( --name ) ||  anonymous ;", 
            "title": "option"
        }, 
        {
            "location": "/reference/arguments/#hasoption", 
            "text": "hasOption(optionName)  Checks if the specified option is present in the command-line.  Arguments   optionName : string.   Returns  Returns  true  if the specified option is present in the command-line; or  false  otherwise.", 
            "title": "hasOption"
        }, 
        {
            "location": "/reference/arguments/#iterator", 
            "text": "iterator()  Spawns an iterator.  Returns  An iterator to loop through the command-line arguments.", 
            "title": "iterator"
        }, 
        {
            "location": "/reference/arguments/#tostring", 
            "text": "toString()  Converts the command-line arguments to a string.  Returns  A string featuring the command-line arguments.", 
            "title": "toString"
        }, 
        {
            "location": "/reference/array/", 
            "text": "Array\n\n\nAn Array is a collection of values organized in sequencial fashion. To instantiate an Array, use the \n[ value_1, value_2, ..., value_n ]\n syntax rather than the \nspawn()\n function.\n\n\nExample:\n\n\nobject \nApplication\n\n{\n    // The 'characters' array hold 3 strings\n    characters = [ \nSurge\n, \nNeon\n, \nCharge\n ];\n\n    state \nmain\n\n    {\n        // who are the characters?\n        Console.print(\nThe characters are:\n);\n        Console.print(characters[0]);\n        Console.print(characters[1]);\n        Console.print(characters[2]);\n\n        // how many characters?\n        Console.print(\nNumber of characters: \n + characters.length);\n    }\n}\n\n\n\n\nOutput:\n\n\nThe characters are:\nSurge\nNeon\nCharge\nNumber of characters: 3\n\n\n\n\n\n\nNote:\n\n\nWhenever you define a array, you spawn a new object. One is advised to \nNOT\n define arrays within states, because the code within states run continuously. Therefore, new objects will be created at every frame, not just once.\n\n\n\n\nProperties\n\n\nlength\n\n\nlength\n: number, read-only.\n\n\nThe number of elements in the Array.\n\n\nFunctions\n\n\nget\n\n\nget(index)\n\n\nGets the specified element of the Array. Instead of calling \nget()\n directly, you may equivalently use the \n[ ]\n operator.\n\n\nArguments\n\n\n\n\nindex\n: integer number between \n0\n and \nthis.length - 1\n, inclusive.\n\n\n\n\nReturns\n\n\nThe Array element at position \nindex\n (0-based).\n\n\nExample\n\n\ncharacters = [ \nSurge\n, \nNeon\n, \nCharge\n ];\n\n...\n\nsurge = characters[0];  // first element (\nSurge\n)\nneon = characters[1];   // second element (\nNeon\n)\ncharge = characters[2]; // third element (\nCharge\n)\n\n\n\n\nset\n\n\nset(index, value)\n\n\nSets to \nvalue\n the element of the Array at position \nindex\n. Instead of calling \nset()\n directly, you may equivalently use the \n[ ]\n operator.\n\n\nArguments\n\n\n\n\nindex\n: integer number between \n0\n and \nthis.length - 1\n, inclusive.\n\n\nvalue\n: any type. The new value to be placed on the Array.\n\n\n\n\nExample\n\n\ncharacters = [ \nSurge\n, \nNeon\n, \nCharge\n ];\ncharacters[0] = \nGimacian\n;\nConsole.print(characters[0]); // Gimacian\n\n\n\n\npush\n\n\npush(value)\n\n\nAdds a new element to the end of the Array.\n\n\nArguments\n\n\n\n\nvalue\n: any type. The element to be added to the Array.\n\n\n\n\nExample\n\n\ncharacters = [ \nSurge\n, \nNeon\n, \nCharge\n ];\ncharacters.push(\nGimacian\n);\nConsole.print(characters); // [ \nSurge\n, \nNeon\n, \nCharge\n, \nGimacian\n ]\n\n\n\n\npop\n\n\npop()\n\n\nRemoves the last element of the Array and returns it.\n\n\nReturns\n\n\nThe removed element.\n\n\nshift\n\n\nshift()\n\n\nRemoves the first element of the Array and returns it.\n\n\nReturns\n\n\nThe removed element.\n\n\nunshift\n\n\nunshift(value)\n\n\nAdds a new element to the beginning of the Array.\n\n\nArguments\n\n\n\n\nvalue\n: any type. The element to be added to the Array.\n\n\n\n\nclear\n\n\nclear()\n\n\nClears the array. It will no longer hold any elements and its length will be set to zero.\n\n\nAvailable since:\n SurgeScript 0.5.3\n\n\nindexOf\n\n\nindexOf(value)\n\n\nSearch the Array for element \nvalue\n and return its position.\n\n\nArguments\n\n\n\n\nvalue\n: any type. The element to be searched for.\n\n\n\n\nReturns\n\n\nThe position of the searched element - a number between \n0\n and \nthis.length - 1\n, inclusive. If the desired element is not found, this function returns \n-1\n.\n\n\nExample\n\n\ncharacters = [ \nSurge\n, \nNeon\n, \nCharge\n ];\n...\ntwo = characters.indexOf(\nNeon\n); // 2\ngimacian = characters.indexOf(\nGimacian\n); // -1\nif(gimacian \n 0)\n    Console.print(\nNot found\n);\n\n\n\n\nsort\n\n\nsort(cmpFunc)\n\n\nSorts the Array. If no comparison \nfunctor\n is provided (\ncmpFunc\n is \nnull\n), the Array will be sorted in ascending order.\n\n\nArguments\n\n\n\n\ncmpFunc\n: object | null. This \nfunctor\n implements function \ncall(a, b)\n that compares two array elements as described in the example below.\n\n\n\n\nReturns\n\n\nThe sorted array. The returned array is the same array as you called \nsort()\n on; it's not a copy.\n\n\nExample\n\n\n// this example will print the elements\n// of the Array in ascending order\nobject \nApplication\n\n{\n    arr = [ 3, 9, 4, 8, 5, 6, 7, 1, 2, 0 ];\n\n    state \nmain\n\n    {\n        // sort and print the Array\n        arr.sort(null);\n        Console.print(arr);\n        Application.exit();\n    }\n}\n\n\n\n\nOutput: \n[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n\n\n// this example will print the elements\n// of the Array in descending order\nobject \nApplication\n\n{\n    arr = [ 3, 9, 4, 8, 5, 6, 7, 1, 2, 0 ];\n    cmp = spawn(\nSort.OrderByDesc\n);\n\n    state \nmain\n\n    {\n        // sort and print the Array\n        arr.sort(cmp);\n        Console.print(arr);\n        Application.exit();\n    }\n}\n\nobject \nSort.OrderByDesc\n\n{\n    // This function compares two\n    // elements of the Array: a and b.\n    //\n    // It should return a number:\n    //   \n 0 if a must come BEFORE b\n    //   = 0 if a and b are equivalent\n    //   \n 0 if a must come AFTER b\n    fun call(a, b)\n    {\n        // sort in descending order\n        return b - a;\n    }\n}\n\n\n\n\nOutput: \n[ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ]\n\n\nreverse\n\n\nreverse()\n\n\nReverses the order of the elements in the Array.\n\n\nshuffle\n\n\nshuffle()\n\n\nShuffles the elements of the Array, placing its elements at random spots.\n\n\niterator\n\n\niterator()\n\n\nSpawns an iterator.\n\n\nReturns\n\n\nAn iterator to loop through the elements of the Array.\n\n\ntoString\n\n\ntoString()\n\n\nConverts the Array to a string.\n\n\nReturns\n\n\nA string.", 
            "title": "Array"
        }, 
        {
            "location": "/reference/array/#array", 
            "text": "An Array is a collection of values organized in sequencial fashion. To instantiate an Array, use the  [ value_1, value_2, ..., value_n ]  syntax rather than the  spawn()  function.  Example:  object  Application \n{\n    // The 'characters' array hold 3 strings\n    characters = [  Surge ,  Neon ,  Charge  ];\n\n    state  main \n    {\n        // who are the characters?\n        Console.print( The characters are: );\n        Console.print(characters[0]);\n        Console.print(characters[1]);\n        Console.print(characters[2]);\n\n        // how many characters?\n        Console.print( Number of characters:   + characters.length);\n    }\n}  Output:  The characters are:\nSurge\nNeon\nCharge\nNumber of characters: 3   Note:  Whenever you define a array, you spawn a new object. One is advised to  NOT  define arrays within states, because the code within states run continuously. Therefore, new objects will be created at every frame, not just once.", 
            "title": "Array"
        }, 
        {
            "location": "/reference/array/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/reference/array/#length", 
            "text": "length : number, read-only.  The number of elements in the Array.", 
            "title": "length"
        }, 
        {
            "location": "/reference/array/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/reference/array/#get", 
            "text": "get(index)  Gets the specified element of the Array. Instead of calling  get()  directly, you may equivalently use the  [ ]  operator.  Arguments   index : integer number between  0  and  this.length - 1 , inclusive.   Returns  The Array element at position  index  (0-based).  Example  characters = [  Surge ,  Neon ,  Charge  ];\n\n...\n\nsurge = characters[0];  // first element ( Surge )\nneon = characters[1];   // second element ( Neon )\ncharge = characters[2]; // third element ( Charge )", 
            "title": "get"
        }, 
        {
            "location": "/reference/array/#set", 
            "text": "set(index, value)  Sets to  value  the element of the Array at position  index . Instead of calling  set()  directly, you may equivalently use the  [ ]  operator.  Arguments   index : integer number between  0  and  this.length - 1 , inclusive.  value : any type. The new value to be placed on the Array.   Example  characters = [  Surge ,  Neon ,  Charge  ];\ncharacters[0] =  Gimacian ;\nConsole.print(characters[0]); // Gimacian", 
            "title": "set"
        }, 
        {
            "location": "/reference/array/#push", 
            "text": "push(value)  Adds a new element to the end of the Array.  Arguments   value : any type. The element to be added to the Array.   Example  characters = [  Surge ,  Neon ,  Charge  ];\ncharacters.push( Gimacian );\nConsole.print(characters); // [  Surge ,  Neon ,  Charge ,  Gimacian  ]", 
            "title": "push"
        }, 
        {
            "location": "/reference/array/#pop", 
            "text": "pop()  Removes the last element of the Array and returns it.  Returns  The removed element.", 
            "title": "pop"
        }, 
        {
            "location": "/reference/array/#shift", 
            "text": "shift()  Removes the first element of the Array and returns it.  Returns  The removed element.", 
            "title": "shift"
        }, 
        {
            "location": "/reference/array/#unshift", 
            "text": "unshift(value)  Adds a new element to the beginning of the Array.  Arguments   value : any type. The element to be added to the Array.", 
            "title": "unshift"
        }, 
        {
            "location": "/reference/array/#clear", 
            "text": "clear()  Clears the array. It will no longer hold any elements and its length will be set to zero.  Available since:  SurgeScript 0.5.3", 
            "title": "clear"
        }, 
        {
            "location": "/reference/array/#indexof", 
            "text": "indexOf(value)  Search the Array for element  value  and return its position.  Arguments   value : any type. The element to be searched for.   Returns  The position of the searched element - a number between  0  and  this.length - 1 , inclusive. If the desired element is not found, this function returns  -1 .  Example  characters = [  Surge ,  Neon ,  Charge  ];\n...\ntwo = characters.indexOf( Neon ); // 2\ngimacian = characters.indexOf( Gimacian ); // -1\nif(gimacian   0)\n    Console.print( Not found );", 
            "title": "indexOf"
        }, 
        {
            "location": "/reference/array/#sort", 
            "text": "sort(cmpFunc)  Sorts the Array. If no comparison  functor  is provided ( cmpFunc  is  null ), the Array will be sorted in ascending order.  Arguments   cmpFunc : object | null. This  functor  implements function  call(a, b)  that compares two array elements as described in the example below.   Returns  The sorted array. The returned array is the same array as you called  sort()  on; it's not a copy.  Example  // this example will print the elements\n// of the Array in ascending order\nobject  Application \n{\n    arr = [ 3, 9, 4, 8, 5, 6, 7, 1, 2, 0 ];\n\n    state  main \n    {\n        // sort and print the Array\n        arr.sort(null);\n        Console.print(arr);\n        Application.exit();\n    }\n}  Output:  [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]  // this example will print the elements\n// of the Array in descending order\nobject  Application \n{\n    arr = [ 3, 9, 4, 8, 5, 6, 7, 1, 2, 0 ];\n    cmp = spawn( Sort.OrderByDesc );\n\n    state  main \n    {\n        // sort and print the Array\n        arr.sort(cmp);\n        Console.print(arr);\n        Application.exit();\n    }\n}\n\nobject  Sort.OrderByDesc \n{\n    // This function compares two\n    // elements of the Array: a and b.\n    //\n    // It should return a number:\n    //     0 if a must come BEFORE b\n    //   = 0 if a and b are equivalent\n    //     0 if a must come AFTER b\n    fun call(a, b)\n    {\n        // sort in descending order\n        return b - a;\n    }\n}  Output:  [ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ]", 
            "title": "sort"
        }, 
        {
            "location": "/reference/array/#reverse", 
            "text": "reverse()  Reverses the order of the elements in the Array.", 
            "title": "reverse"
        }, 
        {
            "location": "/reference/array/#shuffle", 
            "text": "shuffle()  Shuffles the elements of the Array, placing its elements at random spots.", 
            "title": "shuffle"
        }, 
        {
            "location": "/reference/array/#iterator", 
            "text": "iterator()  Spawns an iterator.  Returns  An iterator to loop through the elements of the Array.", 
            "title": "iterator"
        }, 
        {
            "location": "/reference/array/#tostring", 
            "text": "toString()  Converts the Array to a string.  Returns  A string.", 
            "title": "toString"
        }, 
        {
            "location": "/reference/boolean/", 
            "text": "Boolean\n\n\nRoutines for booleans. The Boolean object is not supposed to be used directly. The functions below are available for primitive values of the boolean type.\n\n\nFunctions\n\n\nvalueOf\n\n\nvalueOf()\n\n\nThe primitive value of the boolean, i.e., the boolean itself.\n\n\nReturns\n\n\nThe boolean.\n\n\ntoString\n\n\ntoString()\n\n\nConvert boolean to string.\n\n\nReturns\n\n\nThe boolean converted to a string.\n\n\nequals\n\n\nequals(b)\n\n\nCompares the boolean to another boolean \nb\n.\n\n\nArguments\n\n\n\n\nb\n: boolean. The value to compare the boolean to.\n\n\n\n\nReturns\n\n\nReturns \ntrue\n if the booleans are equal.", 
            "title": "Boolean"
        }, 
        {
            "location": "/reference/boolean/#boolean", 
            "text": "Routines for booleans. The Boolean object is not supposed to be used directly. The functions below are available for primitive values of the boolean type.", 
            "title": "Boolean"
        }, 
        {
            "location": "/reference/boolean/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/reference/boolean/#valueof", 
            "text": "valueOf()  The primitive value of the boolean, i.e., the boolean itself.  Returns  The boolean.", 
            "title": "valueOf"
        }, 
        {
            "location": "/reference/boolean/#tostring", 
            "text": "toString()  Convert boolean to string.  Returns  The boolean converted to a string.", 
            "title": "toString"
        }, 
        {
            "location": "/reference/boolean/#equals", 
            "text": "equals(b)  Compares the boolean to another boolean  b .  Arguments   b : boolean. The value to compare the boolean to.   Returns  Returns  true  if the booleans are equal.", 
            "title": "equals"
        }, 
        {
            "location": "/reference/console/", 
            "text": "Console\n\n\nThe Console is a mechanism that allows users to interact with your app via a text-based interface. You can print data to the user and read data from the user.\n\n\nFunctions\n\n\nprint\n\n\nprint(line)\n\n\nPrints a line to the console.\n\n\nArguments\n\n\n\n\nline\n: string. The message to be printed.\n\n\n\n\nExample\n\n\n// this will print \nHello, there!\n and quit\nobject \nApplication\n\n{\n    state \nmain\n\n    {\n        Console.print(\nHello, there!\n);\n        Application.exit();\n    }\n}\n\n\n\n\nwrite\n\n\nwrite(str)\n\n\nWrites a string to the console, without a line break at the end.\n\n\nArguments\n\n\n\n\nstr\n: string. The string to be written.\n\n\n\n\nreadline\n\n\nreadline()\n\n\nReads a line from the standard input.\n\n\nReturns\n\n\nReturns the string just read, without a line break at the end.\n\n\nExample\n\n\n// will ask the name of the user until a name is given\nobject \nApplication\n\n{\n    state \nmain\n\n    {\n        Console.print(\nHey pal, what's your name? \n);\n        name = Console.readline();\n        if(name != \n) {\n            Console.print(\nNice to meet you, \n + name);\n            Application.exit();\n        }\n    }\n}", 
            "title": "Console"
        }, 
        {
            "location": "/reference/console/#console", 
            "text": "The Console is a mechanism that allows users to interact with your app via a text-based interface. You can print data to the user and read data from the user.", 
            "title": "Console"
        }, 
        {
            "location": "/reference/console/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/reference/console/#print", 
            "text": "print(line)  Prints a line to the console.  Arguments   line : string. The message to be printed.   Example  // this will print  Hello, there!  and quit\nobject  Application \n{\n    state  main \n    {\n        Console.print( Hello, there! );\n        Application.exit();\n    }\n}", 
            "title": "print"
        }, 
        {
            "location": "/reference/console/#write", 
            "text": "write(str)  Writes a string to the console, without a line break at the end.  Arguments   str : string. The string to be written.", 
            "title": "write"
        }, 
        {
            "location": "/reference/console/#readline", 
            "text": "readline()  Reads a line from the standard input.  Returns  Returns the string just read, without a line break at the end.  Example  // will ask the name of the user until a name is given\nobject  Application \n{\n    state  main \n    {\n        Console.print( Hey pal, what's your name?  );\n        name = Console.readline();\n        if(name !=  ) {\n            Console.print( Nice to meet you,   + name);\n            Application.exit();\n        }\n    }\n}", 
            "title": "readline"
        }, 
        {
            "location": "/reference/date/", 
            "text": "Date\n\n\nDate is used to retrieve current date and time. You can access this object simply by typing \nDate\n.\n\n\nExample:\n\n\n// What day is today?\nobject \nApplication\n\n{\n    // show the day\n    state \nmain\n\n    {\n        today = Date.year + \n-\n + f(Date.month) + \n-\n + f(Date.day);\n        Console.print(\nToday is \n + today);\n        Application.exit();\n    }\n\n    // add a leading zero\n    fun f(x)\n    {\n        if(x \n= 10)\n            return x;\n        else\n            return \n0\n + x;\n    }\n}\n\n\n\n\nAvailable since:\n SurgeScript 0.5.2\n\n\nProperties\n\n\nyear\n\n\nyear\n: number, read-only.\n\n\nThe current year.\n\n\nmonth\n\n\nmonth\n: number, read-only.\n\n\nMonth of the year (1-12).\n\n\nday\n\n\nday\n: number.\n\n\nDay of the month (1-31).\n\n\nhour\n\n\nhour\n: number.\n\n\nHours since midnight (0-23).\n\n\nminute\n\n\nminute\n: number.\n\n\nMinutes after the hour (0-59).\n\n\nsecond\n\n\nsecond\n: number.\n\n\nSeconds after the minute (0-59).\n\n\nweekday\n\n\nweekday\n: number.\n\n\nDays since Sunday (0-6).\n\n\nunixtime\n\n\nunixtime\n: number.\n\n\nNumber of seconds since Jan 1st, 1970 00:00:00 UTC.\n\n\nFunctions\n\n\ntimezoneOffset\n\n\ntimezoneOffset()\n\n\nThe difference, in minutes, from the Coordinated Universal Time (UTC) to the timezone of the host. Example: if your timezone is UTC-03:00, this function returns -180.\n\n\nAvailable since:\n SurgeScript 0.5.2\n\n\nReturns\n\n\nThe timezone difference in minutes.\n\n\ntoString\n\n\ntoString()\n\n\nConverts the current date and time to a string. The string is formatted according to the ISO 8601 standard.\n\n\nAvailable since:\n SurgeScript 0.5.2\n\n\nReturns\n\n\nThe current date and time expressed according to ISO 8601.", 
            "title": "Date"
        }, 
        {
            "location": "/reference/date/#date", 
            "text": "Date is used to retrieve current date and time. You can access this object simply by typing  Date .  Example:  // What day is today?\nobject  Application \n{\n    // show the day\n    state  main \n    {\n        today = Date.year +  -  + f(Date.month) +  -  + f(Date.day);\n        Console.print( Today is   + today);\n        Application.exit();\n    }\n\n    // add a leading zero\n    fun f(x)\n    {\n        if(x  = 10)\n            return x;\n        else\n            return  0  + x;\n    }\n}  Available since:  SurgeScript 0.5.2", 
            "title": "Date"
        }, 
        {
            "location": "/reference/date/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/reference/date/#year", 
            "text": "year : number, read-only.  The current year.", 
            "title": "year"
        }, 
        {
            "location": "/reference/date/#month", 
            "text": "month : number, read-only.  Month of the year (1-12).", 
            "title": "month"
        }, 
        {
            "location": "/reference/date/#day", 
            "text": "day : number.  Day of the month (1-31).", 
            "title": "day"
        }, 
        {
            "location": "/reference/date/#hour", 
            "text": "hour : number.  Hours since midnight (0-23).", 
            "title": "hour"
        }, 
        {
            "location": "/reference/date/#minute", 
            "text": "minute : number.  Minutes after the hour (0-59).", 
            "title": "minute"
        }, 
        {
            "location": "/reference/date/#second", 
            "text": "second : number.  Seconds after the minute (0-59).", 
            "title": "second"
        }, 
        {
            "location": "/reference/date/#weekday", 
            "text": "weekday : number.  Days since Sunday (0-6).", 
            "title": "weekday"
        }, 
        {
            "location": "/reference/date/#unixtime", 
            "text": "unixtime : number.  Number of seconds since Jan 1st, 1970 00:00:00 UTC.", 
            "title": "unixtime"
        }, 
        {
            "location": "/reference/date/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/reference/date/#timezoneoffset", 
            "text": "timezoneOffset()  The difference, in minutes, from the Coordinated Universal Time (UTC) to the timezone of the host. Example: if your timezone is UTC-03:00, this function returns -180.  Available since:  SurgeScript 0.5.2  Returns  The timezone difference in minutes.", 
            "title": "timezoneOffset"
        }, 
        {
            "location": "/reference/date/#tostring", 
            "text": "toString()  Converts the current date and time to a string. The string is formatted according to the ISO 8601 standard.  Available since:  SurgeScript 0.5.2  Returns  The current date and time expressed according to ISO 8601.", 
            "title": "toString"
        }, 
        {
            "location": "/reference/dictionary/", 
            "text": "Dictionary\n\n\nA Dictionary is a collection of key-value pairs. Dictionary keys are strings. Their corresponding values can be of any type. To create a Dictionary, use the \n{ key_1: value_1, key_2: value_2, ..., key_n: value_n }\n syntax rather than the \nspawn()\n function.\n\n\nExample:\n\n\nobject \nApplication\n\n{\n    dictionary = {\n        \nSurge\n: 35,\n        \nNeon\n: 20,\n        \nCharge\n: 37.5,\n        \nGimacian\n: 70\n    };\n\n    state \nmain\n\n    {\n        // usage example\n        Console.print(dictionary[\nSurge\n]); // will print 35\n        Console.print(dictionary[\nNeon\n]); // will print 20\n\n        // will print all entries\n        foreach(entry in dictionary)\n            Console.print(entry.key + \n: \n + entry.value);\n\n        // done!\n        Application.exit();\n    }\n}\n\n\n\n\nOutput:\n\n\n35\n20\nSurge: 35\nNeon: 20\nCharge: 37.5\nGimacian: 70\n\n\n\n\n\n\nNote:\n\n\nWhenever you define a dictionary, you spawn a new object. One is advised to \nNOT\n define dictionaries within states, because the code within states run continuously. Therefore, new objects will be created at every frame of the application, not just once.\n\n\n\n\nProperties\n\n\ncount\n\n\ncount\n: number, read-only.\n\n\nThe number of elements in the Dictionary.\n\n\nFunctions\n\n\nget\n\n\nget(key)\n\n\nGets the value of the specified key in the Dictionary. Instead of calling \nget()\n directly, you may equivalently use the \n[ ]\n operator.\n\n\nArguments\n\n\n\n\nkey\n: string.\n\n\n\n\nReturns\n\n\nThe value corresponding to the specified key, or \nnull\n if there is no such an entry in the Dictionary.\n\n\nExample\n\n\ndict = { \nSurge\n: 10 };\nten = dict[\nSurge\n];\n\n\n\n\nset\n\n\nset(key, value)\n\n\nSets the value of the specified key in the Dictionary. Instead of calling \nset()\n directly, you may equivalently use the \n[ ]\n operator.\n\n\nArguments\n\n\n\n\nkey\n: string.\n\n\nvalue\n: any type.\n\n\n\n\nExample\n\n\ndict = { };\ndict[\nSurge\n] = 10;\n\n\n\n\nclear\n\n\nclear()\n\n\nRemoves all entries from the Dictionary.\n\n\ndelete\n\n\ndelete(key)\n\n\nDeletes the entry having the specified key.\n\n\nArguments\n\n\n\n\nkey\n: string. The key of the entry to be removed.\n\n\n\n\nhas\n\n\nhas(key)\n\n\nChecks if an entry having the specified key belongs to the Dictionary.\n\n\nArguments\n\n\n\n\nkey\n: string. The key of the entry.\n\n\n\n\nReturns\n\n\nReturns \ntrue\n if the Dictionary has such an entry.\n\n\nkeys\n\n\nkeys()\n\n\nGets a collection containing the keys of the Dictionary.\n\n\nReturns\n\n\nReturns a new \nArray\n containing the keys of the Dictionary.\n\n\niterator\n\n\niterator()\n\n\nSpawns an iterator.\n\n\nReturns\n\n\nAn iterator to loop through the elements of the Dictionary.\n\n\ntoString\n\n\ntoString()\n\n\nConverts the Dictionary to a string.\n\n\nReturns\n\n\nA string.", 
            "title": "Dictionary"
        }, 
        {
            "location": "/reference/dictionary/#dictionary", 
            "text": "A Dictionary is a collection of key-value pairs. Dictionary keys are strings. Their corresponding values can be of any type. To create a Dictionary, use the  { key_1: value_1, key_2: value_2, ..., key_n: value_n }  syntax rather than the  spawn()  function.  Example:  object  Application \n{\n    dictionary = {\n         Surge : 35,\n         Neon : 20,\n         Charge : 37.5,\n         Gimacian : 70\n    };\n\n    state  main \n    {\n        // usage example\n        Console.print(dictionary[ Surge ]); // will print 35\n        Console.print(dictionary[ Neon ]); // will print 20\n\n        // will print all entries\n        foreach(entry in dictionary)\n            Console.print(entry.key +  :   + entry.value);\n\n        // done!\n        Application.exit();\n    }\n}  Output:  35\n20\nSurge: 35\nNeon: 20\nCharge: 37.5\nGimacian: 70   Note:  Whenever you define a dictionary, you spawn a new object. One is advised to  NOT  define dictionaries within states, because the code within states run continuously. Therefore, new objects will be created at every frame of the application, not just once.", 
            "title": "Dictionary"
        }, 
        {
            "location": "/reference/dictionary/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/reference/dictionary/#count", 
            "text": "count : number, read-only.  The number of elements in the Dictionary.", 
            "title": "count"
        }, 
        {
            "location": "/reference/dictionary/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/reference/dictionary/#get", 
            "text": "get(key)  Gets the value of the specified key in the Dictionary. Instead of calling  get()  directly, you may equivalently use the  [ ]  operator.  Arguments   key : string.   Returns  The value corresponding to the specified key, or  null  if there is no such an entry in the Dictionary.  Example  dict = {  Surge : 10 };\nten = dict[ Surge ];", 
            "title": "get"
        }, 
        {
            "location": "/reference/dictionary/#set", 
            "text": "set(key, value)  Sets the value of the specified key in the Dictionary. Instead of calling  set()  directly, you may equivalently use the  [ ]  operator.  Arguments   key : string.  value : any type.   Example  dict = { };\ndict[ Surge ] = 10;", 
            "title": "set"
        }, 
        {
            "location": "/reference/dictionary/#clear", 
            "text": "clear()  Removes all entries from the Dictionary.", 
            "title": "clear"
        }, 
        {
            "location": "/reference/dictionary/#delete", 
            "text": "delete(key)  Deletes the entry having the specified key.  Arguments   key : string. The key of the entry to be removed.", 
            "title": "delete"
        }, 
        {
            "location": "/reference/dictionary/#has", 
            "text": "has(key)  Checks if an entry having the specified key belongs to the Dictionary.  Arguments   key : string. The key of the entry.   Returns  Returns  true  if the Dictionary has such an entry.", 
            "title": "has"
        }, 
        {
            "location": "/reference/dictionary/#keys", 
            "text": "keys()  Gets a collection containing the keys of the Dictionary.  Returns  Returns a new  Array  containing the keys of the Dictionary.", 
            "title": "keys"
        }, 
        {
            "location": "/reference/dictionary/#iterator", 
            "text": "iterator()  Spawns an iterator.  Returns  An iterator to loop through the elements of the Dictionary.", 
            "title": "iterator"
        }, 
        {
            "location": "/reference/dictionary/#tostring", 
            "text": "toString()  Converts the Dictionary to a string.  Returns  A string.", 
            "title": "toString"
        }, 
        {
            "location": "/reference/gc/", 
            "text": "GC\n\n\nSurgeScript features a Garbage Collector (GC) that automatically disposes objects that cannot be reached from the root (i.e., their references are lost). The Garbage Collector is available at \nSystem.gc\n. Generally, you do not need to modify any of its settings.\n\n\nProperties\n\n\ninterval\n\n\ninterval\n: number.\n\n\nEvery \ninterval\n seconds, the garbage collector will be called automatically.\n\n\nobjectCount\n\n\nobjectCount\n: number, read-only.\n\n\nHow many objects were disposed when the garbage collector was last called.\n\n\nFunctions\n\n\ncollect\n\n\ncollect()\n\n\nCalls the Garbage Collector manually.", 
            "title": "GC"
        }, 
        {
            "location": "/reference/gc/#gc", 
            "text": "SurgeScript features a Garbage Collector (GC) that automatically disposes objects that cannot be reached from the root (i.e., their references are lost). The Garbage Collector is available at  System.gc . Generally, you do not need to modify any of its settings.", 
            "title": "GC"
        }, 
        {
            "location": "/reference/gc/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/reference/gc/#interval", 
            "text": "interval : number.  Every  interval  seconds, the garbage collector will be called automatically.", 
            "title": "interval"
        }, 
        {
            "location": "/reference/gc/#objectcount", 
            "text": "objectCount : number, read-only.  How many objects were disposed when the garbage collector was last called.", 
            "title": "objectCount"
        }, 
        {
            "location": "/reference/gc/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/reference/gc/#collect", 
            "text": "collect()  Calls the Garbage Collector manually.", 
            "title": "collect"
        }, 
        {
            "location": "/reference/iterator/", 
            "text": "Iterator\n\n\nIn SurgeScript, Iterator is an abstract contract, or protocol, that define a set of functions that should be written in concrete implementations. If you're familiar with object oriented programming, Iterator is an interface. Iterators are used to traverse containers / collections / data structures and access its elements.\n\n\nConcrete implementations of Iterator include: \nArrayIterator\n and \nDictionaryIterator\n. If you wish to \nwrite your own iterators\n, you need to specify the \nfunctions described below\n.\n\n\nThe data structure that you wish to traverse should include an \niterator()\n function that spawns the concrete implementation of the Iterator. Thus, the \nparent\n object of the Iterator will be the structure to be traversed.\n\n\nThe basic usage of an Iterator is as follows:\n\n\n// container is an object such as an Array\niterator = container.iterator(); // spawn an iterator to traverse the container\nwhile(iterator.hasNext()) {\n    element = iterator.next();\n    Console.print(element);\n}\n\n\n\n\nFunctions\n\n\nhasNext\n\n\nhasNext()\n\n\nChecks if there are more elements to be accessed in the iteration.\n\n\nReturns\n\n\nReturns \ntrue\n if there are more elements to be visited, or \nfalse\n otherwise.\n\n\nnext\n\n\nnext()\n\n\nGets the next element of the container and advances the iteration.\n\n\nReturns\n\n\nThe next element of the container, or \nnull\n if there is no such element. The first call to \nnext()\n returns the first element of the container, and so on.", 
            "title": "Iterator"
        }, 
        {
            "location": "/reference/iterator/#iterator", 
            "text": "In SurgeScript, Iterator is an abstract contract, or protocol, that define a set of functions that should be written in concrete implementations. If you're familiar with object oriented programming, Iterator is an interface. Iterators are used to traverse containers / collections / data structures and access its elements.  Concrete implementations of Iterator include:  ArrayIterator  and  DictionaryIterator . If you wish to  write your own iterators , you need to specify the  functions described below .  The data structure that you wish to traverse should include an  iterator()  function that spawns the concrete implementation of the Iterator. Thus, the  parent  object of the Iterator will be the structure to be traversed.  The basic usage of an Iterator is as follows:  // container is an object such as an Array\niterator = container.iterator(); // spawn an iterator to traverse the container\nwhile(iterator.hasNext()) {\n    element = iterator.next();\n    Console.print(element);\n}", 
            "title": "Iterator"
        }, 
        {
            "location": "/reference/iterator/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/reference/iterator/#hasnext", 
            "text": "hasNext()  Checks if there are more elements to be accessed in the iteration.  Returns  Returns  true  if there are more elements to be visited, or  false  otherwise.", 
            "title": "hasNext"
        }, 
        {
            "location": "/reference/iterator/#next", 
            "text": "next()  Gets the next element of the container and advances the iteration.  Returns  The next element of the container, or  null  if there is no such element. The first call to  next()  returns the first element of the container, and so on.", 
            "title": "next"
        }, 
        {
            "location": "/reference/math/", 
            "text": "Math\n\n\nBuilt-in mathematical functions. The Math object can be accessed simply by typing \nMath\n.\n\n\nExamples:\n\n\n// Math functions\ntwo = Math.sqrt(4); // square root of 4\neight = Math.pow(2, 3); // 2 raised to the 3rd power\nzero = Math.sin(0); // sine of 0\nseven = Math.max(5, 7); // maximum of 5 and 7\n\n\n\n\nProperties\n\n\npi\n\n\npi\n: number, read-only.\n\n\nAn approximation of pi (3.1415926535...)\n\n\nepsilon\n\n\nepsilon\n: number, read-only.\n\n\nThe difference between 1 and the smallest floating point number that is greater than 1.\n\n\ninfinity\n\n\ninfinity\n: number, read-only.\n\n\nA floating point representation of positive infinity.\n\n\nNaN\n\n\nNaN\n: number, read-only.\n\n\nA numeric data type representing Not-a-Number.\n\n\nAvailable since:\n SurgeScript 0.5.3\n\n\nFunctions\n\n\nsqrt\n\n\nsqrt(x)\n\n\nSquare root function.\n\n\nArguments\n\n\n\n\nx\n: number.\n\n\n\n\nReturns\n\n\nThe square root of \nx\n.\n\n\npow\n\n\npow(x, p)\n\n\nRaise to power.\n\n\nArguments\n\n\n\n\nx\n: number. The base.\n\n\np\n: number. The exponent.\n\n\n\n\nReturns\n\n\nReturns \nx\n raised to the \np\n power.\n\n\nexp\n\n\ne(x)\n\n\nExponential function.\n\n\nArguments\n\n\n\n\nx\n: number.\n\n\n\n\nReturns\n\n\nReturns \ne\n raised to the \nx\n power.\n\n\nlog\n\n\nlog(x)\n\n\nNatural logarithm.\n\n\nArguments\n\n\n\n\nx\n: number.\n\n\n\n\nReturns\n\n\nThe natural logarithm (base \ne\n) of \nx\n.\n\n\nlog10\n\n\nlog10(x)\n\n\nBase 10 logarithm.\n\n\nArguments\n\n\n\n\nx\n: number.\n\n\n\n\nReturns\n\n\nThe base 10 logarithm of \nx\n.\n\n\nsin\n\n\nsin(x)\n\n\nSine function.\n\n\nArguments\n\n\n\n\nx\n: number. Angle in radians.\n\n\n\n\nReturns\n\n\nThe sine of \nx\n.\n\n\ncos\n\n\ncos(x)\n\n\nCosine function.\n\n\nArguments\n\n\n\n\nx\n: number. Angle in radians.\n\n\n\n\nReturns\n\n\nThe cosine of \nx\n.\n\n\ntan\n\n\ntan(x)\n\n\nTangent function.\n\n\nArguments\n\n\n\n\nx\n: number. Angle in radians.\n\n\n\n\nReturns\n\n\nThe tangent of \nx\n.\n\n\nasin\n\n\nasin(x)\n\n\nArc-sine function.\n\n\nArguments\n\n\n\n\nx\n: number.\n\n\n\n\nReturns\n\n\nThe angle in radians whose sine is \nx\n.\n\n\nacos\n\n\nacos(x)\n\n\nArc-cosine function.\n\n\nArguments\n\n\n\n\nx\n: number.\n\n\n\n\nReturns\n\n\nThe angle in radians whose cosine is \nx\n.\n\n\natan\n\n\natan(x)\n\n\nArc-tangent function.\n\n\nArguments\n\n\n\n\nx\n: number.\n\n\n\n\nReturns\n\n\nThe angle in radians whose tangent is \nx\n.\n\n\natan2\n\n\natan2(y, x)\n\n\nFunction atan2.\n\n\nArguments\n\n\n\n\ny\n: number.\n\n\nx\n: number.\n\n\n\n\nReturns\n\n\nThe angle, in radians, between the positive x-axis and the \n(x, y)\n vector.\n\n\ndeg2rad\n\n\ndeg2rad(degrees)\n\n\nConverts \ndegrees\n to radians.\n\n\nAvailable since:\n SurgeScript 0.5.3\n\n\nArguments\n\n\n\n\ndegrees\n: number.\n\n\n\n\nReturns\n\n\nThe converted value.\n\n\nrad2deg\n\n\nrad2deg(radians)\n\n\nConverts \nradians\n to degrees.\n\n\nAvailable since:\n SurgeScript 0.5.3\n\n\nArguments\n\n\n\n\nradians\n: number.\n\n\n\n\nReturns\n\n\nThe converted value.\n\n\nrandom\n\n\nrandom()\n\n\nRandom value.\n\n\nReturns\n\n\nA random number between 0 (inclusive) and 1 (exclusive).\n\n\nfloor\n\n\nfloor(x)\n\n\nFloor function.\n\n\nArguments\n\n\n\n\nx\n: number.\n\n\n\n\nReturns\n\n\nThe largest integer less or equal than \nx\n.\n\n\nceil\n\n\nceil(x)\n\n\nCeiling function.\n\n\nArguments\n\n\n\n\nx\n: number.\n\n\n\n\nReturns\n\n\nThe smallest integer greater or equal than \nx\n.\n\n\nround\n\n\nround(x)\n\n\nRound to the nearest integer.\n\n\nArguments\n\n\n\n\nx\n: number.\n\n\n\n\nReturns\n\n\nReturns \nx\n rounded to the nearest integer.\n\n\nIf the fraction of \nx\n is 0.5, this function uses the \ncommercial rounding\n tie-breaking method.\n\n\nmod\n\n\nmod(x, y)\n\n\nModulus function. Used to get the remainder of a division.\n\n\nDeprecated since SurgeScript 0.5.3. Use the remainder operator (%) instead, e.g.\n \nx % y\n.\n\n\nArguments\n\n\n\n\nx\n: number.\n\n\ny\n: number.\n\n\n\n\nReturns\n\n\nThe remainder of \nx / y\n.\n\n\nsign\n\n\nsign(x)\n\n\nThe sign of \nx\n.\n\n\nArguments\n\n\n\n\nx\n: number.\n\n\n\n\nReturns\n\n\nReturns 1 if \nx\n is positive or zero; or -1 if \nx\n is negative.\n\n\nabs\n\n\nabs(x)\n\n\nAbsolute value of \nx\n.\n\n\nArguments\n\n\n\n\nx\n: number.\n\n\n\n\nReturns\n\n\nReturns \n-x\n if \nx\n is negative, or \nx\n otherwise.\n\n\nmin\n\n\nmin(x, y)\n\n\nThe minimum of two values.\n\n\nArguments\n\n\n\n\nx\n: number.\n\n\ny\n: number.\n\n\n\n\nReturns\n\n\nReturns the smallest of two values: \nx\n and \ny\n.\n\n\nmax\n\n\nmax(x, y)\n\n\nThe maximum of two values.\n\n\nArguments\n\n\n\n\nx\n: number.\n\n\ny\n: number.\n\n\n\n\nReturns\n\n\nReturns the largest of two values: \nx\n and \ny\n.\n\n\nclamp\n\n\nclamp(val, min, max)\n\n\nClamps a value between a minimum and a maximum.\n\n\nArguments\n\n\n\n\nval\n: number. The value to be clamped.\n\n\nmin\n: number. Minimum value.\n\n\nmax\n: number. Maximum value.\n\n\n\n\nReturns\n\n\nReturns \nval\n clamped between \nmin\n and \nmax\n. Function \nclamp\n behave as follows:\n\n\n\n\nif \nval\n \n \nmin\n, it returns \nmin\n\n\nif \nval\n \n \nmax\n, it returns \nmax\n\n\notherwise, it returns \nval\n\n\n\n\napproximately\n\n\napproximately(x, y)\n\n\nCompares two floating point values. Since comparing two floating point numbers for equality directly may result in inaccuracies, this is a handy function.\n\n\nArguments\n\n\n\n\nx\n: number.\n\n\ny\n: number.\n\n\n\n\nReturns\n\n\nReturns \ntrue\n if \nx\n and \ny\n are \n\"approximately\"\n equal (they are within a small distance of \nepsilon\n of each other).\n\n\nlerp\n\n\nlerp(a, b, t)\n\n\nLinear interpolation.\n\n\nArguments\n\n\n\n\na\n: number.\n\n\nb\n: number.\n\n\nt\n: number. A value between 0 and 1.\n\n\n\n\nReturns\n\n\nReturns the linear interpolation between \na\n and \nb\n by \nt\n.\n\n\nValue \nt\n is clamped automatically to range \n[0, 1]\n.\n\n\nAs an example, note that \nlerp\n:\n\n\n\n\nreturns \na\n if \nt\n is \n0\n\n\nreturns \nb\n if \nt\n is \n1\n\n\nreturns \n(a + b) / 2\n if \nt\n is \n0.5\n\n\n\n\nsmoothstep\n\n\nsmoothstep(a, b, t)\n\n\nInterpolation smoothing at the limits.\n\n\nArguments\n\n\n\n\na\n: number.\n\n\nb\n: number.\n\n\nt\n: number. A value between 0 and 1.\n\n\n\n\nReturns\n\n\nReturns an interpolated value between \na\n and \nb\n by \nt\n, in a similar way to \nlerp\n. Unlike the linear \nlerp\n, \nsmoothstep\n is smooth at the limits. This is useful to create smooth transitions and animations.\n\n\nValue \nt\n is clamped automatically to range \n[0, 1]\n.", 
            "title": "Math"
        }, 
        {
            "location": "/reference/math/#math", 
            "text": "Built-in mathematical functions. The Math object can be accessed simply by typing  Math .  Examples:  // Math functions\ntwo = Math.sqrt(4); // square root of 4\neight = Math.pow(2, 3); // 2 raised to the 3rd power\nzero = Math.sin(0); // sine of 0\nseven = Math.max(5, 7); // maximum of 5 and 7", 
            "title": "Math"
        }, 
        {
            "location": "/reference/math/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/reference/math/#pi", 
            "text": "pi : number, read-only.  An approximation of pi (3.1415926535...)", 
            "title": "pi"
        }, 
        {
            "location": "/reference/math/#epsilon", 
            "text": "epsilon : number, read-only.  The difference between 1 and the smallest floating point number that is greater than 1.", 
            "title": "epsilon"
        }, 
        {
            "location": "/reference/math/#infinity", 
            "text": "infinity : number, read-only.  A floating point representation of positive infinity.", 
            "title": "infinity"
        }, 
        {
            "location": "/reference/math/#nan", 
            "text": "NaN : number, read-only.  A numeric data type representing Not-a-Number.  Available since:  SurgeScript 0.5.3", 
            "title": "NaN"
        }, 
        {
            "location": "/reference/math/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/reference/math/#sqrt", 
            "text": "sqrt(x)  Square root function.  Arguments   x : number.   Returns  The square root of  x .", 
            "title": "sqrt"
        }, 
        {
            "location": "/reference/math/#pow", 
            "text": "pow(x, p)  Raise to power.  Arguments   x : number. The base.  p : number. The exponent.   Returns  Returns  x  raised to the  p  power.", 
            "title": "pow"
        }, 
        {
            "location": "/reference/math/#exp", 
            "text": "e(x)  Exponential function.  Arguments   x : number.   Returns  Returns  e  raised to the  x  power.", 
            "title": "exp"
        }, 
        {
            "location": "/reference/math/#log", 
            "text": "log(x)  Natural logarithm.  Arguments   x : number.   Returns  The natural logarithm (base  e ) of  x .", 
            "title": "log"
        }, 
        {
            "location": "/reference/math/#log10", 
            "text": "log10(x)  Base 10 logarithm.  Arguments   x : number.   Returns  The base 10 logarithm of  x .", 
            "title": "log10"
        }, 
        {
            "location": "/reference/math/#sin", 
            "text": "sin(x)  Sine function.  Arguments   x : number. Angle in radians.   Returns  The sine of  x .", 
            "title": "sin"
        }, 
        {
            "location": "/reference/math/#cos", 
            "text": "cos(x)  Cosine function.  Arguments   x : number. Angle in radians.   Returns  The cosine of  x .", 
            "title": "cos"
        }, 
        {
            "location": "/reference/math/#tan", 
            "text": "tan(x)  Tangent function.  Arguments   x : number. Angle in radians.   Returns  The tangent of  x .", 
            "title": "tan"
        }, 
        {
            "location": "/reference/math/#asin", 
            "text": "asin(x)  Arc-sine function.  Arguments   x : number.   Returns  The angle in radians whose sine is  x .", 
            "title": "asin"
        }, 
        {
            "location": "/reference/math/#acos", 
            "text": "acos(x)  Arc-cosine function.  Arguments   x : number.   Returns  The angle in radians whose cosine is  x .", 
            "title": "acos"
        }, 
        {
            "location": "/reference/math/#atan", 
            "text": "atan(x)  Arc-tangent function.  Arguments   x : number.   Returns  The angle in radians whose tangent is  x .", 
            "title": "atan"
        }, 
        {
            "location": "/reference/math/#atan2", 
            "text": "atan2(y, x)  Function atan2.  Arguments   y : number.  x : number.   Returns  The angle, in radians, between the positive x-axis and the  (x, y)  vector.", 
            "title": "atan2"
        }, 
        {
            "location": "/reference/math/#deg2rad", 
            "text": "deg2rad(degrees)  Converts  degrees  to radians.  Available since:  SurgeScript 0.5.3  Arguments   degrees : number.   Returns  The converted value.", 
            "title": "deg2rad"
        }, 
        {
            "location": "/reference/math/#rad2deg", 
            "text": "rad2deg(radians)  Converts  radians  to degrees.  Available since:  SurgeScript 0.5.3  Arguments   radians : number.   Returns  The converted value.", 
            "title": "rad2deg"
        }, 
        {
            "location": "/reference/math/#random", 
            "text": "random()  Random value.  Returns  A random number between 0 (inclusive) and 1 (exclusive).", 
            "title": "random"
        }, 
        {
            "location": "/reference/math/#floor", 
            "text": "floor(x)  Floor function.  Arguments   x : number.   Returns  The largest integer less or equal than  x .", 
            "title": "floor"
        }, 
        {
            "location": "/reference/math/#ceil", 
            "text": "ceil(x)  Ceiling function.  Arguments   x : number.   Returns  The smallest integer greater or equal than  x .", 
            "title": "ceil"
        }, 
        {
            "location": "/reference/math/#round", 
            "text": "round(x)  Round to the nearest integer.  Arguments   x : number.   Returns  Returns  x  rounded to the nearest integer.  If the fraction of  x  is 0.5, this function uses the  commercial rounding  tie-breaking method.", 
            "title": "round"
        }, 
        {
            "location": "/reference/math/#mod", 
            "text": "mod(x, y)  Modulus function. Used to get the remainder of a division.  Deprecated since SurgeScript 0.5.3. Use the remainder operator (%) instead, e.g.   x % y .  Arguments   x : number.  y : number.   Returns  The remainder of  x / y .", 
            "title": "mod"
        }, 
        {
            "location": "/reference/math/#sign", 
            "text": "sign(x)  The sign of  x .  Arguments   x : number.   Returns  Returns 1 if  x  is positive or zero; or -1 if  x  is negative.", 
            "title": "sign"
        }, 
        {
            "location": "/reference/math/#abs", 
            "text": "abs(x)  Absolute value of  x .  Arguments   x : number.   Returns  Returns  -x  if  x  is negative, or  x  otherwise.", 
            "title": "abs"
        }, 
        {
            "location": "/reference/math/#min", 
            "text": "min(x, y)  The minimum of two values.  Arguments   x : number.  y : number.   Returns  Returns the smallest of two values:  x  and  y .", 
            "title": "min"
        }, 
        {
            "location": "/reference/math/#max", 
            "text": "max(x, y)  The maximum of two values.  Arguments   x : number.  y : number.   Returns  Returns the largest of two values:  x  and  y .", 
            "title": "max"
        }, 
        {
            "location": "/reference/math/#clamp", 
            "text": "clamp(val, min, max)  Clamps a value between a minimum and a maximum.  Arguments   val : number. The value to be clamped.  min : number. Minimum value.  max : number. Maximum value.   Returns  Returns  val  clamped between  min  and  max . Function  clamp  behave as follows:   if  val     min , it returns  min  if  val     max , it returns  max  otherwise, it returns  val", 
            "title": "clamp"
        }, 
        {
            "location": "/reference/math/#approximately", 
            "text": "approximately(x, y)  Compares two floating point values. Since comparing two floating point numbers for equality directly may result in inaccuracies, this is a handy function.  Arguments   x : number.  y : number.   Returns  Returns  true  if  x  and  y  are  \"approximately\"  equal (they are within a small distance of  epsilon  of each other).", 
            "title": "approximately"
        }, 
        {
            "location": "/reference/math/#lerp", 
            "text": "lerp(a, b, t)  Linear interpolation.  Arguments   a : number.  b : number.  t : number. A value between 0 and 1.   Returns  Returns the linear interpolation between  a  and  b  by  t .  Value  t  is clamped automatically to range  [0, 1] .  As an example, note that  lerp :   returns  a  if  t  is  0  returns  b  if  t  is  1  returns  (a + b) / 2  if  t  is  0.5", 
            "title": "lerp"
        }, 
        {
            "location": "/reference/math/#smoothstep", 
            "text": "smoothstep(a, b, t)  Interpolation smoothing at the limits.  Arguments   a : number.  b : number.  t : number. A value between 0 and 1.   Returns  Returns an interpolated value between  a  and  b  by  t , in a similar way to  lerp . Unlike the linear  lerp ,  smoothstep  is smooth at the limits. This is useful to create smooth transitions and animations.  Value  t  is clamped automatically to range  [0, 1] .", 
            "title": "smoothstep"
        }, 
        {
            "location": "/reference/number/", 
            "text": "Number\n\n\nRoutines for numbers. The Number object is not supposed to be used directly. The functions below are available for primitive values of the number type.\n\n\nExample:\n\n\nx = 2.toString(); // x is \n2\n\nt = typeof(x); // t is \nstring\n\n\n\n\n\nNote:\n the SurgeScript Runtime stores numbers as 64-bit floating point values (following the IEEE 754 standard). Integer numbers are accurate up to 15 digits.\n\n\nFunctions\n\n\nvalueOf\n\n\nvalueOf()\n\n\nThe primitive value of the number, i.e., the number itself.\n\n\nReturns\n\n\nThe number.\n\n\ntoString\n\n\ntoString()\n\n\nConverts the number to a string.\n\n\nReturns\n\n\nThe number converted to a string.\n\n\nequals\n\n\nequals(x)\n\n\nCompares the number to another number \nx\n. Since this routine performs a comparison between floating point numbers, it's recommended to use \nMath.approximately()\n instead.\n\n\nArguments\n\n\n\n\nx\n: number. The value to compare the number to.\n\n\n\n\nReturns\n\n\nReturns \ntrue\n if the numbers are equal.\n\n\nisFinite\n\n\nisFinite()\n\n\nChecks if the number is finite.\n\n\nAvailable since:\n SurgeScript 0.5.2\n\n\nReturns\n\n\nReturns \ntrue\n if the number is finite.\n\n\nisNaN\n\n\nisNaN()\n\n\nChecks if the value is NaN (Not-a-Number).\n\n\nAvailable since:\n SurgeScript 0.5.2\n\n\nReturns\n\n\nReturns \ntrue\n if the value is NaN.\n\n\nisInteger\n\n\nisInteger()\n\n\nChecks if the number is an integer.\n\n\nAvailable since:\n SurgeScript 0.5.2\n\n\nReturns\n\n\nReturns \ntrue\n if the number is an integer.", 
            "title": "Number"
        }, 
        {
            "location": "/reference/number/#number", 
            "text": "Routines for numbers. The Number object is not supposed to be used directly. The functions below are available for primitive values of the number type.  Example:  x = 2.toString(); // x is  2 \nt = typeof(x); // t is  string   Note:  the SurgeScript Runtime stores numbers as 64-bit floating point values (following the IEEE 754 standard). Integer numbers are accurate up to 15 digits.", 
            "title": "Number"
        }, 
        {
            "location": "/reference/number/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/reference/number/#valueof", 
            "text": "valueOf()  The primitive value of the number, i.e., the number itself.  Returns  The number.", 
            "title": "valueOf"
        }, 
        {
            "location": "/reference/number/#tostring", 
            "text": "toString()  Converts the number to a string.  Returns  The number converted to a string.", 
            "title": "toString"
        }, 
        {
            "location": "/reference/number/#equals", 
            "text": "equals(x)  Compares the number to another number  x . Since this routine performs a comparison between floating point numbers, it's recommended to use  Math.approximately()  instead.  Arguments   x : number. The value to compare the number to.   Returns  Returns  true  if the numbers are equal.", 
            "title": "equals"
        }, 
        {
            "location": "/reference/number/#isfinite", 
            "text": "isFinite()  Checks if the number is finite.  Available since:  SurgeScript 0.5.2  Returns  Returns  true  if the number is finite.", 
            "title": "isFinite"
        }, 
        {
            "location": "/reference/number/#isnan", 
            "text": "isNaN()  Checks if the value is NaN (Not-a-Number).  Available since:  SurgeScript 0.5.2  Returns  Returns  true  if the value is NaN.", 
            "title": "isNaN"
        }, 
        {
            "location": "/reference/number/#isinteger", 
            "text": "isInteger()  Checks if the number is an integer.  Available since:  SurgeScript 0.5.2  Returns  Returns  true  if the number is an integer.", 
            "title": "isInteger"
        }, 
        {
            "location": "/reference/object/", 
            "text": "Object\n\n\nIn SurgeScript, all objects are also instances of \nObject\n. This means that the properties and functions listed below are available for all objects:\n\n\nProperties\n\n\nparent\n\n\nparent\n: object, read-only.\n\n\nReference to the parent object.\n\n\nchildCount\n\n\nchildCount\n: number, read-only.\n\n\nThe number of children of the object.\n\n\n__name\n\n\n__name\n: string, read-only.\n\n\nThe name of the object.\n\n\n__active\n\n\n__active\n: boolean.\n\n\nIndicates whether the object is active or not.\n\n\nObjects are active by default. Whenever an object is set to be inactive, its state machine is paused. Additionally, the state machines of all its descendants are also paused.\n\n\n__functions\n\n\n__functions\n: \nArray\n object, read-only.\n\n\nThe functions of this object represented as a collection of strings.\n\n\n__timespent\n\n\n__timespent\n: number, read-only.\n\n\nThe approximate time spent in this object in the last frame (in seconds).\n\n\n__file\n\n\n__file\n: string, read-only.\n\n\nThe source file of this object.\n\n\nAvailable since:\n SurgeScript 0.5.3\n\n\nFunctions\n\n\nspawn\n\n\nspawn(objectName)\n\n\nSpawns an object named \nobjectName\n.\n\n\nArguments\n\n\n\n\nobjectName\n: string. The name of the object to be spawned / instantiated.\n\n\n\n\nReturns\n\n\nA new object of the desired name. Note that the newly created object will be a child of \nthis\n.\n\n\ndestroy\n\n\ndestroy()\n\n\nDestroys the object.\n\n\nchild\n\n\nchild(childName | childId)\n\n\nLooks for a child named \nchildName\n (or matching \nchildId\n).\n\n\nArguments\n\n\n\n\nchildName\n: string. The name of the desired child.\n\n\nchildId\n: number. The id of the desired child, an integer between \n0\n and \nchildCount - 1\n, inclusive.\n\n\n\n\nReturns\n\n\nThe desired child\n, or\nnull` if there is no such object.\n\n\nsibling\n\n\nsibling(siblingName)\n\n\nLooks for a sibling named \nsiblingName\n. Two objects are siblings if they share the same parent.\n\n\nArguments\n\n\n\n\nsiblingName\n: string. The name of the desired sibling.\n\n\n\n\nReturns\n\n\nA sibling of name \nsiblingName\n, or \nnull\n if there is no such object.\n\n\nfindObject\n\n\nfindObject(objectName)\n\n\nSearches for a descendant (child, grand-child, and so on) named \nobjectName\n. Since this function traverses the \nobject tree\n, it's recommended to cache its return value. Do not use it in loops or states, as it might be slow.\n\n\nArguments\n\n\n\n\nobjectName\n: string. The name of the desired object.\n\n\n\n\nReturns\n\n\nA descendant named \nobjectName\n, or \nnull\n if there is no such object.\n\n\nExample\n\n\nobject \nTestObject\n\n{\n    // will search for SomeOtherObject in the Application\n    obj = Application.findObject(\nSomeOtherObject\n);\n\n    state \nmain\n\n    {\n        if(obj != null)\n            Console.print(\nFound the object.\n);\n        else\n            Console.print(\nObject not found.\n);\n\n        destroy();\n    }\n}\n\n\n\n\ntoString\n\n\ntoString()\n\n\nConverts the object to a string. This function is designed to be overloaded by your own objects.\n\n\nReturns\n\n\nA string.\n\n\nequals\n\n\nequals(otherObject)\n\n\nCompares \nthis\n object to \notherObject\n. This function is designed to be overloaded by your own objects.\n\n\nArguments\n\n\n\n\notherObject\n: object. An object to compare \nthis\n to.\n\n\n\n\nReturns\n\n\nReturns \ntrue\n if the objects are equal; \nfalse\n otherwise.\n\n\nhasFunction\n\n\nhasFunction(functionName)\n\n\nChecks if the object has a function named \nfunctionName\n.\n\n\nArguments\n\n\n\n\nfunctionName\n: string. The name of the function.\n\n\n\n\nReturns\n\n\nReturns \ntrue\n if the object has a function named \nfunctionName\n.\n\n\nhasTag\n\n\nhasTag(tagName)\n\n\nChecks if the object has been tagged with \ntagName\n.\n\n\nArguments\n\n\n\n\ntagName\n: string. The name of the tag.\n\n\n\n\nReturns\n\n\nReturns \ntrue\n if the object has been tagged with \ntagName\n.\n\n\n__invoke\n\n\n__invoke(functionName, paramsArray)\n\n\nInvokes function \nfunctionName\n, passing the parameters specified in \nparamsArray\n. Please note that the number of elements of \nparamsArray\n must be the same as the number of parameters required by the function to be invoked.\n\n\nAvailable since:\n SurgeScript 0.5.2\n\n\nArguments\n\n\n\n\nfunctionName\n: string. The name of the function to be called.\n\n\nparamsArray\n: \nArray\n. The parameters to be passed to the function.\n\n\n\n\nReturns\n\n\nReturns the value returned by the invoked function.\n\n\nExample\n\n\n// The program below will print:\n// 12\n// 12\n// true\n\nobject \nApplication\n\n{\n    state \nmain\n\n    {\n        Console.print(this.sum(5, 7));\n        Console.print(this.__invoke(\nsum\n, [5, 7]));\n        Console.print(sum(5, 7) == __invoke(\nsum\n, [5, 7]));\n        Application.exit();\n    }\n\n    fun sum(a, b)\n    {\n        return a + b;\n    }\n}", 
            "title": "Object"
        }, 
        {
            "location": "/reference/object/#object", 
            "text": "In SurgeScript, all objects are also instances of  Object . This means that the properties and functions listed below are available for all objects:", 
            "title": "Object"
        }, 
        {
            "location": "/reference/object/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/reference/object/#parent", 
            "text": "parent : object, read-only.  Reference to the parent object.", 
            "title": "parent"
        }, 
        {
            "location": "/reference/object/#childcount", 
            "text": "childCount : number, read-only.  The number of children of the object.", 
            "title": "childCount"
        }, 
        {
            "location": "/reference/object/#__name", 
            "text": "__name : string, read-only.  The name of the object.", 
            "title": "__name"
        }, 
        {
            "location": "/reference/object/#__active", 
            "text": "__active : boolean.  Indicates whether the object is active or not.  Objects are active by default. Whenever an object is set to be inactive, its state machine is paused. Additionally, the state machines of all its descendants are also paused.", 
            "title": "__active"
        }, 
        {
            "location": "/reference/object/#__functions", 
            "text": "__functions :  Array  object, read-only.  The functions of this object represented as a collection of strings.", 
            "title": "__functions"
        }, 
        {
            "location": "/reference/object/#__timespent", 
            "text": "__timespent : number, read-only.  The approximate time spent in this object in the last frame (in seconds).", 
            "title": "__timespent"
        }, 
        {
            "location": "/reference/object/#__file", 
            "text": "__file : string, read-only.  The source file of this object.  Available since:  SurgeScript 0.5.3", 
            "title": "__file"
        }, 
        {
            "location": "/reference/object/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/reference/object/#spawn", 
            "text": "spawn(objectName)  Spawns an object named  objectName .  Arguments   objectName : string. The name of the object to be spawned / instantiated.   Returns  A new object of the desired name. Note that the newly created object will be a child of  this .", 
            "title": "spawn"
        }, 
        {
            "location": "/reference/object/#destroy", 
            "text": "destroy()  Destroys the object.", 
            "title": "destroy"
        }, 
        {
            "location": "/reference/object/#child", 
            "text": "child(childName | childId)  Looks for a child named  childName  (or matching  childId ).  Arguments   childName : string. The name of the desired child.  childId : number. The id of the desired child, an integer between  0  and  childCount - 1 , inclusive.   Returns  The desired child , or null` if there is no such object.", 
            "title": "child"
        }, 
        {
            "location": "/reference/object/#sibling", 
            "text": "sibling(siblingName)  Looks for a sibling named  siblingName . Two objects are siblings if they share the same parent.  Arguments   siblingName : string. The name of the desired sibling.   Returns  A sibling of name  siblingName , or  null  if there is no such object.", 
            "title": "sibling"
        }, 
        {
            "location": "/reference/object/#findobject", 
            "text": "findObject(objectName)  Searches for a descendant (child, grand-child, and so on) named  objectName . Since this function traverses the  object tree , it's recommended to cache its return value. Do not use it in loops or states, as it might be slow.  Arguments   objectName : string. The name of the desired object.   Returns  A descendant named  objectName , or  null  if there is no such object.  Example  object  TestObject \n{\n    // will search for SomeOtherObject in the Application\n    obj = Application.findObject( SomeOtherObject );\n\n    state  main \n    {\n        if(obj != null)\n            Console.print( Found the object. );\n        else\n            Console.print( Object not found. );\n\n        destroy();\n    }\n}", 
            "title": "findObject"
        }, 
        {
            "location": "/reference/object/#tostring", 
            "text": "toString()  Converts the object to a string. This function is designed to be overloaded by your own objects.  Returns  A string.", 
            "title": "toString"
        }, 
        {
            "location": "/reference/object/#equals", 
            "text": "equals(otherObject)  Compares  this  object to  otherObject . This function is designed to be overloaded by your own objects.  Arguments   otherObject : object. An object to compare  this  to.   Returns  Returns  true  if the objects are equal;  false  otherwise.", 
            "title": "equals"
        }, 
        {
            "location": "/reference/object/#hasfunction", 
            "text": "hasFunction(functionName)  Checks if the object has a function named  functionName .  Arguments   functionName : string. The name of the function.   Returns  Returns  true  if the object has a function named  functionName .", 
            "title": "hasFunction"
        }, 
        {
            "location": "/reference/object/#hastag", 
            "text": "hasTag(tagName)  Checks if the object has been tagged with  tagName .  Arguments   tagName : string. The name of the tag.   Returns  Returns  true  if the object has been tagged with  tagName .", 
            "title": "hasTag"
        }, 
        {
            "location": "/reference/object/#__invoke", 
            "text": "__invoke(functionName, paramsArray)  Invokes function  functionName , passing the parameters specified in  paramsArray . Please note that the number of elements of  paramsArray  must be the same as the number of parameters required by the function to be invoked.  Available since:  SurgeScript 0.5.2  Arguments   functionName : string. The name of the function to be called.  paramsArray :  Array . The parameters to be passed to the function.   Returns  Returns the value returned by the invoked function.  Example  // The program below will print:\n// 12\n// 12\n// true\n\nobject  Application \n{\n    state  main \n    {\n        Console.print(this.sum(5, 7));\n        Console.print(this.__invoke( sum , [5, 7]));\n        Console.print(sum(5, 7) == __invoke( sum , [5, 7]));\n        Application.exit();\n    }\n\n    fun sum(a, b)\n    {\n        return a + b;\n    }\n}", 
            "title": "__invoke"
        }, 
        {
            "location": "/reference/plugin/", 
            "text": "Plugin\n\n\nSurgeScript features a plugin system that allows you to extend the functionalities of the language. Plugins are objects that can be accessed anywhere in the code. They can be imported using a \nusing\n statement. Also, the plugin system can be accessed simply by typing \nPlugin\n.\n\n\nExample:\n\n\n// File: app.ss\n\n// Plugins are used to extend the language. You can\n// import them into your source file using the\n// \nusing\n statement:\nusing StringUtils;\n\n// An application that uses the imported plugin\nobject \nApplication\n\n{\n    str = \nalucard\n;\n\n    state \nmain\n\n    {\n        Console.print(\nReverse a string:\n);\n        Console.print(str);\n        Console.print(StringUtils.reverse(str));\n        Application.exit();\n    }\n}\n\n\n\n\n// File: string_utils.ss\n\n// Plugins are objects annotated with \n@Plugin\n.\n// They are spawned automatically and can be\n// accessed anywhere in the code.\n@Plugin\nobject \nStringUtils\n\n{\n    fun reverse(str)\n    {\n        buf = \n;\n        for(i = str.length - 1; i \n= 0; i--)\n            buf += str[i];\n        return buf;\n    }\n}\n\n\n\n\nAvailable since:\n SurgeScript 0.5.2\n\n\nProperties\n\n\ncount\n\n\ncount\n: number, read-only.\n\n\nThe number of plugins.\n\n\nFunctions\n\n\nspawn\n\n\nspawn(pluginName)\n\n\nSpawns object \npluginName\n as a plugin. This function is not to be used directly, as SurgeScript spawns the plugins automatically for you. SurgeScript recognizes an object as a plugin when you annotate it with \n@Plugin\n.\n\n\nArguments\n\n\n\n\npluginName\n: string. The name of the object to be spawned as a plugin. It's not recommended to include special characters in the plugin name.\n\n\n\n\nget\n\n\nget(pluginName)\n\n\nGets a reference to the plugin named \npluginName\n. The \n[ ]\n operator can be used instead of the \nget()\n function, as in \nPlugin[pluginName]\n.\n\n\nRather than using this function, it's recommended to import the desired plugin using the \nusing myPlugin;\n statement at the beginning of your code. Your plugin will be available as \nmyPlugin\n.\n\n\nArguments\n\n\n\n\npluginName\n: string. The name of the plugin.\n\n\n\n\nExample\n\n\nusing StringUtils;\n\n...\n\nb = (Plugin[\nStringUtils\n] === StringUtils); // b is true\nc = (Plugin.StringUtils === StringUtils); // c is true", 
            "title": "Plugin"
        }, 
        {
            "location": "/reference/plugin/#plugin", 
            "text": "SurgeScript features a plugin system that allows you to extend the functionalities of the language. Plugins are objects that can be accessed anywhere in the code. They can be imported using a  using  statement. Also, the plugin system can be accessed simply by typing  Plugin .  Example:  // File: app.ss\n\n// Plugins are used to extend the language. You can\n// import them into your source file using the\n//  using  statement:\nusing StringUtils;\n\n// An application that uses the imported plugin\nobject  Application \n{\n    str =  alucard ;\n\n    state  main \n    {\n        Console.print( Reverse a string: );\n        Console.print(str);\n        Console.print(StringUtils.reverse(str));\n        Application.exit();\n    }\n}  // File: string_utils.ss\n\n// Plugins are objects annotated with  @Plugin .\n// They are spawned automatically and can be\n// accessed anywhere in the code.\n@Plugin\nobject  StringUtils \n{\n    fun reverse(str)\n    {\n        buf =  ;\n        for(i = str.length - 1; i  = 0; i--)\n            buf += str[i];\n        return buf;\n    }\n}  Available since:  SurgeScript 0.5.2", 
            "title": "Plugin"
        }, 
        {
            "location": "/reference/plugin/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/reference/plugin/#count", 
            "text": "count : number, read-only.  The number of plugins.", 
            "title": "count"
        }, 
        {
            "location": "/reference/plugin/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/reference/plugin/#spawn", 
            "text": "spawn(pluginName)  Spawns object  pluginName  as a plugin. This function is not to be used directly, as SurgeScript spawns the plugins automatically for you. SurgeScript recognizes an object as a plugin when you annotate it with  @Plugin .  Arguments   pluginName : string. The name of the object to be spawned as a plugin. It's not recommended to include special characters in the plugin name.", 
            "title": "spawn"
        }, 
        {
            "location": "/reference/plugin/#get", 
            "text": "get(pluginName)  Gets a reference to the plugin named  pluginName . The  [ ]  operator can be used instead of the  get()  function, as in  Plugin[pluginName] .  Rather than using this function, it's recommended to import the desired plugin using the  using myPlugin;  statement at the beginning of your code. Your plugin will be available as  myPlugin .  Arguments   pluginName : string. The name of the plugin.   Example  using StringUtils;\n\n...\n\nb = (Plugin[ StringUtils ] === StringUtils); // b is true\nc = (Plugin.StringUtils === StringUtils); // c is true", 
            "title": "get"
        }, 
        {
            "location": "/reference/string/", 
            "text": "String\n\n\nRoutines for strings. The String object is not supposed to be used directly (generally speaking). The functions below are available for primitive values of the string type.\n\n\nExample:\n\n\n// Useful string routines\nx = \nSurgeScript\n.toLowerCase(); // \nsurgescript\n\ny = x.substr(0, 5); // \nsurge\n\nz = x[0]; // \ns\n (first character of x)\nn = y.length; // 5\n\n\n\n\nPlease note that strings in SurgeScript are immutable. Once a string is set, its individual characters cannot be changed. If you need to modify the content of a string, reassign the variable to a new string.\n\n\nProperties\n\n\nlength\n\n\nlength\n: number, read-only.\n\n\nThe length of the string.\n\n\nFunctions\n\n\nvalueOf\n\n\nvalueOf()\n\n\nThe primitive value of the string, i.e., the string itself.\n\n\nReturns\n\n\nThe string.\n\n\ntoString\n\n\ntoString()\n\n\nConvert to string.\n\n\nReturns\n\n\nThe string itself.\n\n\nequals\n\n\nequals(str)\n\n\nCompares the string to another string \nstr\n.\n\n\nArguments\n\n\n\n\nstr\n: string.\n\n\n\n\nReturns\n\n\nReturns \ntrue\n if the strings are equal.\n\n\nget\n\n\nget(i)\n\n\nGets the \ni\n-th character of the string. The \n[ ]\n operator can be used equivalently.\n\n\nArguments\n\n\n\n\ni\n: integer number. A value between 0 (inclusive) and the length of the string (exclusive).\n\n\n\n\nReturns\n\n\nThe \ni\n-th character of the string (0-based index).\n\n\nindexOf\n\n\nindexOf(str)\n\n\nFinds the position of the first occurrence of \nstr\n in the string.\n\n\nArguments\n\n\n\n\nstr\n: string. The string to be searched for.\n\n\n\n\nReturns\n\n\nThe position (0-based index) of the first occurrence of \nstr\n in the string, or \n-1\n if there is no such occurrence.\n\n\nExample\n\n\nname = \nSurgeScript\n;\na = name.indexOf(\nSurge\n); // a is 0\nb = name.indexOf(\nNeon\n); // b is -1\nc = name.indexOf(\ne\n); // c is 4\nd = name.indexOf(\nscript\n); // d is -1, as the search is case-sensitive\n\n\n\n\nsubstr\n\n\nsubstr(start, length)\n\n\nExtracts the substring starting at position \nstart\n with length \nlength\n.\n\n\nArguments\n\n\n\n\nstart\n: number. The start position.\n\n\nlength\n: number. The length of the substring.\n\n\n\n\nReturns\n\n\nThe substring with length \nlength\n starting at \nstart\n.\n\n\nExample\n\n\nname = \nSurgeScript\n;\nsurge = name.substr(0, 5); // \nSurge\n\nscript = name.substr(5, 6); // \nScript\n\ne = name.substr(4, 2); // \ne\n\nempty = name.substr(555, 1); // \n\n\n\n\n\nconcat\n\n\nconcat(str)\n\n\nConcatenates two strings. This is the same as using the \n+\n operator.\n\n\nArguments\n\n\n\n\nstr\n: string.\n\n\n\n\nReturns\n\n\nThe caller string concatenated with \nstr\n at the end.\n\n\nExample\n\n\nname = \nSurge\n.concat(\nScript\n); // SurgeScript\nname = \nSurge\n + \nScript\n; // SurgeScript\n\n\n\n\nreplace\n\n\nreplace(oldstr, newstr)\n\n\nReplaces all occurrences of \noldstr\n to \nnewstr\n in the caller string.\n\n\nArguments\n\n\n\n\noldstr\n: string. The substring to be replaced.\n\n\nnewstr\n: string. The substring that should appear in the result.\n\n\n\n\nReturns\n\n\nThe caller string having all its occurrences of \noldstr\n replaced to \nnewstr\n.\n\n\nExample\n\n\n// dst is \nGimacian, Neon and Charge\n\nsrc = \nSurge, Neon and Charge\n;\ndst = src.replace(\nSurge\n, \nGimacian\n);\n\n\n\n\ntoLowerCase\n\n\ntoLowerCase()\n\n\nConverts the string to lower case.\n\n\nReturns\n\n\nThe string converted to lower case.\n\n\ntoUpperCase\n\n\ntoUpperCase()\n\n\nConverts the string to upper case.\n\n\nReturns\n\n\nThe string converted to upper case.\n\n\nisNullOrEmpty\n\n\nisNullOrEmpty(value)\n\n\nThis method of the \nString\n object can be used directly. It checks if the given \nvalue\n is either \nnull\n or an empty string.\n\n\nAvailable since:\n SurgeScript 0.5.3\n\n\nArguments\n\n\n\n\nvalue\n: string | null. The value to be tested.\n\n\n\n\nReturns\n\n\nReturns \ntrue\n if \nvalue\n is either \nnull\n or an empty string.\n\n\nExample\n\n\nname = \nSurge\n;\n//name = \n;\n//name = null;\n\nif(!String.isNullOrEmpty(name))\n    Console.print(name);", 
            "title": "String"
        }, 
        {
            "location": "/reference/string/#string", 
            "text": "Routines for strings. The String object is not supposed to be used directly (generally speaking). The functions below are available for primitive values of the string type.  Example:  // Useful string routines\nx =  SurgeScript .toLowerCase(); //  surgescript \ny = x.substr(0, 5); //  surge \nz = x[0]; //  s  (first character of x)\nn = y.length; // 5  Please note that strings in SurgeScript are immutable. Once a string is set, its individual characters cannot be changed. If you need to modify the content of a string, reassign the variable to a new string.", 
            "title": "String"
        }, 
        {
            "location": "/reference/string/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/reference/string/#length", 
            "text": "length : number, read-only.  The length of the string.", 
            "title": "length"
        }, 
        {
            "location": "/reference/string/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/reference/string/#valueof", 
            "text": "valueOf()  The primitive value of the string, i.e., the string itself.  Returns  The string.", 
            "title": "valueOf"
        }, 
        {
            "location": "/reference/string/#tostring", 
            "text": "toString()  Convert to string.  Returns  The string itself.", 
            "title": "toString"
        }, 
        {
            "location": "/reference/string/#equals", 
            "text": "equals(str)  Compares the string to another string  str .  Arguments   str : string.   Returns  Returns  true  if the strings are equal.", 
            "title": "equals"
        }, 
        {
            "location": "/reference/string/#get", 
            "text": "get(i)  Gets the  i -th character of the string. The  [ ]  operator can be used equivalently.  Arguments   i : integer number. A value between 0 (inclusive) and the length of the string (exclusive).   Returns  The  i -th character of the string (0-based index).", 
            "title": "get"
        }, 
        {
            "location": "/reference/string/#indexof", 
            "text": "indexOf(str)  Finds the position of the first occurrence of  str  in the string.  Arguments   str : string. The string to be searched for.   Returns  The position (0-based index) of the first occurrence of  str  in the string, or  -1  if there is no such occurrence.  Example  name =  SurgeScript ;\na = name.indexOf( Surge ); // a is 0\nb = name.indexOf( Neon ); // b is -1\nc = name.indexOf( e ); // c is 4\nd = name.indexOf( script ); // d is -1, as the search is case-sensitive", 
            "title": "indexOf"
        }, 
        {
            "location": "/reference/string/#substr", 
            "text": "substr(start, length)  Extracts the substring starting at position  start  with length  length .  Arguments   start : number. The start position.  length : number. The length of the substring.   Returns  The substring with length  length  starting at  start .  Example  name =  SurgeScript ;\nsurge = name.substr(0, 5); //  Surge \nscript = name.substr(5, 6); //  Script \ne = name.substr(4, 2); //  e \nempty = name.substr(555, 1); //", 
            "title": "substr"
        }, 
        {
            "location": "/reference/string/#concat", 
            "text": "concat(str)  Concatenates two strings. This is the same as using the  +  operator.  Arguments   str : string.   Returns  The caller string concatenated with  str  at the end.  Example  name =  Surge .concat( Script ); // SurgeScript\nname =  Surge  +  Script ; // SurgeScript", 
            "title": "concat"
        }, 
        {
            "location": "/reference/string/#replace", 
            "text": "replace(oldstr, newstr)  Replaces all occurrences of  oldstr  to  newstr  in the caller string.  Arguments   oldstr : string. The substring to be replaced.  newstr : string. The substring that should appear in the result.   Returns  The caller string having all its occurrences of  oldstr  replaced to  newstr .  Example  // dst is  Gimacian, Neon and Charge \nsrc =  Surge, Neon and Charge ;\ndst = src.replace( Surge ,  Gimacian );", 
            "title": "replace"
        }, 
        {
            "location": "/reference/string/#tolowercase", 
            "text": "toLowerCase()  Converts the string to lower case.  Returns  The string converted to lower case.", 
            "title": "toLowerCase"
        }, 
        {
            "location": "/reference/string/#touppercase", 
            "text": "toUpperCase()  Converts the string to upper case.  Returns  The string converted to upper case.", 
            "title": "toUpperCase"
        }, 
        {
            "location": "/reference/string/#isnullorempty", 
            "text": "isNullOrEmpty(value)  This method of the  String  object can be used directly. It checks if the given  value  is either  null  or an empty string.  Available since:  SurgeScript 0.5.3  Arguments   value : string | null. The value to be tested.   Returns  Returns  true  if  value  is either  null  or an empty string.  Example  name =  Surge ;\n//name =  ;\n//name = null;\n\nif(!String.isNullOrEmpty(name))\n    Console.print(name);", 
            "title": "isNullOrEmpty"
        }, 
        {
            "location": "/reference/surgescript/", 
            "text": "SurgeScript\n\n\nData related to the scripting language itself. You can access this object simply by typing \nSurgeScript\n.\n\n\nExample:\n\n\n// Prints the version of the SurgeScript runtime\nobject \nApplication\n\n{\n    state \nmain\n\n    {\n        Console.print(SurgeScript.version);\n        Application.exit();\n    }\n}\n\n\n\n\nAvailable since:\n SurgeScript 0.5.2\n\n\nProperties\n\n\nversion\n\n\nversion\n: string, read-only.\n\n\nVersion number of the SurgeScript runtime.", 
            "title": "SurgeScript"
        }, 
        {
            "location": "/reference/surgescript/#surgescript", 
            "text": "Data related to the scripting language itself. You can access this object simply by typing  SurgeScript .  Example:  // Prints the version of the SurgeScript runtime\nobject  Application \n{\n    state  main \n    {\n        Console.print(SurgeScript.version);\n        Application.exit();\n    }\n}  Available since:  SurgeScript 0.5.2", 
            "title": "SurgeScript"
        }, 
        {
            "location": "/reference/surgescript/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/reference/surgescript/#version", 
            "text": "version : string, read-only.  Version number of the SurgeScript runtime.", 
            "title": "version"
        }, 
        {
            "location": "/reference/system/", 
            "text": "System\n\n\nThe root object. Used to gather data from the language and to access special objects. It can be accessed by typing \nSystem\n.\n\n\nProperties\n\n\ntags\n\n\ntags\n: \nTag System\n object, read-only.\n\n\nA reference to the Tag System.\n\n\ngc\n\n\ngc\n: \nGarbage Collector\n object, read-only.\n\n\nA reference to the Garbage Collector object.\n\n\nobjectCount\n\n\nobjectCount\n: number, read-only.\n\n\nThe total number of objects at this moment.\n\n\nFunctions\n\n\nexit\n\n\nexit()\n\n\nExits the Application.\n\n\ndestroy\n\n\ndestroy()\n\n\nThe same as \nexit()\n.", 
            "title": "System"
        }, 
        {
            "location": "/reference/system/#system", 
            "text": "The root object. Used to gather data from the language and to access special objects. It can be accessed by typing  System .", 
            "title": "System"
        }, 
        {
            "location": "/reference/system/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/reference/system/#tags", 
            "text": "tags :  Tag System  object, read-only.  A reference to the Tag System.", 
            "title": "tags"
        }, 
        {
            "location": "/reference/system/#gc", 
            "text": "gc :  Garbage Collector  object, read-only.  A reference to the Garbage Collector object.", 
            "title": "gc"
        }, 
        {
            "location": "/reference/system/#objectcount", 
            "text": "objectCount : number, read-only.  The total number of objects at this moment.", 
            "title": "objectCount"
        }, 
        {
            "location": "/reference/system/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/reference/system/#exit", 
            "text": "exit()  Exits the Application.", 
            "title": "exit"
        }, 
        {
            "location": "/reference/system/#destroy", 
            "text": "destroy()  The same as  exit() .", 
            "title": "destroy"
        }, 
        {
            "location": "/reference/tags/", 
            "text": "TagSystem\n\n\nUtility functions for dealing with object tags. This object is available at \nSystem.tags\n and shouldn't be instantiated directly.\n\n\nFunctions\n\n\nlist\n\n\nlist()\n\n\nLists all tags used in all objects.\n\n\nReturns\n\n\nThis function spawns a new Array object with all tags and returns it.\n\n\nselect\n\n\nselect(tagName)\n\n\nSelects all objects that are tagged with \ntagName\n.\n\n\nArguments\n\n\n\n\ntagName\n: string.\n\n\n\n\nReturns\n\n\nThis function returns a new Array with all the names of the objects tagged with \ntagName\n.", 
            "title": "TagSystem"
        }, 
        {
            "location": "/reference/tags/#tagsystem", 
            "text": "Utility functions for dealing with object tags. This object is available at  System.tags  and shouldn't be instantiated directly.", 
            "title": "TagSystem"
        }, 
        {
            "location": "/reference/tags/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/reference/tags/#list", 
            "text": "list()  Lists all tags used in all objects.  Returns  This function spawns a new Array object with all tags and returns it.", 
            "title": "list"
        }, 
        {
            "location": "/reference/tags/#select", 
            "text": "select(tagName)  Selects all objects that are tagged with  tagName .  Arguments   tagName : string.   Returns  This function returns a new Array with all the names of the objects tagged with  tagName .", 
            "title": "select"
        }, 
        {
            "location": "/reference/time/", 
            "text": "Time\n\n\nTime utilities. This object is available simply by typing \nTime\n.\n\n\nProperties\n\n\ntime\n\n\ntime\n: number, read-only.\n\n\nThe number of seconds since the application was started at the beginning of this frame.\n\n\ndelta\n\n\ndelta\n: number, read-only.\n\n\nThe time, in seconds, taken to complete the last frame of the application. Use this value to make your application behave consistently regardless of the frame rate.\n\n\ntickCount\n\n\ntickCount\n: number, read-only.\n\n\nThe number of seconds since the application was started at the moment this property is evaluated.\n\n\n\n\nNote:\n\n\nSince \nTime.tickCount\n may return different values during the same frame of your application, it's generally advisable to use \nTime.time\n instead.", 
            "title": "Time"
        }, 
        {
            "location": "/reference/time/#time", 
            "text": "Time utilities. This object is available simply by typing  Time .", 
            "title": "Time"
        }, 
        {
            "location": "/reference/time/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/reference/time/#time_1", 
            "text": "time : number, read-only.  The number of seconds since the application was started at the beginning of this frame.", 
            "title": "time"
        }, 
        {
            "location": "/reference/time/#delta", 
            "text": "delta : number, read-only.  The time, in seconds, taken to complete the last frame of the application. Use this value to make your application behave consistently regardless of the frame rate.", 
            "title": "delta"
        }, 
        {
            "location": "/reference/time/#tickcount", 
            "text": "tickCount : number, read-only.  The number of seconds since the application was started at the moment this property is evaluated.   Note:  Since  Time.tickCount  may return different values during the same frame of your application, it's generally advisable to use  Time.time  instead.", 
            "title": "tickCount"
        }, 
        {
            "location": "/engine/actor/", 
            "text": "Actor\n\n\nThe Actor component is used to associate a sprite to a target object. The target object is required to be an \nentity\n. It's recommended to use only one actor per entity.\n\n\nFactory\n\n\nActor\n\n\nActor(sprite)\n\n\nSpawns a new Actor component with the given sprite name.\n\n\nArguments\n\n\n\n\nsprite\n: string. The name of the sprite (defined in the \nsprites/\n folder).\n\n\n\n\nReturns\n\n\nAn Actor component.\n\n\nExample\n\n\nusing SurgeEngine.Actor;\n\nobject \nSurgeTest\n is \nentity\n\n{\n    // spawns an Actor with the SurgeTest sprite\n    actor = Actor(\nSurgeTest\n);\n\n    state \nmain\n\n    {\n    }\n}\n\n\n\n\nProperties\n\n\nanim\n\n\nanim\n: number.\n\n\nA shortcut to \nanimation.id\n: an integer corresponding to the animation number. Defaults to 0.\n\n\nanimation\n\n\nanimation\n: \nAnimation\n object, read-only.\n\n\nReference to the Animation object of the Actor.\n\n\nalpha\n\n\nalpha\n: number.\n\n\nOpacity value, ranging from zero (0% opaque) to one (100% opaque). Defaults to 1.0.\n\n\nentity\n\n\nentity\n: object, read-only.\n\n\nThe entity associated with this component.\n\n\noffset\n\n\noffset\n: \nVector2\n object.\n\n\nAn \n(x,y)\n offset relative to the parent object. Defaults to zero.\n\n\nhflip\n\n\nhflip\n: boolean.\n\n\nShould the actor be flipped horizontally? Defaults to \nfalse\n.\n\n\nvflip\n\n\nvflip\n: boolean.\n\n\nShould the actor be flipped vertically? Defaults to \nfalse\n.\n\n\nvisible\n\n\nvisible\n: boolean.\n\n\nShould the actor be rendered? Defaults to \ntrue\n.\n\n\nwidth\n\n\nwidth\n: number, read-only.\n\n\nThe width of the actor.\n\n\nheight\n\n\nheight\n: number, read-only.\n\n\nThe height of the actor.\n\n\nzindex\n\n\nzindex\n: number.\n\n\nObjects with greater zindex are rendered in front of others. Defaults to 0.5.", 
            "title": "Actor"
        }, 
        {
            "location": "/engine/actor/#actor", 
            "text": "The Actor component is used to associate a sprite to a target object. The target object is required to be an  entity . It's recommended to use only one actor per entity.", 
            "title": "Actor"
        }, 
        {
            "location": "/engine/actor/#factory", 
            "text": "", 
            "title": "Factory"
        }, 
        {
            "location": "/engine/actor/#actor_1", 
            "text": "Actor(sprite)  Spawns a new Actor component with the given sprite name.  Arguments   sprite : string. The name of the sprite (defined in the  sprites/  folder).   Returns  An Actor component.  Example  using SurgeEngine.Actor;\n\nobject  SurgeTest  is  entity \n{\n    // spawns an Actor with the SurgeTest sprite\n    actor = Actor( SurgeTest );\n\n    state  main \n    {\n    }\n}", 
            "title": "Actor"
        }, 
        {
            "location": "/engine/actor/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/engine/actor/#anim", 
            "text": "anim : number.  A shortcut to  animation.id : an integer corresponding to the animation number. Defaults to 0.", 
            "title": "anim"
        }, 
        {
            "location": "/engine/actor/#animation", 
            "text": "animation :  Animation  object, read-only.  Reference to the Animation object of the Actor.", 
            "title": "animation"
        }, 
        {
            "location": "/engine/actor/#alpha", 
            "text": "alpha : number.  Opacity value, ranging from zero (0% opaque) to one (100% opaque). Defaults to 1.0.", 
            "title": "alpha"
        }, 
        {
            "location": "/engine/actor/#entity", 
            "text": "entity : object, read-only.  The entity associated with this component.", 
            "title": "entity"
        }, 
        {
            "location": "/engine/actor/#offset", 
            "text": "offset :  Vector2  object.  An  (x,y)  offset relative to the parent object. Defaults to zero.", 
            "title": "offset"
        }, 
        {
            "location": "/engine/actor/#hflip", 
            "text": "hflip : boolean.  Should the actor be flipped horizontally? Defaults to  false .", 
            "title": "hflip"
        }, 
        {
            "location": "/engine/actor/#vflip", 
            "text": "vflip : boolean.  Should the actor be flipped vertically? Defaults to  false .", 
            "title": "vflip"
        }, 
        {
            "location": "/engine/actor/#visible", 
            "text": "visible : boolean.  Should the actor be rendered? Defaults to  true .", 
            "title": "visible"
        }, 
        {
            "location": "/engine/actor/#width", 
            "text": "width : number, read-only.  The width of the actor.", 
            "title": "width"
        }, 
        {
            "location": "/engine/actor/#height", 
            "text": "height : number, read-only.  The height of the actor.", 
            "title": "height"
        }, 
        {
            "location": "/engine/actor/#zindex", 
            "text": "zindex : number.  Objects with greater zindex are rendered in front of others. Defaults to 0.5.", 
            "title": "zindex"
        }, 
        {
            "location": "/engine/animation/", 
            "text": "Animation\n\n\nAnimation objects are used to gather data about specific animations. Although you can't spawn Animation objects directly, you can access them via other objects such as \nActor\n and \nPlayer\n.\n\n\nExample\n\n\nusing SurgeEngine.Actor;\n\nobject \nMyExplosion\n is \nentity\n, \ndisposable\n, \nprivate\n\n{\n    actor = Actor(\nMyExplosion\n);\n\n    state \nmain\n\n    {\n        if(actor.animation.finished)\n            destroy();\n    }\n}\n\n\n\n\nProperties\n\n\nid\n\n\nid\n: number.\n\n\nThe number of the current animation, defined in a .spr file.\n\n\nsprite\n\n\nsprite\n: string, read-only.\n\n\nThe name of the sprite, defined in a .spr file.\n\n\nfinished\n\n\nfinished\n: boolean, read-only.\n\n\nWill be true if the current animation has finished playing.\n\n\nhotspot\n\n\nhotspot\n: \nVector2\n object, read-only.\n\n\nThe position of the hot spot of the current animation.\n\n\nfps\n\n\nfps\n: number, read-only.\n\n\nFrames per second of the current animation.\n\n\nrepeats\n\n\nrepeats\n: boolean, read-only.\n\n\nDoes the current animation repeat itself?\n\n\nframe\n\n\nframe\n: number, read-only.\n\n\nThe current frame of the animation: an integer between \n0\n and \nframeCount - 1\n, inclusive.\n\n\nframeCount\n\n\nframeCount\n: number, read-only.\n\n\nThe number of frames of the current animation.\n\n\nspeedFactor\n\n\nspeedFactor\n: number.\n\n\nWhile the \nFPS\n rate controls the speed of the animation, the speed factor gives you an additional degree of control. This is a multiplier that defaults to 1.0, meaning that the animation will run using its normal speed. If it's set to 2.0, it will run using twice that speed. A value of 0.5 means half the speed, and so on.", 
            "title": "Animation"
        }, 
        {
            "location": "/engine/animation/#animation", 
            "text": "Animation objects are used to gather data about specific animations. Although you can't spawn Animation objects directly, you can access them via other objects such as  Actor  and  Player .  Example  using SurgeEngine.Actor;\n\nobject  MyExplosion  is  entity ,  disposable ,  private \n{\n    actor = Actor( MyExplosion );\n\n    state  main \n    {\n        if(actor.animation.finished)\n            destroy();\n    }\n}", 
            "title": "Animation"
        }, 
        {
            "location": "/engine/animation/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/engine/animation/#id", 
            "text": "id : number.  The number of the current animation, defined in a .spr file.", 
            "title": "id"
        }, 
        {
            "location": "/engine/animation/#sprite", 
            "text": "sprite : string, read-only.  The name of the sprite, defined in a .spr file.", 
            "title": "sprite"
        }, 
        {
            "location": "/engine/animation/#finished", 
            "text": "finished : boolean, read-only.  Will be true if the current animation has finished playing.", 
            "title": "finished"
        }, 
        {
            "location": "/engine/animation/#hotspot", 
            "text": "hotspot :  Vector2  object, read-only.  The position of the hot spot of the current animation.", 
            "title": "hotspot"
        }, 
        {
            "location": "/engine/animation/#fps", 
            "text": "fps : number, read-only.  Frames per second of the current animation.", 
            "title": "fps"
        }, 
        {
            "location": "/engine/animation/#repeats", 
            "text": "repeats : boolean, read-only.  Does the current animation repeat itself?", 
            "title": "repeats"
        }, 
        {
            "location": "/engine/animation/#frame", 
            "text": "frame : number, read-only.  The current frame of the animation: an integer between  0  and  frameCount - 1 , inclusive.", 
            "title": "frame"
        }, 
        {
            "location": "/engine/animation/#framecount", 
            "text": "frameCount : number, read-only.  The number of frames of the current animation.", 
            "title": "frameCount"
        }, 
        {
            "location": "/engine/animation/#speedfactor", 
            "text": "speedFactor : number.  While the  FPS  rate controls the speed of the animation, the speed factor gives you an additional degree of control. This is a multiplier that defaults to 1.0, meaning that the animation will run using its normal speed. If it's set to 2.0, it will run using twice that speed. A value of 0.5 means half the speed, and so on.", 
            "title": "speedFactor"
        }, 
        {
            "location": "/engine/music/", 
            "text": "Music\n\n\nThe Music object lets you play music. This is meant to handle background music; therefore, only one music can be played at a time.\n\n\nUnlike regular \nsounds\n, musics are streamed, (i.e., not loaded completely in memory). Given the longer nature of musics, this improves memory usage and helps with the loading times.\n\n\nExample\n\n\nusing SurgeEngine.Level;\n\n// Fades the music in a linear fashion ;)\nobject \nMyMusicFader\n\n{\n    public music = Level.music;\n    prevVolume = music.volume;\n    fadeTime = 1.0; // given in seconds\n\n    state \nmain\n\n    {\n    }\n\n    state \nfadeout\n\n    {\n        music.volume -= Time.delta / fadeTime;\n        if(music.volume \n= 0.0) {\n            music.pause();\n            music.volume = prevVolume;\n            state = \nmain\n;\n        }\n    }\n\n    // call fadeOut() to make the\n    // music fade smoothly\n    fun fadeOut(seconds)\n    {\n        if(state == \nmain\n)\n            prevVolume = music.volume;\n        fadeTime = seconds;\n        state = \nfadeout\n;\n    }\n}\n\n\n\n\nFactory\n\n\nMusic\n\n\nAudio.Music(path)\n\n\nCreates a Music object associated with a certain file.\n\n\nArguments\n\n\n\n\npath\n: string. The path of the music - usually a file in the \nmusics/\n folder.\n\n\n\n\nReturns\n\n\nA Music object.\n\n\nExample\n\n\nusing SurgeEngine.Audio.Music;\n\nobject \nMusicTest\n\n{\n    music = Music(\nmusics/options.ogg\n);\n\n    state \nmain\n\n    {\n        // loop music\n        if(!music.playing)\n            music.play();\n    }\n}\n\n\n\n\nProperties\n\n\nplaying\n\n\nplaying\n: boolean, read-only.\n\n\nWill be \ntrue\n if the music is playing.\n\n\nvolume\n\n\nvolume\n: number.\n\n\nThe volume of the music, a value between 0.0 and 1.0, inclusive (zero means silence).\n\n\nFunctions\n\n\nplay\n\n\nplay()\n\n\nPlays the music (once). To make it loop, play it whenever \nmusic.playing\n is \nfalse\n.\n\n\nstop\n\n\nstop()\n\n\nStops the music. Once the music is stopped, it can only be played again from the beginning.\n\n\npause\n\n\npause()\n\n\nPauses the music. A paused music can be resumed later with \nplay()\n.", 
            "title": "Music"
        }, 
        {
            "location": "/engine/music/#music", 
            "text": "The Music object lets you play music. This is meant to handle background music; therefore, only one music can be played at a time.  Unlike regular  sounds , musics are streamed, (i.e., not loaded completely in memory). Given the longer nature of musics, this improves memory usage and helps with the loading times.  Example  using SurgeEngine.Level;\n\n// Fades the music in a linear fashion ;)\nobject  MyMusicFader \n{\n    public music = Level.music;\n    prevVolume = music.volume;\n    fadeTime = 1.0; // given in seconds\n\n    state  main \n    {\n    }\n\n    state  fadeout \n    {\n        music.volume -= Time.delta / fadeTime;\n        if(music.volume  = 0.0) {\n            music.pause();\n            music.volume = prevVolume;\n            state =  main ;\n        }\n    }\n\n    // call fadeOut() to make the\n    // music fade smoothly\n    fun fadeOut(seconds)\n    {\n        if(state ==  main )\n            prevVolume = music.volume;\n        fadeTime = seconds;\n        state =  fadeout ;\n    }\n}", 
            "title": "Music"
        }, 
        {
            "location": "/engine/music/#factory", 
            "text": "", 
            "title": "Factory"
        }, 
        {
            "location": "/engine/music/#music_1", 
            "text": "Audio.Music(path)  Creates a Music object associated with a certain file.  Arguments   path : string. The path of the music - usually a file in the  musics/  folder.   Returns  A Music object.  Example  using SurgeEngine.Audio.Music;\n\nobject  MusicTest \n{\n    music = Music( musics/options.ogg );\n\n    state  main \n    {\n        // loop music\n        if(!music.playing)\n            music.play();\n    }\n}", 
            "title": "Music"
        }, 
        {
            "location": "/engine/music/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/engine/music/#playing", 
            "text": "playing : boolean, read-only.  Will be  true  if the music is playing.", 
            "title": "playing"
        }, 
        {
            "location": "/engine/music/#volume", 
            "text": "volume : number.  The volume of the music, a value between 0.0 and 1.0, inclusive (zero means silence).", 
            "title": "volume"
        }, 
        {
            "location": "/engine/music/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/engine/music/#play", 
            "text": "play()  Plays the music (once). To make it loop, play it whenever  music.playing  is  false .", 
            "title": "play"
        }, 
        {
            "location": "/engine/music/#stop", 
            "text": "stop()  Stops the music. Once the music is stopped, it can only be played again from the beginning.", 
            "title": "stop"
        }, 
        {
            "location": "/engine/music/#pause", 
            "text": "pause()  Pauses the music. A paused music can be resumed later with  play() .", 
            "title": "pause"
        }, 
        {
            "location": "/engine/sound/", 
            "text": "Sound\n\n\nThe Sound object lets you play samples, which are short sounds like: jump, brake, select, hit, etc. Sounds are loaded entirely in the memory; therefore, this object is meant to be used only with samples. If you need to play longer things like music, consider using \nMusic\n instead.\n\n\nExample\n\n\nusing SurgeEngine.Audio.Sound;\n\n// will play a sound every 5 seconds\nobject \nSoundTest\n\n{\n    sound = Sound(\nsamples/jump.wav\n);\n\n    state \nmain\n\n    {\n        sound.play();\n        state = \nwait\n;\n    }\n\n    state \nwait\n\n    {\n        if(timeout(5.0))\n            state = \nmain\n;\n    }\n}\n\n\n\n\nFactory\n\n\nSound\n\n\nAudio.Sound(path)\n\n\nCreates a Sound object associated with a certain file.\n\n\nArguments\n\n\n\n\npath\n: string. The path of the sound - usually a file in the \nsamples/\n folder.\n\n\n\n\nReturns\n\n\nA Sound object.\n\n\nProperties\n\n\nplaying\n\n\nplaying\n: boolean, read-only.\n\n\nWill be \ntrue\n if the sound is playing.\n\n\nvolume\n\n\nvolume\n: number.\n\n\nThe volume of the sound, a value between 0.0 and 1.0, inclusive (zero means silence).\n\n\nFunctions\n\n\nplay\n\n\nplay()\n\n\nPlays the sound.\n\n\nstop\n\n\nstop()\n\n\nStops the sound.", 
            "title": "Sound"
        }, 
        {
            "location": "/engine/sound/#sound", 
            "text": "The Sound object lets you play samples, which are short sounds like: jump, brake, select, hit, etc. Sounds are loaded entirely in the memory; therefore, this object is meant to be used only with samples. If you need to play longer things like music, consider using  Music  instead.  Example  using SurgeEngine.Audio.Sound;\n\n// will play a sound every 5 seconds\nobject  SoundTest \n{\n    sound = Sound( samples/jump.wav );\n\n    state  main \n    {\n        sound.play();\n        state =  wait ;\n    }\n\n    state  wait \n    {\n        if(timeout(5.0))\n            state =  main ;\n    }\n}", 
            "title": "Sound"
        }, 
        {
            "location": "/engine/sound/#factory", 
            "text": "", 
            "title": "Factory"
        }, 
        {
            "location": "/engine/sound/#sound_1", 
            "text": "Audio.Sound(path)  Creates a Sound object associated with a certain file.  Arguments   path : string. The path of the sound - usually a file in the  samples/  folder.   Returns  A Sound object.", 
            "title": "Sound"
        }, 
        {
            "location": "/engine/sound/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/engine/sound/#playing", 
            "text": "playing : boolean, read-only.  Will be  true  if the sound is playing.", 
            "title": "playing"
        }, 
        {
            "location": "/engine/sound/#volume", 
            "text": "volume : number.  The volume of the sound, a value between 0.0 and 1.0, inclusive (zero means silence).", 
            "title": "volume"
        }, 
        {
            "location": "/engine/sound/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/engine/sound/#play", 
            "text": "play()  Plays the sound.", 
            "title": "play"
        }, 
        {
            "location": "/engine/sound/#stop", 
            "text": "stop()  Stops the sound.", 
            "title": "stop"
        }, 
        {
            "location": "/engine/camera/", 
            "text": "Camera\n\n\nThe Camera object can be used to control what content (in world space) is rendered to the screen. The Camera is represented by a 2-dimensional point in world space that is mapped to the center of the screen.\n\n\n\n\nHUD elements\n\n\nObjects tagged as \n\"detached\"\n do not follow the camera. They are not in world space, but in screen space. This is useful for creating HUD elements.\n\n\n\n\nExample\n\n\n// Import the Camera object\nusing SurgeEngine.Camera;\n\n// Reading the Camera status\n// This app prints the position of the camera at every second\nobject \nApplication\n\n{\n    state \nmain\n\n    {\n        if(timeout(1))\n            state = \nprint\n;\n    }\n\n    state \nprint\n\n    {\n        Console.print(Camera.position);\n        state = \nmain\n;\n    }\n}\n\n\n\n\nProperties\n\n\nposition\n\n\nposition\n: \nVector2\n object.\n\n\nThe position of the camera in world space.", 
            "title": "Camera"
        }, 
        {
            "location": "/engine/camera/#camera", 
            "text": "The Camera object can be used to control what content (in world space) is rendered to the screen. The Camera is represented by a 2-dimensional point in world space that is mapped to the center of the screen.   HUD elements  Objects tagged as  \"detached\"  do not follow the camera. They are not in world space, but in screen space. This is useful for creating HUD elements.   Example  // Import the Camera object\nusing SurgeEngine.Camera;\n\n// Reading the Camera status\n// This app prints the position of the camera at every second\nobject  Application \n{\n    state  main \n    {\n        if(timeout(1))\n            state =  print ;\n    }\n\n    state  print \n    {\n        Console.print(Camera.position);\n        state =  main ;\n    }\n}", 
            "title": "Camera"
        }, 
        {
            "location": "/engine/camera/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/engine/camera/#position", 
            "text": "position :  Vector2  object.  The position of the camera in world space.", 
            "title": "position"
        }, 
        {
            "location": "/engine/collider/", 
            "text": "Collider\n\n\nA collider, or collision object, is used to detect collisions. There are different types of colliders, each with a different shape. They are usually centered on the hot spot of sprites, but that can be changed by altering their \nanchor\n.\n\n\nColliders must be spawned as children of \nentities\n. To detect collisions, you may implement function \nonCollision()\n on the entity (see the example below), or use the colliders directly. Additionally, a single entity may have multiple colliders attached to it. This allows users to work with more complex shapes than simple primitives.\n\n\nA collider is an abstract concept, and hence can't be spawned directly. Rather, you can spawn colliders of specific shapes, such as \nCollisionBox\n and \nCollisionBall\n. All Colliders share some functionalities (detailed in this page), but there are functionalities tied to specific shapes.\n\n\nExample\n\n\nusing SurgeEngine.Actor;\nusing SurgeEngine.Player;\nusing SurgeEngine.Collisions.CollisionBall;\n\nobject \nCollisionDoll\n is \nentity\n\n{\n    actor = Actor(\nCollisionDoll\n);\n    collider = CollisionBall(25); // ball with radius = 25px\n\n    // The player has a built-in collider\n    // Let's make it visible for debugging\n    state \nmain\n\n    {\n        player = Player.active;\n        player.collider.visible = true;\n        collider.visible = true;\n    }\n\n    // Detect collisions between a collider that is a child\n    // of this object and any other collider in the game\n    fun onCollision(otherCollider)\n    {\n        // A collision has occurred.\n        Console.print(\nCollided with something\n);\n\n        // Collided with a player?\n        if(otherCollider.entity.hasTag(\nplayer\n)) {\n            player = otherCollider.entity;\n            Console.print(\nTouched \n + player.name);\n        }\n    }\n}\n\n\n\n\nProperties\n\n\nentity\n\n\nentity\n: object, read-only.\n\n\nThe \nEntity\n associated with this collider.\n\n\nvisible\n\n\nvisible\n: boolean.\n\n\nUseful for debugging. The default value is \nfalse\n.\n\n\nFunctions\n\n\ncollidesWith\n\n\ncollidesWith(collider)\n\n\nChecks if this collider is colliding with some other collider.\n\n\nArguments\n\n\n\n\ncollider\n: \nCollider\n object. The other collider.\n\n\n\n\nReturns\n\n\nReturns \ntrue\n if there is a collision (the colliders overlap), or \nfalse\n otherwise.\n\n\ncontains\n\n\ncontains(x, y)\n\n\nChecks if the collider contains the point (\nx\n, \ny\n), given in world coordinates.\n\n\nArguments\n\n\n\n\nx\n: number. The x-coordinate of the point.\n\n\ny\n: number. The y-coordinate of the point.\n\n\n\n\nReturns\n\n\nReturns \ntrue\n if the point is inside the collider, or \nfalse\n otherwise.\n\n\nsetAnchor\n\n\nsetAnchor(x, y)\n\n\nDefines the anchor of the collider to be (\nx\n, \ny\n), where these values are (usually) numbers between 0.0 and 1.0. Imagine a bounding box of the collider. Point (0.5, 0.5) is the default, representing its center. Point (0.0, 0.0) is the top-left and (1,0, 1.0), the bottom-right. The anchor of the collider will be aligned to the hot spot of the sprite of the entity.\n\n\nArguments\n\n\n\n\nx\n: number. Usually a value between 0.0 and 1.0.\n\n\ny\n: number. Usually a value between 0.0 and 1.0.", 
            "title": "Collider"
        }, 
        {
            "location": "/engine/collider/#collider", 
            "text": "A collider, or collision object, is used to detect collisions. There are different types of colliders, each with a different shape. They are usually centered on the hot spot of sprites, but that can be changed by altering their  anchor .  Colliders must be spawned as children of  entities . To detect collisions, you may implement function  onCollision()  on the entity (see the example below), or use the colliders directly. Additionally, a single entity may have multiple colliders attached to it. This allows users to work with more complex shapes than simple primitives.  A collider is an abstract concept, and hence can't be spawned directly. Rather, you can spawn colliders of specific shapes, such as  CollisionBox  and  CollisionBall . All Colliders share some functionalities (detailed in this page), but there are functionalities tied to specific shapes.  Example  using SurgeEngine.Actor;\nusing SurgeEngine.Player;\nusing SurgeEngine.Collisions.CollisionBall;\n\nobject  CollisionDoll  is  entity \n{\n    actor = Actor( CollisionDoll );\n    collider = CollisionBall(25); // ball with radius = 25px\n\n    // The player has a built-in collider\n    // Let's make it visible for debugging\n    state  main \n    {\n        player = Player.active;\n        player.collider.visible = true;\n        collider.visible = true;\n    }\n\n    // Detect collisions between a collider that is a child\n    // of this object and any other collider in the game\n    fun onCollision(otherCollider)\n    {\n        // A collision has occurred.\n        Console.print( Collided with something );\n\n        // Collided with a player?\n        if(otherCollider.entity.hasTag( player )) {\n            player = otherCollider.entity;\n            Console.print( Touched   + player.name);\n        }\n    }\n}", 
            "title": "Collider"
        }, 
        {
            "location": "/engine/collider/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/engine/collider/#entity", 
            "text": "entity : object, read-only.  The  Entity  associated with this collider.", 
            "title": "entity"
        }, 
        {
            "location": "/engine/collider/#visible", 
            "text": "visible : boolean.  Useful for debugging. The default value is  false .", 
            "title": "visible"
        }, 
        {
            "location": "/engine/collider/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/engine/collider/#collideswith", 
            "text": "collidesWith(collider)  Checks if this collider is colliding with some other collider.  Arguments   collider :  Collider  object. The other collider.   Returns  Returns  true  if there is a collision (the colliders overlap), or  false  otherwise.", 
            "title": "collidesWith"
        }, 
        {
            "location": "/engine/collider/#contains", 
            "text": "contains(x, y)  Checks if the collider contains the point ( x ,  y ), given in world coordinates.  Arguments   x : number. The x-coordinate of the point.  y : number. The y-coordinate of the point.   Returns  Returns  true  if the point is inside the collider, or  false  otherwise.", 
            "title": "contains"
        }, 
        {
            "location": "/engine/collider/#setanchor", 
            "text": "setAnchor(x, y)  Defines the anchor of the collider to be ( x ,  y ), where these values are (usually) numbers between 0.0 and 1.0. Imagine a bounding box of the collider. Point (0.5, 0.5) is the default, representing its center. Point (0.0, 0.0) is the top-left and (1,0, 1.0), the bottom-right. The anchor of the collider will be aligned to the hot spot of the sprite of the entity.  Arguments   x : number. Usually a value between 0.0 and 1.0.  y : number. Usually a value between 0.0 and 1.0.", 
            "title": "setAnchor"
        }, 
        {
            "location": "/engine/collisionball/", 
            "text": "CollisionBall\n\n\nA CollisionBall is a special type of \nCollider\n that takes the shape of a ball. In 2D space, this is a circle with a specific radius. All functions and properties of \nCollider\n apply to this.\n\n\nExample\n\n\nusing SurgeEngine.Actor;\nusing SurgeEngine.Collisions.CollisionBall;\n\nobject \nCollisionDoll\n is \nentity\n\n{\n    actor = Actor(\nCollisionDoll\n);\n    collider = CollisionBall(25); // radius = 25px\n\n    state \nmain\n\n    {\n        collider.visible = true; // useful for debugging\n    }\n\n    fun onCollision(otherCollider)\n    {\n        Console.print(\nA collision has occurred.\n);\n    }\n}\n\n\n\n\nFactory\n\n\nCollisions.CollisionBall\n\n\nCollisions.CollisionBall(radius)\n\n\nSpawns a new CollisionBall with the specified radius, in pixels.\n\n\nArguments\n\n\n\n\nradius\n: number. The radius of the CollisionBall.\n\n\n\n\nReturns\n\n\nA new CollisionBall with the specified radius.\n\n\nProperties\n\n\ncenter\n\n\ncenter\n: \nVector2\n, read-only.\n\n\nThe center of the CollisionBall, in world space.\n\n\nradius\n\n\nradius\n: number.\n\n\nThe radius of the CollisionBall, in pixels.", 
            "title": "CollisionBall"
        }, 
        {
            "location": "/engine/collisionball/#collisionball", 
            "text": "A CollisionBall is a special type of  Collider  that takes the shape of a ball. In 2D space, this is a circle with a specific radius. All functions and properties of  Collider  apply to this.  Example  using SurgeEngine.Actor;\nusing SurgeEngine.Collisions.CollisionBall;\n\nobject  CollisionDoll  is  entity \n{\n    actor = Actor( CollisionDoll );\n    collider = CollisionBall(25); // radius = 25px\n\n    state  main \n    {\n        collider.visible = true; // useful for debugging\n    }\n\n    fun onCollision(otherCollider)\n    {\n        Console.print( A collision has occurred. );\n    }\n}", 
            "title": "CollisionBall"
        }, 
        {
            "location": "/engine/collisionball/#factory", 
            "text": "", 
            "title": "Factory"
        }, 
        {
            "location": "/engine/collisionball/#collisionscollisionball", 
            "text": "Collisions.CollisionBall(radius)  Spawns a new CollisionBall with the specified radius, in pixels.  Arguments   radius : number. The radius of the CollisionBall.   Returns  A new CollisionBall with the specified radius.", 
            "title": "Collisions.CollisionBall"
        }, 
        {
            "location": "/engine/collisionball/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/engine/collisionball/#center", 
            "text": "center :  Vector2 , read-only.  The center of the CollisionBall, in world space.", 
            "title": "center"
        }, 
        {
            "location": "/engine/collisionball/#radius", 
            "text": "radius : number.  The radius of the CollisionBall, in pixels.", 
            "title": "radius"
        }, 
        {
            "location": "/engine/collisionbox/", 
            "text": "CollisionBox\n\n\nA CollisionBox is a special type of \nCollider\n that takes the shape of a box. In 2D space, this is a rectangle with a specific width and height. All functions and properties of \nCollider\n apply to this.\n\n\nExample\n\n\nusing SurgeEngine.Actor;\nusing SurgeEngine.Collisions.CollisionBox;\n\nobject \nCollisionDoll\n is \nentity\n\n{\n    actor = Actor(\nCollisionDoll\n);\n    collider = CollisionBox(32, 64); // width = 32px, height = 64px\n\n    state \nmain\n\n    {\n        collider.visible = true; // useful for debugging\n    }\n\n    fun onCollision(otherCollider)\n    {\n        Console.print(\nA collision has occurred.\n);\n    }\n}\n\n\n\n\nFactory\n\n\nCollisions.CollisionBox\n\n\nCollisions.CollisionBox(width, height)\n\n\nSpawns a new CollisionBox with the specified dimensions, in pixels.\n\n\nArguments\n\n\n\n\nwidth\n: number. The width of the CollisionBox.\n\n\nheight\n: number. The height of the CollisionBox.\n\n\n\n\nReturns\n\n\nA new CollisionBox with the specified dimensions.\n\n\nProperties\n\n\ntop\n\n\ntop\n: number, read-only.\n\n\nThe y-coordinate of top border of the CollisionBox, in world space.\n\n\nright\n\n\nright\n: number, read-only.\n\n\nThe x-coordinate of right border of the CollisionBox, in world space.\n\n\nbottom\n\n\nbottom\n: number, read-only.\n\n\nThe y-coordinate of bottom border of the CollisionBox, in world space.\n\n\nleft\n\n\nleft\n: number, read-only.\n\n\nThe x-coordinate of left border of the CollisionBox, in world space.\n\n\nwidth\n\n\nwidth\n: number.\n\n\nThe width of the CollisionBox, in pixels.\n\n\nheight\n\n\nheight\n: number.\n\n\nThe height of the CollisionBox, in pixels.", 
            "title": "CollisionBox"
        }, 
        {
            "location": "/engine/collisionbox/#collisionbox", 
            "text": "A CollisionBox is a special type of  Collider  that takes the shape of a box. In 2D space, this is a rectangle with a specific width and height. All functions and properties of  Collider  apply to this.  Example  using SurgeEngine.Actor;\nusing SurgeEngine.Collisions.CollisionBox;\n\nobject  CollisionDoll  is  entity \n{\n    actor = Actor( CollisionDoll );\n    collider = CollisionBox(32, 64); // width = 32px, height = 64px\n\n    state  main \n    {\n        collider.visible = true; // useful for debugging\n    }\n\n    fun onCollision(otherCollider)\n    {\n        Console.print( A collision has occurred. );\n    }\n}", 
            "title": "CollisionBox"
        }, 
        {
            "location": "/engine/collisionbox/#factory", 
            "text": "", 
            "title": "Factory"
        }, 
        {
            "location": "/engine/collisionbox/#collisionscollisionbox", 
            "text": "Collisions.CollisionBox(width, height)  Spawns a new CollisionBox with the specified dimensions, in pixels.  Arguments   width : number. The width of the CollisionBox.  height : number. The height of the CollisionBox.   Returns  A new CollisionBox with the specified dimensions.", 
            "title": "Collisions.CollisionBox"
        }, 
        {
            "location": "/engine/collisionbox/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/engine/collisionbox/#top", 
            "text": "top : number, read-only.  The y-coordinate of top border of the CollisionBox, in world space.", 
            "title": "top"
        }, 
        {
            "location": "/engine/collisionbox/#right", 
            "text": "right : number, read-only.  The x-coordinate of right border of the CollisionBox, in world space.", 
            "title": "right"
        }, 
        {
            "location": "/engine/collisionbox/#bottom", 
            "text": "bottom : number, read-only.  The y-coordinate of bottom border of the CollisionBox, in world space.", 
            "title": "bottom"
        }, 
        {
            "location": "/engine/collisionbox/#left", 
            "text": "left : number, read-only.  The x-coordinate of left border of the CollisionBox, in world space.", 
            "title": "left"
        }, 
        {
            "location": "/engine/collisionbox/#width", 
            "text": "width : number.  The width of the CollisionBox, in pixels.", 
            "title": "width"
        }, 
        {
            "location": "/engine/collisionbox/#height", 
            "text": "height : number.  The height of the CollisionBox, in pixels.", 
            "title": "height"
        }, 
        {
            "location": "/engine/sensor/", 
            "text": "Sensor\n\n\nA Sensor is used to detect collisions with bricks (obstacle, cloud). Due to performance optimizations, passable bricks (or bricks that are too far off camera) can't be sensed.\n\n\nExample\n\n\nusing SurgeEngine.Actor;\nusing SurgeEngine.Collisions.Sensor;\n\nobject \nSensorToy\n is \nentity\n\n{\n    actor = Actor(\nSensorToy\n);\n    sensor = Sensor(10, -50, 1, 50);\n\n    state \nmain\n\n    {\n        if(sensor.status != 0)\n            Console.print(\nGot brick\n);\n    }\n\n    fun constructor()\n    {\n        sensor.visible = true;\n    }\n}\n\n\n\n\nFactory\n\n\nSensor\n\n\nCollisions.Sensor(x, y, width, height)\n\n\nSpawns a new Sensor with the specified dimensions and having its top-left corner located at position (\nx\n, \ny\n) relative to the parent object. A Sensor is either a vertical or a horizontal bar that is 1-pixel thin. Both \nwidth\n and \nheight\n must be positive integers, and at least one of them must be equal to 1.\n\n\nArguments\n\n\n\n\nx\n: number. The x-position of the top-left corner of the sensor, relative to the parent object.\n\n\ny\n: number. The y-position of the top-left corner of the sensor, relative to the parent object.\n\n\nwidth\n: number. The width of the sensor, in pixels. Must be a positive integer.\n\n\nheight\n: number. The height of the sensor, in pixels. Must be a positive integer.\n\n\n\n\nReturns\n\n\nA Sensor with the specified parameters.\n\n\nProperties\n\n\nvisible\n\n\nvisible\n: boolean.\n\n\nShould the sensor be rendered? Useful for debugging. Defaults to \nfalse\n.\n\n\nstatus\n\n\nstatus\n: number, read-only.\n\n\nThe type of the brick colliding with the sensor (0: no brick, 1: obstacle, 2: cloud). To detect if the sensor is colliding with something, check if its status is non-zero, i.e., \nsensor.status != 0\n.\n\n\nFunctions\n\n\nupdate\n\n\nupdate()\n\n\nThe sensor status is updated automatically once per frame. Use this function to update it manually. This is useful if you modify the position of the parent object and need the updated sensor status in the same frame (for example; you're working in a loop).", 
            "title": "Sensor"
        }, 
        {
            "location": "/engine/sensor/#sensor", 
            "text": "A Sensor is used to detect collisions with bricks (obstacle, cloud). Due to performance optimizations, passable bricks (or bricks that are too far off camera) can't be sensed.  Example  using SurgeEngine.Actor;\nusing SurgeEngine.Collisions.Sensor;\n\nobject  SensorToy  is  entity \n{\n    actor = Actor( SensorToy );\n    sensor = Sensor(10, -50, 1, 50);\n\n    state  main \n    {\n        if(sensor.status != 0)\n            Console.print( Got brick );\n    }\n\n    fun constructor()\n    {\n        sensor.visible = true;\n    }\n}", 
            "title": "Sensor"
        }, 
        {
            "location": "/engine/sensor/#factory", 
            "text": "", 
            "title": "Factory"
        }, 
        {
            "location": "/engine/sensor/#sensor_1", 
            "text": "Collisions.Sensor(x, y, width, height)  Spawns a new Sensor with the specified dimensions and having its top-left corner located at position ( x ,  y ) relative to the parent object. A Sensor is either a vertical or a horizontal bar that is 1-pixel thin. Both  width  and  height  must be positive integers, and at least one of them must be equal to 1.  Arguments   x : number. The x-position of the top-left corner of the sensor, relative to the parent object.  y : number. The y-position of the top-left corner of the sensor, relative to the parent object.  width : number. The width of the sensor, in pixels. Must be a positive integer.  height : number. The height of the sensor, in pixels. Must be a positive integer.   Returns  A Sensor with the specified parameters.", 
            "title": "Sensor"
        }, 
        {
            "location": "/engine/sensor/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/engine/sensor/#visible", 
            "text": "visible : boolean.  Should the sensor be rendered? Useful for debugging. Defaults to  false .", 
            "title": "visible"
        }, 
        {
            "location": "/engine/sensor/#status", 
            "text": "status : number, read-only.  The type of the brick colliding with the sensor (0: no brick, 1: obstacle, 2: cloud). To detect if the sensor is colliding with something, check if its status is non-zero, i.e.,  sensor.status != 0 .", 
            "title": "status"
        }, 
        {
            "location": "/engine/sensor/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/engine/sensor/#update", 
            "text": "update()  The sensor status is updated automatically once per frame. Use this function to update it manually. This is useful if you modify the position of the parent object and need the updated sensor status in the same frame (for example; you're working in a loop).", 
            "title": "update"
        }, 
        {
            "location": "/engine/entity/", 
            "text": "Entity\n\n\nEntity is not an object per-se. Rather, it's a class of objects. An entity is an object that is present in world space (for example: an item, a NPC, a baddie, and so on). Abstract objects or components are \nnot\n entities. \nIn Open Surge, all objects that are tagged \n\"entity\"\n are considered to be entities.\n\n\nEntites have special treatment in Open Surge. They are deactivated automatically if they get too far off camera. Behavior can be changed by adding different tags to your entities. Additionally, entities can have components associated to it, so they can be fully customized.\n\n\n\n\nTip\n\n\nDuring level design, entities may be placed in world space using the editor palette. The icon of the entity will be the first animation (animation 0) of the sprite that has the name of the entity.\n\n\n\n\nTags\n\n\nentity\n\n\nTells Open Surge that the object is an entity and should be treated as such.\n\n\n// In the example below, MyExplosion (entity) has an Actor component\n// that gives it a visible form (a sprite) in world space.\nusing SurgeEngine.Actor;\n\nobject \nMyExplosion\n is \nentity\n, \nprivate\n, \ndisposable\n\n{\n    actor = Actor(\nMyExplosion\n);\n\n    state \nmain\n\n    {\n        if(actor.animation.finished)\n            destroy();\n    }\n}\n\n\n\n\nawake\n\n\nTells Open Surge to \nnot\n disable the object if it gets too far off camera.\n\n\ndetached\n\n\nThe object will \nnot\n follow the camera - it will be rendered in screen space.\n\n\ndisposable\n\n\nWill destroy the object automatically if it gets too far off camera.\n\n\nprivate\n\n\nPrivate entities cannot be spawned via the level editor (they will be hidden).", 
            "title": "Entity"
        }, 
        {
            "location": "/engine/entity/#entity", 
            "text": "Entity is not an object per-se. Rather, it's a class of objects. An entity is an object that is present in world space (for example: an item, a NPC, a baddie, and so on). Abstract objects or components are  not  entities.  In Open Surge, all objects that are tagged  \"entity\"  are considered to be entities.  Entites have special treatment in Open Surge. They are deactivated automatically if they get too far off camera. Behavior can be changed by adding different tags to your entities. Additionally, entities can have components associated to it, so they can be fully customized.   Tip  During level design, entities may be placed in world space using the editor palette. The icon of the entity will be the first animation (animation 0) of the sprite that has the name of the entity.", 
            "title": "Entity"
        }, 
        {
            "location": "/engine/entity/#tags", 
            "text": "", 
            "title": "Tags"
        }, 
        {
            "location": "/engine/entity/#entity_1", 
            "text": "Tells Open Surge that the object is an entity and should be treated as such.  // In the example below, MyExplosion (entity) has an Actor component\n// that gives it a visible form (a sprite) in world space.\nusing SurgeEngine.Actor;\n\nobject  MyExplosion  is  entity ,  private ,  disposable \n{\n    actor = Actor( MyExplosion );\n\n    state  main \n    {\n        if(actor.animation.finished)\n            destroy();\n    }\n}", 
            "title": "entity"
        }, 
        {
            "location": "/engine/entity/#awake", 
            "text": "Tells Open Surge to  not  disable the object if it gets too far off camera.", 
            "title": "awake"
        }, 
        {
            "location": "/engine/entity/#detached", 
            "text": "The object will  not  follow the camera - it will be rendered in screen space.", 
            "title": "detached"
        }, 
        {
            "location": "/engine/entity/#disposable", 
            "text": "Will destroy the object automatically if it gets too far off camera.", 
            "title": "disposable"
        }, 
        {
            "location": "/engine/entity/#private", 
            "text": "Private entities cannot be spawned via the level editor (they will be hidden).", 
            "title": "private"
        }, 
        {
            "location": "/engine/input/", 
            "text": "Input\n\n\nThe Input component is used to read input from the user.\n\n\nFactory\n\n\nInput\n\n\nInput(inputMap | null)\n\n\nSpawns a new Input component with the given input map.\n\n\nArguments\n\n\n\n\ninputMap\n: string | null. The name of the input map. If set to \nnull\n, a default input map will be used.\n\n\n\n\nReturns\n\n\nAn Input component.\n\n\nExample\n\n\nusing SurgeEngine.Input;\n\nobject \nApplication\n\n{\n    input = Input(null);\n\n    state \nmain\n\n    {\n        if(input.buttonDown(\nright\n))\n            Console.print(\nUser is holding right\n);\n    }\n}\n\n\n\n\nFunctions\n\n\nbuttonDown\n\n\nbuttonDown(buttonName)\n\n\nChecks if a button of the input map is currently being held down.\n\n\nArguments\n\n\n\n\nbuttonName\n: string. One of the following: \n\"up\", \"down\", \"left\", \"right\", \"fire1\", \"fire2\", ..., \"fire8\"\n.\n\n\n\n\nReturns\n\n\nReturns \ntrue\n if the specified button is being held down.\n\n\nbuttonPressed\n\n\nbuttonPressed(buttonName)\n\n\nChecks if a button has just been pressed.\n\n\nArguments\n\n\n\n\nbuttonName\n: string. One of the following: \n\"up\", \"down\", \"left\", \"right\", \"fire1\", \"fire2\", ..., \"fire8\"\n.\n\n\n\n\nReturns\n\n\nReturns \ntrue\n if the specified button has just been pressed.\n\n\nbuttonReleased\n\n\nbuttonReleased(buttonName)\n\n\nChecks if a button has just been released.\n\n\nArguments\n\n\n\n\nbuttonName\n: string. One of the following: \n\"up\", \"down\", \"left\", \"right\", \"fire1\", \"fire2\", ..., \"fire8\"\n.\n\n\n\n\nReturns\n\n\nReturns \ntrue\n if the specified button has just been released.", 
            "title": "Input"
        }, 
        {
            "location": "/engine/input/#input", 
            "text": "The Input component is used to read input from the user.", 
            "title": "Input"
        }, 
        {
            "location": "/engine/input/#factory", 
            "text": "", 
            "title": "Factory"
        }, 
        {
            "location": "/engine/input/#input_1", 
            "text": "Input(inputMap | null)  Spawns a new Input component with the given input map.  Arguments   inputMap : string | null. The name of the input map. If set to  null , a default input map will be used.   Returns  An Input component.  Example  using SurgeEngine.Input;\n\nobject  Application \n{\n    input = Input(null);\n\n    state  main \n    {\n        if(input.buttonDown( right ))\n            Console.print( User is holding right );\n    }\n}", 
            "title": "Input"
        }, 
        {
            "location": "/engine/input/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/engine/input/#buttondown", 
            "text": "buttonDown(buttonName)  Checks if a button of the input map is currently being held down.  Arguments   buttonName : string. One of the following:  \"up\", \"down\", \"left\", \"right\", \"fire1\", \"fire2\", ..., \"fire8\" .   Returns  Returns  true  if the specified button is being held down.", 
            "title": "buttonDown"
        }, 
        {
            "location": "/engine/input/#buttonpressed", 
            "text": "buttonPressed(buttonName)  Checks if a button has just been pressed.  Arguments   buttonName : string. One of the following:  \"up\", \"down\", \"left\", \"right\", \"fire1\", \"fire2\", ..., \"fire8\" .   Returns  Returns  true  if the specified button has just been pressed.", 
            "title": "buttonPressed"
        }, 
        {
            "location": "/engine/input/#buttonreleased", 
            "text": "buttonReleased(buttonName)  Checks if a button has just been released.  Arguments   buttonName : string. One of the following:  \"up\", \"down\", \"left\", \"right\", \"fire1\", \"fire2\", ..., \"fire8\" .   Returns  Returns  true  if the specified button has just been released.", 
            "title": "buttonReleased"
        }, 
        {
            "location": "/engine/mouse/", 
            "text": "Mouse\n\n\nThe Mouse object is used to read input from the mouse.\n\n\nExample\n\n\n// This example shows how to use the Collectible\n// sprite as a mouse cursor. Since MyCursor is\n// tagged as \ndetached\n, it will be rendered in\n// screen space (not world space).\n\nusing SurgeEngine.Actor;\nusing SurgeEngine.Transform;\nusing SurgeEngine.Input.Mouse;\n\nobject \nMyCursor\n is \nentity\n, \ndetached\n\n{\n    actor = Actor(\nMyCursor\n);\n    transform = Transform();\n\n    state \nmain\n\n    {\n        transform.position = Mouse.position;\n        if(Mouse.buttonPressed(\nleft\n))\n            Console.print(\nleft click\n);\n    }\n\n    fun constructor()\n    {\n        actor.zindex = 1.0;\n    }\n}\n\n\n\n\nProperties\n\n\nposition\n\n\nposition\n: \nVector2\n object, read-only.\n\n\nThe position of the mouse cursor, in screen space.\n\n\nFunctions\n\n\nbuttonDown\n\n\nbuttonDown(buttonName)\n\n\nChecks if a mouse button is currently being held down.\n\n\nArguments\n\n\n\n\nbuttonName\n: string. One of the following: \n\"left\"\n, \n\"right\"\n, \n\"middle\"\n.\n\n\n\n\nReturns\n\n\nReturns \ntrue\n if the specified button is being held down.\n\n\nbuttonPressed\n\n\nbuttonPressed(buttonName)\n\n\nChecks if a mouse button has just been pressed.\n\n\nArguments\n\n\n\n\nbuttonName\n: string. One of the following: \n\"left\"\n, \n\"right\"\n, \n\"middle\"\n.\n\n\n\n\nReturns\n\n\nReturns \ntrue\n if the specified button has just been pressed (i.e., a click has just occurred).\n\n\nbuttonReleased\n\n\nbuttonReleased(buttonName)\n\n\nChecks if a mouse button has just been released.\n\n\nArguments\n\n\n\n\nbuttonName\n: string. One of the following: \n\"left\"\n, \n\"right\"\n, \n\"middle\"\n.\n\n\n\n\nReturns\n\n\nReturns \ntrue\n if the specified button has just been released.", 
            "title": "Mouse"
        }, 
        {
            "location": "/engine/mouse/#mouse", 
            "text": "The Mouse object is used to read input from the mouse.  Example  // This example shows how to use the Collectible\n// sprite as a mouse cursor. Since MyCursor is\n// tagged as  detached , it will be rendered in\n// screen space (not world space).\n\nusing SurgeEngine.Actor;\nusing SurgeEngine.Transform;\nusing SurgeEngine.Input.Mouse;\n\nobject  MyCursor  is  entity ,  detached \n{\n    actor = Actor( MyCursor );\n    transform = Transform();\n\n    state  main \n    {\n        transform.position = Mouse.position;\n        if(Mouse.buttonPressed( left ))\n            Console.print( left click );\n    }\n\n    fun constructor()\n    {\n        actor.zindex = 1.0;\n    }\n}", 
            "title": "Mouse"
        }, 
        {
            "location": "/engine/mouse/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/engine/mouse/#position", 
            "text": "position :  Vector2  object, read-only.  The position of the mouse cursor, in screen space.", 
            "title": "position"
        }, 
        {
            "location": "/engine/mouse/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/engine/mouse/#buttondown", 
            "text": "buttonDown(buttonName)  Checks if a mouse button is currently being held down.  Arguments   buttonName : string. One of the following:  \"left\" ,  \"right\" ,  \"middle\" .   Returns  Returns  true  if the specified button is being held down.", 
            "title": "buttonDown"
        }, 
        {
            "location": "/engine/mouse/#buttonpressed", 
            "text": "buttonPressed(buttonName)  Checks if a mouse button has just been pressed.  Arguments   buttonName : string. One of the following:  \"left\" ,  \"right\" ,  \"middle\" .   Returns  Returns  true  if the specified button has just been pressed (i.e., a click has just occurred).", 
            "title": "buttonPressed"
        }, 
        {
            "location": "/engine/mouse/#buttonreleased", 
            "text": "buttonReleased(buttonName)  Checks if a mouse button has just been released.  Arguments   buttonName : string. One of the following:  \"left\" ,  \"right\" ,  \"middle\" .   Returns  Returns  true  if the specified button has just been released.", 
            "title": "buttonReleased"
        }, 
        {
            "location": "/engine/level/", 
            "text": "Level\n\n\nLevel routines. A level is a scene in the game, represented by a .lev file in the \nlevels/\n folder.\n\n\nWhenever you spawn an object in SurgeScript, you should keep a reference to it, otherwise it will be automatically deleted by the \nGarbage Collector\n. Sometimes, you may want to spawn \nentities\n in your level, but keeping references to all of them may be inconvenient. If this is your case, you can \nspawn them as children of the Level object\n. It will keep references of the entities for you; therefore, they won't be garbage collected.\n\n\nExample\n\n\nusing SurgeEngine.Level;\nusing SurgeEngine.Player;\n\nobject \nApplication\n\n{\n    state \nmain\n\n    {\n        if(timeout(1))\n            state = \nexplode\n;\n    }\n\n    state \nexplode\n\n    {\n        Level.spawn(\nMyExplosion\n); // no need to keep references\n        state = \nmain\n;\n    }\n}\n\nobject \nMyExplosion\n is \nentity\n, \ndisposable\n, \nprivate\n\n{\n    actor = Actor(\nMyExplosion\n);\n\n    state \nmain\n\n    {\n        if(actor.animation.finished)\n            destroy()\n    }\n\n    fun constructor()\n    {\n        // set initial position\n        player = Player.active;\n        actor.transform.position = player.transform.position;\n    }\n}\n\n\n\n\nProperties\n\n\nname\n\n\nname\n: string, read-only.\n\n\nThe name of the level.\n\n\nExample\n\n\nusing SurgeEngine.Level;\n\n// Will display the name of the level\nobject \nApplication\n\n{\n    state \nmain\n\n    {\n        Console.print(Level.name);\n        state = \ndone\n;\n    }\n\n    state \ndone\n\n    {\n    }\n}\n\n\n\n\nact\n\n\nact\n: number, read-only.\n\n\nThe act number (1, 2, 3...) of the current level.\n\n\nfile\n\n\nfile\n: string, read-only.\n\n\nThe relative path of the .lev file of the current level.\n\n\nversion\n\n\nversion\n: string, read-only.\n\n\nThe version of the level, defined in the .lev file.\n\n\nauthor\n\n\nauthor\n: string, read-only.\n\n\nThe author of the level, defined in the .lev file.\n\n\nlicense\n\n\nlicense\n: string, read-only.\n\n\nThe license of the level, defined in the .lev file.\n\n\nmusic\n\n\nmusic\n: \nMusic\n object, read-only.\n\n\nThe music of the level.\n\n\nwaterlevel\n\n\nwaterlevel\n: number.\n\n\nThe y-coordinate, in world space, of the level water. Pixels not above this value are underwater.\n\n\ncleared\n\n\ncleared\n: boolean, read-only.\n\n\nChecks if the current level has been cleared by the player. If this is \ntrue\n, a \nlevel cleared\n animation should be played. Although the engine provides a default animation, you may use this property to design your own. See also: \nclear()\n.\n\n\nFunctions\n\n\nspawn\n\n\nspawn(objectName)\n\n\nSpawns an object as a child of Level. Such objects won't be garbage collected. Please note that the spawned object is required to be an \nentity\n.\n\n\nArguments\n\n\n\n\nobjectName\n: string. The name of the object to be spawned.\n\n\n\n\nReturns\n\n\nThe spawned object.\n\n\nrestart\n\n\nrestart()\n\n\nRestarts the current level.\n\n\nquit\n\n\nquit()\n\n\nPrompts the user to see if he/she wants to quit the current level.\n\n\nabort\n\n\nabort()\n\n\nQuits the current level/quest without prompting the user.\n\n\npause\n\n\npause()\n\n\nPauses the game.\n\n\nload\n\n\nload(filepath)\n\n\nLoads the specified level/quest.\n\n\n\n\n\n\nIf you pass the path to a level (a .lev file in the \nlevels/\n folder), the specified level will be loaded. The state of the current level (position of the \nentities\n and so on) will be lost.\n\n\n\n\n\n\nIf you pass the path to a quest (a .qst file in the \nquests/\n folder), the specified quest will be loaded and, when it's completed, the engine will redirect the user back to the level he/she was before. This might be useful for creating bonuses, configuration screens, and so on.\n\n\n\n\n\n\nArguments\n\n\n\n\nfilepath\n: string. Relative path of the level or quest to be loaded.\n\n\n\n\nExample\n\n\nusing SurgeEngine.Level;\n\nobject \nLevelLoader\n\n{\n    fun load(id)\n    {\n        if(id == \nbeach\n)\n            Level.load(\nlevels/my_beach_level.lev\n);\n        else if(id == \nforest\n)\n            Level.load(\nlevels/my_forest_level.lev\n);\n        else\n            Console.print(\nUnrecognized level: \n + id);\n    }\n}\n\n\n\n\nclear\n\n\nclear()\n\n\nClears the level without actually changing it. Once the level is cleared, a \nlevel cleared\n animation is played. See also: \ncleared\n.\n\n\nfinish\n\n\nfinish()\n\n\nLoads the next level in the current quest. This is the usual procedure after \nclearing the level\n.", 
            "title": "Level"
        }, 
        {
            "location": "/engine/level/#level", 
            "text": "Level routines. A level is a scene in the game, represented by a .lev file in the  levels/  folder.  Whenever you spawn an object in SurgeScript, you should keep a reference to it, otherwise it will be automatically deleted by the  Garbage Collector . Sometimes, you may want to spawn  entities  in your level, but keeping references to all of them may be inconvenient. If this is your case, you can  spawn them as children of the Level object . It will keep references of the entities for you; therefore, they won't be garbage collected.  Example  using SurgeEngine.Level;\nusing SurgeEngine.Player;\n\nobject  Application \n{\n    state  main \n    {\n        if(timeout(1))\n            state =  explode ;\n    }\n\n    state  explode \n    {\n        Level.spawn( MyExplosion ); // no need to keep references\n        state =  main ;\n    }\n}\n\nobject  MyExplosion  is  entity ,  disposable ,  private \n{\n    actor = Actor( MyExplosion );\n\n    state  main \n    {\n        if(actor.animation.finished)\n            destroy()\n    }\n\n    fun constructor()\n    {\n        // set initial position\n        player = Player.active;\n        actor.transform.position = player.transform.position;\n    }\n}", 
            "title": "Level"
        }, 
        {
            "location": "/engine/level/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/engine/level/#name", 
            "text": "name : string, read-only.  The name of the level.  Example  using SurgeEngine.Level;\n\n// Will display the name of the level\nobject  Application \n{\n    state  main \n    {\n        Console.print(Level.name);\n        state =  done ;\n    }\n\n    state  done \n    {\n    }\n}", 
            "title": "name"
        }, 
        {
            "location": "/engine/level/#act", 
            "text": "act : number, read-only.  The act number (1, 2, 3...) of the current level.", 
            "title": "act"
        }, 
        {
            "location": "/engine/level/#file", 
            "text": "file : string, read-only.  The relative path of the .lev file of the current level.", 
            "title": "file"
        }, 
        {
            "location": "/engine/level/#version", 
            "text": "version : string, read-only.  The version of the level, defined in the .lev file.", 
            "title": "version"
        }, 
        {
            "location": "/engine/level/#author", 
            "text": "author : string, read-only.  The author of the level, defined in the .lev file.", 
            "title": "author"
        }, 
        {
            "location": "/engine/level/#license", 
            "text": "license : string, read-only.  The license of the level, defined in the .lev file.", 
            "title": "license"
        }, 
        {
            "location": "/engine/level/#music", 
            "text": "music :  Music  object, read-only.  The music of the level.", 
            "title": "music"
        }, 
        {
            "location": "/engine/level/#waterlevel", 
            "text": "waterlevel : number.  The y-coordinate, in world space, of the level water. Pixels not above this value are underwater.", 
            "title": "waterlevel"
        }, 
        {
            "location": "/engine/level/#cleared", 
            "text": "cleared : boolean, read-only.  Checks if the current level has been cleared by the player. If this is  true , a  level cleared  animation should be played. Although the engine provides a default animation, you may use this property to design your own. See also:  clear() .", 
            "title": "cleared"
        }, 
        {
            "location": "/engine/level/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/engine/level/#spawn", 
            "text": "spawn(objectName)  Spawns an object as a child of Level. Such objects won't be garbage collected. Please note that the spawned object is required to be an  entity .  Arguments   objectName : string. The name of the object to be spawned.   Returns  The spawned object.", 
            "title": "spawn"
        }, 
        {
            "location": "/engine/level/#restart", 
            "text": "restart()  Restarts the current level.", 
            "title": "restart"
        }, 
        {
            "location": "/engine/level/#quit", 
            "text": "quit()  Prompts the user to see if he/she wants to quit the current level.", 
            "title": "quit"
        }, 
        {
            "location": "/engine/level/#abort", 
            "text": "abort()  Quits the current level/quest without prompting the user.", 
            "title": "abort"
        }, 
        {
            "location": "/engine/level/#pause", 
            "text": "pause()  Pauses the game.", 
            "title": "pause"
        }, 
        {
            "location": "/engine/level/#load", 
            "text": "load(filepath)  Loads the specified level/quest.    If you pass the path to a level (a .lev file in the  levels/  folder), the specified level will be loaded. The state of the current level (position of the  entities  and so on) will be lost.    If you pass the path to a quest (a .qst file in the  quests/  folder), the specified quest will be loaded and, when it's completed, the engine will redirect the user back to the level he/she was before. This might be useful for creating bonuses, configuration screens, and so on.    Arguments   filepath : string. Relative path of the level or quest to be loaded.   Example  using SurgeEngine.Level;\n\nobject  LevelLoader \n{\n    fun load(id)\n    {\n        if(id ==  beach )\n            Level.load( levels/my_beach_level.lev );\n        else if(id ==  forest )\n            Level.load( levels/my_forest_level.lev );\n        else\n            Console.print( Unrecognized level:   + id);\n    }\n}", 
            "title": "load"
        }, 
        {
            "location": "/engine/level/#clear", 
            "text": "clear()  Clears the level without actually changing it. Once the level is cleared, a  level cleared  animation is played. See also:  cleared .", 
            "title": "clear"
        }, 
        {
            "location": "/engine/level/#finish", 
            "text": "finish()  Loads the next level in the current quest. This is the usual procedure after  clearing the level .", 
            "title": "finish"
        }, 
        {
            "location": "/engine/player/", 
            "text": "Player\n\n\nThe Player object is used to control a specific player/character. Player objects are tagged \nplayer\n. That might be useful when dealing with collisions.\n\n\nFactory\n\n\nPlayer\n\n\nPlayer(playerName | playerId)\n\n\nGets the Player object associated with a certain character.\n\n\nArguments\n\n\n\n\nplayerName\n: string. The name of the character (defined in the \ncharacters/\n folder).\n\n\nplayerId\n: number. The ID of the character (as defined in the \n.lev\n file), an integer between \n0\n and \nPlayer.count - 1\n, inclusive.\n\n\n\n\nReturns\n\n\nA Player object.\n\n\nExample\n\n\nusing SurgeEngine.Player;\n\n// Gives Surge 1 collectible each second\n// Just place it in your level\nobject \nCollectibleGiver\n is \nentity\n, \nawake\n\n{\n    player = Player(\nSurge\n);\n\n    state \nmain\n\n    {\n        if(timeout(1))\n            state = \ngive collectible\n;\n    }\n\n    state \ngive collectible\n\n    {\n        player.collectibles = player.collectibles + 1;\n        state = \nmain\n;\n    }\n}\n\n\n\n\nPlayer.active\n\n\nPlayer.active\n\n\nThe active player, i.e., the one currently in focus.\n\n\nReturns\n\n\nA Player object.\n\n\nExample\n\n\nusing SurgeEngine.Player;\n\n// Tells the name of the active player\nobject \nWho am I\n\n{\n    state \nmain\n\n    {\n        Console.print(\nI am \n + Player.active.name);\n        destroy();\n    }\n}\n\n\n\n\nPlayer.count\n\n\nPlayer.count\n\n\nPlayer count.\n\n\nReturns\n\n\nThe number of players in the level.\n\n\nPlayer.initialLives\n\n\nPlayer.initialLives\n\n\nThe initial number of lives set by the engine.\n\n\nReturns\n\n\nThe initial number of lives.\n\n\nProperties\n\n\nname\n\n\nname\n: string, read-only.\n\n\nThe name of the character.\n\n\nactivity\n\n\nactivity\n: string, read-only.\n\n\nThe current state / activity of the player. One of the following: \n\"stopped\"\n, \n\"walking\"\n, \n\"running\"\n, \n\"jumping\"\n, \n\"springing\"\n, \n\"rolling\"\n, \n\"charging\"\n, \n\"pushing\"\n, \n\"gettinghit\"\n, \n\"dying\"\n, \n\"braking\"\n, \n\"balancing\"\n, \n\"drowning\"\n, \n\"breathing\"\n, \n\"ducking\"\n, \n\"lookingup\"\n, \n\"waiting\"\n, \n\"winning\"\n.\n\n\nusing SurgeEngine.Player;\n\n// Place this inside your level to see the\n// current activity of the active player\nobject \nActivityDebugger\n is \nawake\n, \nentity\n\n{\n    state \nmain\n\n    {\n        player = Player.active;\n        Console.print(player.activity);\n    }\n}\n\n\n\n\nanim\n\n\nanim\n: number.\n\n\nA shortcut to \nanimation.id\n: an integer corresponding to the animation number.\n\n\nanimation\n\n\nanimation\n: \nAnimation\n object, read-only.\n\n\nReference to the Animation object of the Player.\n\n\nattacking\n\n\nattacking\n: boolean, read-only.\n\n\nIs the player attacking? (jumping, rolling, and so on)\n\n\nmidair\n\n\nmidair\n: boolean, read-only.\n\n\nIs the player midair?\n\n\nsecondsToDrown\n\n\nsecondsToDrown\n: number, read-only.\n\n\nThe number of seconds to drown, if underwater.\n\n\ndirection\n\n\ndirection\n: number, read-only.\n\n\nDirection will be +1 if the player is facing right, -1 if facing left.\n\n\ntransform\n\n\ntransform\n: \nTransform\n object, read-only.\n\n\nThe transform of the Player.\n\n\ncollider\n\n\ncollider\n: \nCollider\n object, read-only.\n\n\nA collider associated with this Player.\n\n\nshield\n\n\nshield\n: string.\n\n\nOne of the following: \n\"none\"\n, \n\"shield\"\n, \n\"fire\"\n, \n\"thunder\"\n, \n\"water\"\n, \n\"acid\"\n, \n\"wind\"\n.\n\n\ninvincible\n\n\ninvincible\n: boolean.\n\n\nUsed to make the player invincible. Defaults to \nfalse\n.\n\n\nturbo\n\n\nturbo\n: boolean.\n\n\nTurbo mode (increases player speed). Defaults to \nfalse\n.\n\n\nfrozen\n\n\nfrozen\n: boolean.\n\n\nDisable/enable player movement. Defaults to \nfalse\n.\n\n\nunderwater\n\n\nunderwater\n: boolean.\n\n\nGet underwater / out of water. Defaults to \nfalse\n.\n\n\nlayer\n\n\nlayer\n: string.\n\n\nThe current layer of the player. One of the following: \n\"green\"\n, \n\"yellow\"\n, \n\"default\"\n. This property tells you which bricks will be sensed, depending on their layer.\n\n\nvisible\n\n\nvisible\n: boolean.\n\n\nShould the player sprite be rendered? Defaults to \ntrue\n.\n\n\ncollectibles\n\n\ncollectibles\n: number.\n\n\nThe number of collectibles, an integer shared between all player objects.\n\n\nlives\n\n\nlives\n: number.\n\n\nThe number of lives, an integer shared between all player objects.\n\n\nscore\n\n\nscore\n: number.\n\n\nThe score of the player, an integer value shared between all player objects.\n\n\ngsp\n\n\ngsp\n: number.\n\n\nGround speed, in pixels per second.\n\n\nxsp\n\n\nxsp\n: number.\n\n\nHorizontal speed, in pixels per second (useful while midair).\n\n\nysp\n\n\nysp\n: number.\n\n\nVertical speed, in pixels per second.\n\n\nangle\n\n\nangle\n: number.\n\n\nThe angle of the player, in degrees. The same as \ntransform.angle\n.\n\n\nwidth\n\n\nwidth\n: number, read-only.\n\n\nThe width of the player sprite, in pixels.\n\n\nheight\n\n\nheight\n: number, read-only.\n\n\nThe height of the player sprite, in pixels.\n\n\nFunctions\n\n\nbounce\n\n\nbounce(hazard | null)\n\n\nMakes the player bounce after smashing a hazard. The trajectory of the movement will be computed according to the position of the hazard. If no hazard is present, you may pass \nnull\n as the argument.\n\n\nArguments\n\n\n\n\nhazard\n: \nActor\n object. The hazard.\n\n\n\n\nExample\n\n\nusing SurgeEngine.Player;\nusing SurgeEngine.Actor;\nusing SurgeEngine.Collisions.CollisionBox;\n\nobject \nShieldBox\n is \nentity\n\n{\n    actor = Actor(\nShieldBox\n);\n    shieldCollider = CollisionBox(32,32);\n\n    state \nmain\n\n    {\n        player = Player.active;\n        if(player.attacking) {\n            if(player.collider.collidesWith(shieldCollider)) {\n                if(player.midair)\n                    player.bounce(actor);\n                player.shield = \nfire\n;\n                destroy();\n            }\n        }\n    }\n}\n\n\n\n\nbounceBack\n\n\nbounceBack(hazard)\n\n\nMakes the player bounce after smashing a hazard. If the player comes at the hazard from below, the player is thrown downwards. If not, the player is thrown upwards. The \nhazard\n parameter is mandatory.\n\n\nArguments\n\n\n\n\nhazard\n: \nActor\n object. The hazard.\n\n\n\n\nhit\n\n\nhit(hazard | null)\n\n\nMakes the player get hit. Call it whenever the player gets hit by a hazard. The hit movement will be calculated according to the position of the hazard. If no hazard is present, you may pass \nnull\n as the argument.\n\n\nArguments\n\n\n\n\nhazard\n: \nActor\n object. The hazard.\n\n\n\n\nkill\n\n\nkill()\n\n\nKills the player.\n\n\nbreathe\n\n\nbreathe()\n\n\nMakes the player breathe (underwater only).\n\n\nspringify\n\n\nspringify()\n\n\nActivates the \"springing\" activity.\n\n\nroll\n\n\nroll()\n\n\nMakes the player roll.\n\n\nfocus\n\n\nfocus()\n\n\nFocuses on the player. The focused player is controlled by the user. Only one player can have focus at any given time.\n\n\nhasFocus\n\n\nhasFocus()\n\n\nDoes the player have focus?\n\n\nReturns\n\n\nReturns \ntrue\n if the player has focus, \nfalse\n otherwise.", 
            "title": "Player"
        }, 
        {
            "location": "/engine/player/#player", 
            "text": "The Player object is used to control a specific player/character. Player objects are tagged  player . That might be useful when dealing with collisions.", 
            "title": "Player"
        }, 
        {
            "location": "/engine/player/#factory", 
            "text": "", 
            "title": "Factory"
        }, 
        {
            "location": "/engine/player/#player_1", 
            "text": "Player(playerName | playerId)  Gets the Player object associated with a certain character.  Arguments   playerName : string. The name of the character (defined in the  characters/  folder).  playerId : number. The ID of the character (as defined in the  .lev  file), an integer between  0  and  Player.count - 1 , inclusive.   Returns  A Player object.  Example  using SurgeEngine.Player;\n\n// Gives Surge 1 collectible each second\n// Just place it in your level\nobject  CollectibleGiver  is  entity ,  awake \n{\n    player = Player( Surge );\n\n    state  main \n    {\n        if(timeout(1))\n            state =  give collectible ;\n    }\n\n    state  give collectible \n    {\n        player.collectibles = player.collectibles + 1;\n        state =  main ;\n    }\n}", 
            "title": "Player"
        }, 
        {
            "location": "/engine/player/#playeractive", 
            "text": "Player.active  The active player, i.e., the one currently in focus.  Returns  A Player object.  Example  using SurgeEngine.Player;\n\n// Tells the name of the active player\nobject  Who am I \n{\n    state  main \n    {\n        Console.print( I am   + Player.active.name);\n        destroy();\n    }\n}", 
            "title": "Player.active"
        }, 
        {
            "location": "/engine/player/#playercount", 
            "text": "Player.count  Player count.  Returns  The number of players in the level.", 
            "title": "Player.count"
        }, 
        {
            "location": "/engine/player/#playerinitiallives", 
            "text": "Player.initialLives  The initial number of lives set by the engine.  Returns  The initial number of lives.", 
            "title": "Player.initialLives"
        }, 
        {
            "location": "/engine/player/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/engine/player/#name", 
            "text": "name : string, read-only.  The name of the character.", 
            "title": "name"
        }, 
        {
            "location": "/engine/player/#activity", 
            "text": "activity : string, read-only.  The current state / activity of the player. One of the following:  \"stopped\" ,  \"walking\" ,  \"running\" ,  \"jumping\" ,  \"springing\" ,  \"rolling\" ,  \"charging\" ,  \"pushing\" ,  \"gettinghit\" ,  \"dying\" ,  \"braking\" ,  \"balancing\" ,  \"drowning\" ,  \"breathing\" ,  \"ducking\" ,  \"lookingup\" ,  \"waiting\" ,  \"winning\" .  using SurgeEngine.Player;\n\n// Place this inside your level to see the\n// current activity of the active player\nobject  ActivityDebugger  is  awake ,  entity \n{\n    state  main \n    {\n        player = Player.active;\n        Console.print(player.activity);\n    }\n}", 
            "title": "activity"
        }, 
        {
            "location": "/engine/player/#anim", 
            "text": "anim : number.  A shortcut to  animation.id : an integer corresponding to the animation number.", 
            "title": "anim"
        }, 
        {
            "location": "/engine/player/#animation", 
            "text": "animation :  Animation  object, read-only.  Reference to the Animation object of the Player.", 
            "title": "animation"
        }, 
        {
            "location": "/engine/player/#attacking", 
            "text": "attacking : boolean, read-only.  Is the player attacking? (jumping, rolling, and so on)", 
            "title": "attacking"
        }, 
        {
            "location": "/engine/player/#midair", 
            "text": "midair : boolean, read-only.  Is the player midair?", 
            "title": "midair"
        }, 
        {
            "location": "/engine/player/#secondstodrown", 
            "text": "secondsToDrown : number, read-only.  The number of seconds to drown, if underwater.", 
            "title": "secondsToDrown"
        }, 
        {
            "location": "/engine/player/#direction", 
            "text": "direction : number, read-only.  Direction will be +1 if the player is facing right, -1 if facing left.", 
            "title": "direction"
        }, 
        {
            "location": "/engine/player/#transform", 
            "text": "transform :  Transform  object, read-only.  The transform of the Player.", 
            "title": "transform"
        }, 
        {
            "location": "/engine/player/#collider", 
            "text": "collider :  Collider  object, read-only.  A collider associated with this Player.", 
            "title": "collider"
        }, 
        {
            "location": "/engine/player/#shield", 
            "text": "shield : string.  One of the following:  \"none\" ,  \"shield\" ,  \"fire\" ,  \"thunder\" ,  \"water\" ,  \"acid\" ,  \"wind\" .", 
            "title": "shield"
        }, 
        {
            "location": "/engine/player/#invincible", 
            "text": "invincible : boolean.  Used to make the player invincible. Defaults to  false .", 
            "title": "invincible"
        }, 
        {
            "location": "/engine/player/#turbo", 
            "text": "turbo : boolean.  Turbo mode (increases player speed). Defaults to  false .", 
            "title": "turbo"
        }, 
        {
            "location": "/engine/player/#frozen", 
            "text": "frozen : boolean.  Disable/enable player movement. Defaults to  false .", 
            "title": "frozen"
        }, 
        {
            "location": "/engine/player/#underwater", 
            "text": "underwater : boolean.  Get underwater / out of water. Defaults to  false .", 
            "title": "underwater"
        }, 
        {
            "location": "/engine/player/#layer", 
            "text": "layer : string.  The current layer of the player. One of the following:  \"green\" ,  \"yellow\" ,  \"default\" . This property tells you which bricks will be sensed, depending on their layer.", 
            "title": "layer"
        }, 
        {
            "location": "/engine/player/#visible", 
            "text": "visible : boolean.  Should the player sprite be rendered? Defaults to  true .", 
            "title": "visible"
        }, 
        {
            "location": "/engine/player/#collectibles", 
            "text": "collectibles : number.  The number of collectibles, an integer shared between all player objects.", 
            "title": "collectibles"
        }, 
        {
            "location": "/engine/player/#lives", 
            "text": "lives : number.  The number of lives, an integer shared between all player objects.", 
            "title": "lives"
        }, 
        {
            "location": "/engine/player/#score", 
            "text": "score : number.  The score of the player, an integer value shared between all player objects.", 
            "title": "score"
        }, 
        {
            "location": "/engine/player/#gsp", 
            "text": "gsp : number.  Ground speed, in pixels per second.", 
            "title": "gsp"
        }, 
        {
            "location": "/engine/player/#xsp", 
            "text": "xsp : number.  Horizontal speed, in pixels per second (useful while midair).", 
            "title": "xsp"
        }, 
        {
            "location": "/engine/player/#ysp", 
            "text": "ysp : number.  Vertical speed, in pixels per second.", 
            "title": "ysp"
        }, 
        {
            "location": "/engine/player/#angle", 
            "text": "angle : number.  The angle of the player, in degrees. The same as  transform.angle .", 
            "title": "angle"
        }, 
        {
            "location": "/engine/player/#width", 
            "text": "width : number, read-only.  The width of the player sprite, in pixels.", 
            "title": "width"
        }, 
        {
            "location": "/engine/player/#height", 
            "text": "height : number, read-only.  The height of the player sprite, in pixels.", 
            "title": "height"
        }, 
        {
            "location": "/engine/player/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/engine/player/#bounce", 
            "text": "bounce(hazard | null)  Makes the player bounce after smashing a hazard. The trajectory of the movement will be computed according to the position of the hazard. If no hazard is present, you may pass  null  as the argument.  Arguments   hazard :  Actor  object. The hazard.   Example  using SurgeEngine.Player;\nusing SurgeEngine.Actor;\nusing SurgeEngine.Collisions.CollisionBox;\n\nobject  ShieldBox  is  entity \n{\n    actor = Actor( ShieldBox );\n    shieldCollider = CollisionBox(32,32);\n\n    state  main \n    {\n        player = Player.active;\n        if(player.attacking) {\n            if(player.collider.collidesWith(shieldCollider)) {\n                if(player.midair)\n                    player.bounce(actor);\n                player.shield =  fire ;\n                destroy();\n            }\n        }\n    }\n}", 
            "title": "bounce"
        }, 
        {
            "location": "/engine/player/#bounceback", 
            "text": "bounceBack(hazard)  Makes the player bounce after smashing a hazard. If the player comes at the hazard from below, the player is thrown downwards. If not, the player is thrown upwards. The  hazard  parameter is mandatory.  Arguments   hazard :  Actor  object. The hazard.", 
            "title": "bounceBack"
        }, 
        {
            "location": "/engine/player/#hit", 
            "text": "hit(hazard | null)  Makes the player get hit. Call it whenever the player gets hit by a hazard. The hit movement will be calculated according to the position of the hazard. If no hazard is present, you may pass  null  as the argument.  Arguments   hazard :  Actor  object. The hazard.", 
            "title": "hit"
        }, 
        {
            "location": "/engine/player/#kill", 
            "text": "kill()  Kills the player.", 
            "title": "kill"
        }, 
        {
            "location": "/engine/player/#breathe", 
            "text": "breathe()  Makes the player breathe (underwater only).", 
            "title": "breathe"
        }, 
        {
            "location": "/engine/player/#springify", 
            "text": "springify()  Activates the \"springing\" activity.", 
            "title": "springify"
        }, 
        {
            "location": "/engine/player/#roll", 
            "text": "roll()  Makes the player roll.", 
            "title": "roll"
        }, 
        {
            "location": "/engine/player/#focus", 
            "text": "focus()  Focuses on the player. The focused player is controlled by the user. Only one player can have focus at any given time.", 
            "title": "focus"
        }, 
        {
            "location": "/engine/player/#hasfocus", 
            "text": "hasFocus()  Does the player have focus?  Returns  Returns  true  if the player has focus,  false  otherwise.", 
            "title": "hasFocus"
        }, 
        {
            "location": "/engine/prefs/", 
            "text": "Prefs\n\n\nPrefs is a SurgeEngine component used to save/load data to/from the disk (permanent storage). Prefs is a (key, value) storage that works like a Dictionary, but its data can be persisted between game sessions.\n\n\nExample\n\n\nusing SurgeEngine.Prefs;\n\n// Run the Application multiple times and see\n// how the counter increments\nobject \nApplication\n\n{\n    state \nmain\n\n    {\n        Prefs[\ncounter\n] += 1;\n        Console.print(\ncounter: \n + Prefs[\ncounter\n]);\n    }\n\n    fun constructor()\n    {\n        if(!Prefs.has(\ncounter\n))\n            Prefs[\ncounter\n] = 0;\n    }\n}\n\n\n\n\nFunctions\n\n\nget\n\n\nget(key)\n\n\nGets the value of the specified key. Instead of calling \nget()\n directly, you may equivalently use the \n[ ]\n operator.\n\n\nArguments\n\n\n\n\nkey\n: string. The key must always be a string.\n\n\n\n\nReturns\n\n\nReturns the value associated with the specified key, or \nnull\n if there is no such value.\n\n\nset\n\n\nset(key, value)\n\n\nSets the value of the specified key. Instead of calling \nset()\n directly, you may equivalently use the \n[ ]\n operator.\n\n\nArguments\n\n\n\n\nkey\n: string. The key must always be a string.\n\n\nvalue\n: any type. The value you want to store.\n\n\n\n\nclear\n\n\nclear()\n\n\nRemoves all entries from Prefs. Use this very carefully, because data will be lost.\n\n\ndelete\n\n\ndelete(key)\n\n\nDeletes the entry having the specified key.\n\n\nArguments\n\n\n\n\nkey\n: string. The key of the entry to be removed.\n\n\n\n\nhas\n\n\nhas(key)\n\n\nChecks if a specific entry exists.\n\n\nArguments\n\n\n\n\nkey\n: string. The key of the entry.\n\n\n\n\nReturns\n\n\nReturns \ntrue\n if the specified entry exists, \nfalse\n otherwise.\n\n\nsave\n\n\nsave()\n\n\nWrites the data to secondary storage. The data isn't saved immediately after you set an entry, but it is saved on key moments. Since the data is persisted automatically, normally you don't need to call this.", 
            "title": "Prefs"
        }, 
        {
            "location": "/engine/prefs/#prefs", 
            "text": "Prefs is a SurgeEngine component used to save/load data to/from the disk (permanent storage). Prefs is a (key, value) storage that works like a Dictionary, but its data can be persisted between game sessions.  Example  using SurgeEngine.Prefs;\n\n// Run the Application multiple times and see\n// how the counter increments\nobject  Application \n{\n    state  main \n    {\n        Prefs[ counter ] += 1;\n        Console.print( counter:   + Prefs[ counter ]);\n    }\n\n    fun constructor()\n    {\n        if(!Prefs.has( counter ))\n            Prefs[ counter ] = 0;\n    }\n}", 
            "title": "Prefs"
        }, 
        {
            "location": "/engine/prefs/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/engine/prefs/#get", 
            "text": "get(key)  Gets the value of the specified key. Instead of calling  get()  directly, you may equivalently use the  [ ]  operator.  Arguments   key : string. The key must always be a string.   Returns  Returns the value associated with the specified key, or  null  if there is no such value.", 
            "title": "get"
        }, 
        {
            "location": "/engine/prefs/#set", 
            "text": "set(key, value)  Sets the value of the specified key. Instead of calling  set()  directly, you may equivalently use the  [ ]  operator.  Arguments   key : string. The key must always be a string.  value : any type. The value you want to store.", 
            "title": "set"
        }, 
        {
            "location": "/engine/prefs/#clear", 
            "text": "clear()  Removes all entries from Prefs. Use this very carefully, because data will be lost.", 
            "title": "clear"
        }, 
        {
            "location": "/engine/prefs/#delete", 
            "text": "delete(key)  Deletes the entry having the specified key.  Arguments   key : string. The key of the entry to be removed.", 
            "title": "delete"
        }, 
        {
            "location": "/engine/prefs/#has", 
            "text": "has(key)  Checks if a specific entry exists.  Arguments   key : string. The key of the entry.   Returns  Returns  true  if the specified entry exists,  false  otherwise.", 
            "title": "has"
        }, 
        {
            "location": "/engine/prefs/#save", 
            "text": "save()  Writes the data to secondary storage. The data isn't saved immediately after you set an entry, but it is saved on key moments. Since the data is persisted automatically, normally you don't need to call this.", 
            "title": "save"
        }, 
        {
            "location": "/engine/surgeengine/", 
            "text": "SurgeEngine\n\n\nThe SurgeEngine plugin is the interface between SurgeScript (scripting language) and Open Surge (game engine).\n\n\nExample\n\n\nusing SurgeEngine;\n\n// Open Surge version\nobject \nApplication\n\n{\n    state \nmain\n\n    {\n        Console.print(SurgeEngine.version);\n        state = \nblank\n;\n    }\n\n    state \nblank\n\n    {\n    }\n}\n\n\n\n\nProperties\n\n\nversion\n\n\nversion\n: string, read-only.\n\n\nOpen Surge version.", 
            "title": "SurgeEngine"
        }, 
        {
            "location": "/engine/surgeengine/#surgeengine", 
            "text": "The SurgeEngine plugin is the interface between SurgeScript (scripting language) and Open Surge (game engine).  Example  using SurgeEngine;\n\n// Open Surge version\nobject  Application \n{\n    state  main \n    {\n        Console.print(SurgeEngine.version);\n        state =  blank ;\n    }\n\n    state  blank \n    {\n    }\n}", 
            "title": "SurgeEngine"
        }, 
        {
            "location": "/engine/surgeengine/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/engine/surgeengine/#version", 
            "text": "version : string, read-only.  Open Surge version.", 
            "title": "version"
        }, 
        {
            "location": "/engine/transform/", 
            "text": "Transform\n\n\nTransform encapsulates a 2D Transform. It comes with functions for translating, rotating and scaling things - and it's very useful for games! Whenever you spawn a Transform on your object, you gain power to command its position, rotation and scale.\n\n\nThe Transform component can only be spawned on \nentities\n. If an entity with a Transform component has any children, the transform of the children will be affected by the transform of their parent. Example: if you move an object, its children will be moved by the same amount.\n\n\nFactory\n\n\nTransform\n\n\nTransform()\n\n\nSpawns a Transform on the object. The object is required to be an \nentity\n.\n\n\nReturns\n\n\nA Transform object.\n\n\nExample\n\n\nusing SurgeEngine.Actor;\nusing SurgeEngine.Transform;\n\nobject \nMyLevelObject\n is \nentity\n\n{\n    public transform = Transform();\n    actor = Actor(\nMyLevelObject\n);\n\n    state \nmain\n\n    {\n        // prints the position of this entity\n        Console.print(transform.position);\n    }\n}\n\n\n\n\nProperties\n\n\nposition\n\n\nposition\n: \nVector2\n object.\n\n\nThe position of the object in world coordinates.\n\n\nOnly use this property if you need to read the position of the object or to set it to a fixed value. If you need to move the entity, use \nmove\n instead.\n\n\nExample\n\n\nusing SurgeEngine.Actor;\nusing SurgeEngine.Player;\nusing SurgeEngine.Transform;\n\nobject \nMyLevelObject\n is \nentity\n\n{\n    public transform = Transform();\n    actor = Actor(\nMyLevelObject\n);\n\n    state \nmain\n\n    {\n        // this will show the distance between\n        // this entity and the active player\n        player = Player.active;\n        Console.print(distanceTo(player));\n    }\n\n    fun distanceTo(obj)\n    {\n        return transform.position.distanceTo(obj.transform.position);\n    }\n}\n\n\n\n\nangle\n\n\nangle\n: number.\n\n\nThe angle, in degrees, specifying the rotation of the object.\n\n\nUnless you need to read or to set the angle of the object to a pre-determined value, consider using \nrotate\n instead.\n\n\nlocalPosition\n\n\nlocalPosition\n: \nVector2\n object.\n\n\nThe position of the object relative to the parent object.\n\n\nOnly use this property if you need to read the position of the object or to set it to a fixed value. If you need to move the entity, use \nmove\n instead.\n\n\nlocalAngle\n\n\nlocalAngle\n: number.\n\n\nThe angle, in degrees, relative to the angle of the parent object.\n\n\nUnless you need to read or to set the angle of the object to a pre-determined value, consider using \nrotate\n instead.\n\n\nlocalScale\n\n\nlocalScale\n: \nVector2\n object.\n\n\nThe local scale of the entity.\n\n\nFunctions\n\n\nmove\n\n\nmove(dx, dy)\n\n\nMoves the object by (\ndx\n, \ndy\n).\n\n\nArguments\n\n\n\n\ndx\n: number. The amount to move the object in the x-axis.\n\n\ndy\n: number. The amount to move the object in the y-axis.\n\n\n\n\nExample\n\n\nusing SurgeEngine.Actor;\nusing SurgeEngine.Transform;\n\nobject \nMyLevelObject\n is \nentity\n\n{\n    public transform = Transform();\n    actor = Actor(\nMyLevelObject\n);\n\n    state \nmain\n\n    {\n        // move the entity at a speed of\n        // 50 pixels/second, to the right\n        transform.move(50 * Time.delta, 0);\n\n        // the command below would move it\n        // at a speed of 30 pixels per FRAME\n        //transform.move(30, 0); // don't do this\n\n        // since the framerate may vary across\n        // different systems, it's advisable\n        // to multiply the value by Time.delta\n        // to make the behavior consistent.\n    }\n}\n\n\n\n\ntranslate\n\n\ntranslate(delta)\n\n\nTranslates the object by a \ndelta\n vector.\n\n\nArguments\n\n\n\n\ndelta\n: \nVector2\n object.\n\n\n\n\nrotate\n\n\nrotate(deg)\n\n\nRotates the object by \ndeg\n degrees.\n\n\nArguments\n\n\n\n\ndeg\n: number.\n\n\n\n\nExample\n\n\nusing SurgeEngine.Actor;\nusing SurgeEngine.Transform;\n\nobject \nMyLevelObject\n is \nentity\n\n{\n    public transform = Transform();\n    actor = Actor(\nMyLevelObject\n);\n\n    state \nmain\n\n    {\n        // rotate the entity at a speed of\n        // 45 degrees per second\n        transform.rotate(45 * Time.delta);\n    }\n}\n\n\n\n\nlookAt\n\n\nlookAt(transform)\n\n\nUse this function to make your object look at some point in space.\n\n\nArguments\n\n\n\n\ntransform\n: Transform object.\n\n\n\n\nExample\n\n\nusing SurgeEngine.Actor;\nusing SurgeEngine.Player;\nusing SurgeEngine.Transform;\n\nobject \nMyLevelObject\n is \nentity\n\n{\n    public transform = Transform();\n    actor = Actor(\nMyLevelObject\n);\n\n    state \nmain\n\n    {\n        player = Player.active;\n        transform.lookAt(player.transform);\n    }\n}", 
            "title": "Transform"
        }, 
        {
            "location": "/engine/transform/#transform", 
            "text": "Transform encapsulates a 2D Transform. It comes with functions for translating, rotating and scaling things - and it's very useful for games! Whenever you spawn a Transform on your object, you gain power to command its position, rotation and scale.  The Transform component can only be spawned on  entities . If an entity with a Transform component has any children, the transform of the children will be affected by the transform of their parent. Example: if you move an object, its children will be moved by the same amount.", 
            "title": "Transform"
        }, 
        {
            "location": "/engine/transform/#factory", 
            "text": "", 
            "title": "Factory"
        }, 
        {
            "location": "/engine/transform/#transform_1", 
            "text": "Transform()  Spawns a Transform on the object. The object is required to be an  entity .  Returns  A Transform object.  Example  using SurgeEngine.Actor;\nusing SurgeEngine.Transform;\n\nobject  MyLevelObject  is  entity \n{\n    public transform = Transform();\n    actor = Actor( MyLevelObject );\n\n    state  main \n    {\n        // prints the position of this entity\n        Console.print(transform.position);\n    }\n}", 
            "title": "Transform"
        }, 
        {
            "location": "/engine/transform/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/engine/transform/#position", 
            "text": "position :  Vector2  object.  The position of the object in world coordinates.  Only use this property if you need to read the position of the object or to set it to a fixed value. If you need to move the entity, use  move  instead.  Example  using SurgeEngine.Actor;\nusing SurgeEngine.Player;\nusing SurgeEngine.Transform;\n\nobject  MyLevelObject  is  entity \n{\n    public transform = Transform();\n    actor = Actor( MyLevelObject );\n\n    state  main \n    {\n        // this will show the distance between\n        // this entity and the active player\n        player = Player.active;\n        Console.print(distanceTo(player));\n    }\n\n    fun distanceTo(obj)\n    {\n        return transform.position.distanceTo(obj.transform.position);\n    }\n}", 
            "title": "position"
        }, 
        {
            "location": "/engine/transform/#angle", 
            "text": "angle : number.  The angle, in degrees, specifying the rotation of the object.  Unless you need to read or to set the angle of the object to a pre-determined value, consider using  rotate  instead.", 
            "title": "angle"
        }, 
        {
            "location": "/engine/transform/#localposition", 
            "text": "localPosition :  Vector2  object.  The position of the object relative to the parent object.  Only use this property if you need to read the position of the object or to set it to a fixed value. If you need to move the entity, use  move  instead.", 
            "title": "localPosition"
        }, 
        {
            "location": "/engine/transform/#localangle", 
            "text": "localAngle : number.  The angle, in degrees, relative to the angle of the parent object.  Unless you need to read or to set the angle of the object to a pre-determined value, consider using  rotate  instead.", 
            "title": "localAngle"
        }, 
        {
            "location": "/engine/transform/#localscale", 
            "text": "localScale :  Vector2  object.  The local scale of the entity.", 
            "title": "localScale"
        }, 
        {
            "location": "/engine/transform/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/engine/transform/#move", 
            "text": "move(dx, dy)  Moves the object by ( dx ,  dy ).  Arguments   dx : number. The amount to move the object in the x-axis.  dy : number. The amount to move the object in the y-axis.   Example  using SurgeEngine.Actor;\nusing SurgeEngine.Transform;\n\nobject  MyLevelObject  is  entity \n{\n    public transform = Transform();\n    actor = Actor( MyLevelObject );\n\n    state  main \n    {\n        // move the entity at a speed of\n        // 50 pixels/second, to the right\n        transform.move(50 * Time.delta, 0);\n\n        // the command below would move it\n        // at a speed of 30 pixels per FRAME\n        //transform.move(30, 0); // don't do this\n\n        // since the framerate may vary across\n        // different systems, it's advisable\n        // to multiply the value by Time.delta\n        // to make the behavior consistent.\n    }\n}", 
            "title": "move"
        }, 
        {
            "location": "/engine/transform/#translate", 
            "text": "translate(delta)  Translates the object by a  delta  vector.  Arguments   delta :  Vector2  object.", 
            "title": "translate"
        }, 
        {
            "location": "/engine/transform/#rotate", 
            "text": "rotate(deg)  Rotates the object by  deg  degrees.  Arguments   deg : number.   Example  using SurgeEngine.Actor;\nusing SurgeEngine.Transform;\n\nobject  MyLevelObject  is  entity \n{\n    public transform = Transform();\n    actor = Actor( MyLevelObject );\n\n    state  main \n    {\n        // rotate the entity at a speed of\n        // 45 degrees per second\n        transform.rotate(45 * Time.delta);\n    }\n}", 
            "title": "rotate"
        }, 
        {
            "location": "/engine/transform/#lookat", 
            "text": "lookAt(transform)  Use this function to make your object look at some point in space.  Arguments   transform : Transform object.   Example  using SurgeEngine.Actor;\nusing SurgeEngine.Player;\nusing SurgeEngine.Transform;\n\nobject  MyLevelObject  is  entity \n{\n    public transform = Transform();\n    actor = Actor( MyLevelObject );\n\n    state  main \n    {\n        player = Player.active;\n        transform.lookAt(player.transform);\n    }\n}", 
            "title": "lookAt"
        }, 
        {
            "location": "/engine/text/", 
            "text": "Text\n\n\nThe Text object allows you to display custom texts in the game. The parent object is required to be an \nentity\n.\n\n\nFactory\n\n\nText\n\n\nUI.Text(font | null)\n\n\nSpawns a new Text object with the given font name. If \nnull\n is provided as the font name, then a default font will be used.\n\n\nArguments\n\n\n\n\nfont\n: string. The name of a font (defined in the \nfonts/\n folder).\n\n\n\n\nReturns\n\n\nA Text object.\n\n\nExample\n\n\nusing SurgeEngine.UI.Text;\nusing SurgeEngine.Transform;\nusing SurgeEngine.Player;\n\n// Place this on your level to display\n// the name of the player\nobject \nPlayerName\n is \nentity\n, \nawake\n\n{\n    text = Text(null);\n    transform = Transform();\n\n    state \nmain\n\n    {\n        // position the text\n        player = Player.active;\n        transform.position = player.transform.position;\n        transform.move(0, -50);\n\n        // configure the text\n        text.align = \ncenter\n;\n        text.text = player.name;\n    }\n}\n\n\n\n\nProperties\n\n\ntext\n\n\ntext\n: string.\n\n\nThe text to be displayed.\n\n\nfont\n\n\nfont\n: string, read-only.\n\n\nThe name of the font in use.\n\n\nalign\n\n\nalign\n: string.\n\n\nThe alignment of the text. One of the following: \n\"left\"\n, \n\"center\"\n, \n\"right\"\n.\n\n\nvisible\n\n\nvisible\n: boolean.\n\n\nIs the Text object visible?\n\n\nmaxlength\n\n\nmaxlength\n: number.\n\n\nThe maximum number of characters to be displayed, ignoring \n tags and spaces.\n\n\nmaxWidth\n\n\nmaxWidth\n: number.\n\n\nThe maximum width of the text, in pixels. Setting this value will enable wordwrap.\n\n\nzindex\n\n\nzindex\n: number.\n\n\nThe zindex of the Text object. Defaults to 0.5.\n\n\noffset\n\n\noffset\n: \nVector2\n object.\n\n\nAn \n(x,y)\n offset relative to the parent object. Defaults to zero.", 
            "title": "Text"
        }, 
        {
            "location": "/engine/text/#text", 
            "text": "The Text object allows you to display custom texts in the game. The parent object is required to be an  entity .", 
            "title": "Text"
        }, 
        {
            "location": "/engine/text/#factory", 
            "text": "", 
            "title": "Factory"
        }, 
        {
            "location": "/engine/text/#text_1", 
            "text": "UI.Text(font | null)  Spawns a new Text object with the given font name. If  null  is provided as the font name, then a default font will be used.  Arguments   font : string. The name of a font (defined in the  fonts/  folder).   Returns  A Text object.  Example  using SurgeEngine.UI.Text;\nusing SurgeEngine.Transform;\nusing SurgeEngine.Player;\n\n// Place this on your level to display\n// the name of the player\nobject  PlayerName  is  entity ,  awake \n{\n    text = Text(null);\n    transform = Transform();\n\n    state  main \n    {\n        // position the text\n        player = Player.active;\n        transform.position = player.transform.position;\n        transform.move(0, -50);\n\n        // configure the text\n        text.align =  center ;\n        text.text = player.name;\n    }\n}", 
            "title": "Text"
        }, 
        {
            "location": "/engine/text/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/engine/text/#text_2", 
            "text": "text : string.  The text to be displayed.", 
            "title": "text"
        }, 
        {
            "location": "/engine/text/#font", 
            "text": "font : string, read-only.  The name of the font in use.", 
            "title": "font"
        }, 
        {
            "location": "/engine/text/#align", 
            "text": "align : string.  The alignment of the text. One of the following:  \"left\" ,  \"center\" ,  \"right\" .", 
            "title": "align"
        }, 
        {
            "location": "/engine/text/#visible", 
            "text": "visible : boolean.  Is the Text object visible?", 
            "title": "visible"
        }, 
        {
            "location": "/engine/text/#maxlength", 
            "text": "maxlength : number.  The maximum number of characters to be displayed, ignoring   tags and spaces.", 
            "title": "maxlength"
        }, 
        {
            "location": "/engine/text/#maxwidth", 
            "text": "maxWidth : number.  The maximum width of the text, in pixels. Setting this value will enable wordwrap.", 
            "title": "maxWidth"
        }, 
        {
            "location": "/engine/text/#zindex", 
            "text": "zindex : number.  The zindex of the Text object. Defaults to 0.5.", 
            "title": "zindex"
        }, 
        {
            "location": "/engine/text/#offset", 
            "text": "offset :  Vector2  object.  An  (x,y)  offset relative to the parent object. Defaults to zero.", 
            "title": "offset"
        }, 
        {
            "location": "/engine/vector2/", 
            "text": "Vector2\n\n\nVector2 is a vector in 2D space. A vector is a mathematical object that has direction and length, usually represented by an arrow. A Vector2 can also be represented by a pair of \n(x,y)\n coordinates.\n\n\nIn SurgeScript, vectors are immutable. Once created, you can't change their coordinates directly. In order to bring about change (say, in the position of an \nentity\n), you need to create a new vector.\n\n\nVector2 objects have been designed in such a way that their functions make them chainable. You can compose different vector operations using english-based terms, as in the example below:\n\n\nExample\n\n\nusing SurgeEngine.Player;\nusing SurgeEngine.Vector2;\n...\nplayer = Player.active;\n...\nl = Vector2(6, 8).scaledBy(0.5).length; // number five\nu = Vector2.right.rotatedBy(45).scaledBy(2); // a vector\nv = player.transform.position.translatedBy(5,0); // a vector\n...\n\n\n\n\nFactory\n\n\nVector2\n\n\nVector2(x, y)\n\n\nSpawns a 2D vector with the given coordinates.\n\n\nArguments\n\n\n\n\nx\n: number. The x-coordinate of the vector.\n\n\ny\n: number. The y-coordinate of the vector.\n\n\n\n\nReturns\n\n\nA Vector2 object.\n\n\nExample\n\n\nusing SurgeEngine.Vector2;\nusing SurgeEngine.Player;\n\n// This entity will lock the player on position (100, 100)\nobject \nPlayerLocker\n is \nentity\n, \nawake\n\n{\n    pos = Vector2(100, 100);\n\n    state \nmain\n\n    {\n        player = Player.active;\n        player.transform.position = pos;\n    }\n}\n\n\n\n\nVector2.up\n\n\nVector2.up\n\n\nThe unit up vector.\n\n\nReturns\n\n\nReturns the unit up vector.\n\n\nVector2.right\n\n\nVector2.right\n\n\nThe unit right vector.\n\n\nReturns\n\n\nReturns the unit right vector.\n\n\nVector2.down\n\n\nVector2.down\n\n\nThe unit down vector.\n\n\nReturns\n\n\nReturns the unit down vector.\n\n\nVector2.left\n\n\nVector2.left\n\n\nThe unit left vector.\n\n\nReturns\n\n\nReturns the unit left vector.\n\n\nVector2.zero\n\n\nVector2.zero\n\n\nThe (0,0) vector.\n\n\nReturns\n\n\nReturns the (0,0) vector.\n\n\nProperties\n\n\nx\n\n\nx\n: number, read-only.\n\n\nThe x-coordinate of the vector.\n\n\ny\n\n\ny\n: number, read-only.\n\n\nThe y-coordinate of the vector.\n\n\nlength\n\n\nlength\n: number, read-only.\n\n\nThe length of the vector.\n\n\nangle\n\n\nangle\n: number, read-only.\n\n\nThe angle, in degrees, between the vector and the positive x-axis (as in polar coordinates).\n\n\nFunctions\n\n\nplus\n\n\nplus(v)\n\n\nReturns a Vector2 corresponding to the addition between \nthis\n and \nv\n.\n\n\nArguments\n\n\n\n\nv\n: Vector2 object.\n\n\n\n\nReturns\n\n\nReturns a Vector2 object corresponding to the result of the operation.\n\n\nExample\n\n\na = Vector2(3, 1);\nb = Vector2(2, 1);\nc = a.plus(b); // c = (5,2)\n\n\n\n\nminus\n\n\nminus(v)\n\n\nReturns a Vector2 corresponding to the subtraction between \nthis\n and \nv\n.\n\n\nArguments\n\n\n\n\nv\n: Vector2 object.\n\n\n\n\nReturns\n\n\nReturns a Vector2 object corresponding to the result of the operation.\n\n\nExample\n\n\nv = Vector2(5, 5);\nzero = v.minus(v); // zero = (0,0)\n\n\n\n\ndot\n\n\ndot(v)\n\n\nReturns the dot product between \nthis\n and \nv\n.\n\n\nArguments\n\n\n\n\nv\n: Vector2 object.\n\n\n\n\nReturns\n\n\nReturns a number: the dot product between \nthis\n and \nv\n.\n\n\nnormalized\n\n\nnormalized()\n\n\nReturns a normalized copy of \nthis\n: the new vector will have length one.\n\n\nReturns\n\n\nReturns a Vector2 object corresponding to the result of the operation.\n\n\ndirectionTo\n\n\ndirectionTo(v)\n\n\nReturns a unit vector pointing to \nv\n (from \nthis\n).\n\n\nArguments\n\n\n\n\nv\n: Vector2 object.\n\n\n\n\nReturns\n\n\nReturns a Vector2 of length one corresponding to the result of the operation.\n\n\ndistanceTo\n\n\ndistanceTo(v)\n\n\nConsidering \nthis\n and \nv\n as points in space, this function returns the distance between them.\n\n\nArguments\n\n\n\n\nv\n: Vector2 object.\n\n\n\n\nReturns\n\n\nReturns a number corresponding to the specified distance.\n\n\nExample\n\n\nusing SurgeEngine.Transform;\nusing SurgeEngine.Player;\n\n// This entity will show the distance between\n// itself and the active player\nobject \nDistanceDebugger\n is \nentity\n, \nawake\n\n{\n    transform = Transform();\n\n    state \nmain\n\n    {\n        player = Player.active;\n        playerpos = player.transform.position;\n        distance = transform.position.distanceTo(playerpos);\n        Console.print(distance);\n    }\n}\n\n\n\n\ntranslatedBy\n\n\ntranslatedBy(dx,dy)\n\n\nReturns a copy of \nthis\n translated by \n(dx,dy)\n.\n\n\nArguments\n\n\n\n\ndx\n: number. The offset to be added to the x-coordinate.\n\n\ndy\n: number. The offset to be added to the y-coordinate.\n\n\n\n\nReturns\n\n\nReturns a Vector2 object corresponding to the result of the operation.\n\n\nExample\n\n\nusing SurgeEngine.Vector2;\n...\none = Vector2(1,1);\nv = one.translatedBy(4,5); // (5,6)\n\n\n\n\nrotatedBy\n\n\nrotatedBy(deg)\n\n\nReturns a copy of \nthis\n rotated by \ndeg\n degrees.\n\n\nArguments\n\n\n\n\ndeg\n: number. The amount of degrees used on the rotation.\n\n\n\n\nReturns\n\n\nReturns a Vector2 object corresponding to the result of the operation.\n\n\nExample\n\n\nusing SurgeEngine.Vector2;\n\n...\n\n// A unit vector with an angle of 45 degrees\n// (relative to the positive x-axis)\nv = Vector2.right.rotatedBy(45);\n\n\n\n\nscaledBy\n\n\nscaledBy(s)\n\n\nReturns a copy of \nthis\n scaled by \ns\n. The length of the resulting vector will be the length of \nthis\n multiplied by \ns\n.\n\n\nArguments\n\n\n\n\ns\n: number. The multiplier.\n\n\n\n\nReturns\n\n\nReturns a Vector2 object corresponding to the result of the operation.\n\n\nExample\n\n\nusing SurgeEngine.Vector2;\n...\none = Vector2(1,1);\ntwo = one.scaledBy(2); // (2,2)\nhalf = one.scaledBy(0.5); // (0.5,0.5)\n\n\n\n\nprojectedOn\n\n\nprojectedOn(v)\n\n\nReturns a copy of \nthis\n projected on nonzero vector \nv\n.\n\n\nArguments\n\n\n\n\nv\n: Vector2 object.\n\n\n\n\nReturns\n\n\nReturns a Vector2 object corresponding to the result of the operation.\n\n\ntoString\n\n\ntoString()\n\n\nConverts the vector to a string.\n\n\nReturns\n\n\nReturns a string containing the coordinates of \nthis\n.\n\n\nExample\n\n\nusing SurgeEngine.Vector2;\n...\none = Vector2(1,1);\nConsole.print(one); // using toString() implicitly", 
            "title": "Vector2"
        }, 
        {
            "location": "/engine/vector2/#vector2", 
            "text": "Vector2 is a vector in 2D space. A vector is a mathematical object that has direction and length, usually represented by an arrow. A Vector2 can also be represented by a pair of  (x,y)  coordinates.  In SurgeScript, vectors are immutable. Once created, you can't change their coordinates directly. In order to bring about change (say, in the position of an  entity ), you need to create a new vector.  Vector2 objects have been designed in such a way that their functions make them chainable. You can compose different vector operations using english-based terms, as in the example below:  Example  using SurgeEngine.Player;\nusing SurgeEngine.Vector2;\n...\nplayer = Player.active;\n...\nl = Vector2(6, 8).scaledBy(0.5).length; // number five\nu = Vector2.right.rotatedBy(45).scaledBy(2); // a vector\nv = player.transform.position.translatedBy(5,0); // a vector\n...", 
            "title": "Vector2"
        }, 
        {
            "location": "/engine/vector2/#factory", 
            "text": "", 
            "title": "Factory"
        }, 
        {
            "location": "/engine/vector2/#vector2_1", 
            "text": "Vector2(x, y)  Spawns a 2D vector with the given coordinates.  Arguments   x : number. The x-coordinate of the vector.  y : number. The y-coordinate of the vector.   Returns  A Vector2 object.  Example  using SurgeEngine.Vector2;\nusing SurgeEngine.Player;\n\n// This entity will lock the player on position (100, 100)\nobject  PlayerLocker  is  entity ,  awake \n{\n    pos = Vector2(100, 100);\n\n    state  main \n    {\n        player = Player.active;\n        player.transform.position = pos;\n    }\n}", 
            "title": "Vector2"
        }, 
        {
            "location": "/engine/vector2/#vector2up", 
            "text": "Vector2.up  The unit up vector.  Returns  Returns the unit up vector.", 
            "title": "Vector2.up"
        }, 
        {
            "location": "/engine/vector2/#vector2right", 
            "text": "Vector2.right  The unit right vector.  Returns  Returns the unit right vector.", 
            "title": "Vector2.right"
        }, 
        {
            "location": "/engine/vector2/#vector2down", 
            "text": "Vector2.down  The unit down vector.  Returns  Returns the unit down vector.", 
            "title": "Vector2.down"
        }, 
        {
            "location": "/engine/vector2/#vector2left", 
            "text": "Vector2.left  The unit left vector.  Returns  Returns the unit left vector.", 
            "title": "Vector2.left"
        }, 
        {
            "location": "/engine/vector2/#vector2zero", 
            "text": "Vector2.zero  The (0,0) vector.  Returns  Returns the (0,0) vector.", 
            "title": "Vector2.zero"
        }, 
        {
            "location": "/engine/vector2/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/engine/vector2/#x", 
            "text": "x : number, read-only.  The x-coordinate of the vector.", 
            "title": "x"
        }, 
        {
            "location": "/engine/vector2/#y", 
            "text": "y : number, read-only.  The y-coordinate of the vector.", 
            "title": "y"
        }, 
        {
            "location": "/engine/vector2/#length", 
            "text": "length : number, read-only.  The length of the vector.", 
            "title": "length"
        }, 
        {
            "location": "/engine/vector2/#angle", 
            "text": "angle : number, read-only.  The angle, in degrees, between the vector and the positive x-axis (as in polar coordinates).", 
            "title": "angle"
        }, 
        {
            "location": "/engine/vector2/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/engine/vector2/#plus", 
            "text": "plus(v)  Returns a Vector2 corresponding to the addition between  this  and  v .  Arguments   v : Vector2 object.   Returns  Returns a Vector2 object corresponding to the result of the operation.  Example  a = Vector2(3, 1);\nb = Vector2(2, 1);\nc = a.plus(b); // c = (5,2)", 
            "title": "plus"
        }, 
        {
            "location": "/engine/vector2/#minus", 
            "text": "minus(v)  Returns a Vector2 corresponding to the subtraction between  this  and  v .  Arguments   v : Vector2 object.   Returns  Returns a Vector2 object corresponding to the result of the operation.  Example  v = Vector2(5, 5);\nzero = v.minus(v); // zero = (0,0)", 
            "title": "minus"
        }, 
        {
            "location": "/engine/vector2/#dot", 
            "text": "dot(v)  Returns the dot product between  this  and  v .  Arguments   v : Vector2 object.   Returns  Returns a number: the dot product between  this  and  v .", 
            "title": "dot"
        }, 
        {
            "location": "/engine/vector2/#normalized", 
            "text": "normalized()  Returns a normalized copy of  this : the new vector will have length one.  Returns  Returns a Vector2 object corresponding to the result of the operation.", 
            "title": "normalized"
        }, 
        {
            "location": "/engine/vector2/#directionto", 
            "text": "directionTo(v)  Returns a unit vector pointing to  v  (from  this ).  Arguments   v : Vector2 object.   Returns  Returns a Vector2 of length one corresponding to the result of the operation.", 
            "title": "directionTo"
        }, 
        {
            "location": "/engine/vector2/#distanceto", 
            "text": "distanceTo(v)  Considering  this  and  v  as points in space, this function returns the distance between them.  Arguments   v : Vector2 object.   Returns  Returns a number corresponding to the specified distance.  Example  using SurgeEngine.Transform;\nusing SurgeEngine.Player;\n\n// This entity will show the distance between\n// itself and the active player\nobject  DistanceDebugger  is  entity ,  awake \n{\n    transform = Transform();\n\n    state  main \n    {\n        player = Player.active;\n        playerpos = player.transform.position;\n        distance = transform.position.distanceTo(playerpos);\n        Console.print(distance);\n    }\n}", 
            "title": "distanceTo"
        }, 
        {
            "location": "/engine/vector2/#translatedby", 
            "text": "translatedBy(dx,dy)  Returns a copy of  this  translated by  (dx,dy) .  Arguments   dx : number. The offset to be added to the x-coordinate.  dy : number. The offset to be added to the y-coordinate.   Returns  Returns a Vector2 object corresponding to the result of the operation.  Example  using SurgeEngine.Vector2;\n...\none = Vector2(1,1);\nv = one.translatedBy(4,5); // (5,6)", 
            "title": "translatedBy"
        }, 
        {
            "location": "/engine/vector2/#rotatedby", 
            "text": "rotatedBy(deg)  Returns a copy of  this  rotated by  deg  degrees.  Arguments   deg : number. The amount of degrees used on the rotation.   Returns  Returns a Vector2 object corresponding to the result of the operation.  Example  using SurgeEngine.Vector2;\n\n...\n\n// A unit vector with an angle of 45 degrees\n// (relative to the positive x-axis)\nv = Vector2.right.rotatedBy(45);", 
            "title": "rotatedBy"
        }, 
        {
            "location": "/engine/vector2/#scaledby", 
            "text": "scaledBy(s)  Returns a copy of  this  scaled by  s . The length of the resulting vector will be the length of  this  multiplied by  s .  Arguments   s : number. The multiplier.   Returns  Returns a Vector2 object corresponding to the result of the operation.  Example  using SurgeEngine.Vector2;\n...\none = Vector2(1,1);\ntwo = one.scaledBy(2); // (2,2)\nhalf = one.scaledBy(0.5); // (0.5,0.5)", 
            "title": "scaledBy"
        }, 
        {
            "location": "/engine/vector2/#projectedon", 
            "text": "projectedOn(v)  Returns a copy of  this  projected on nonzero vector  v .  Arguments   v : Vector2 object.   Returns  Returns a Vector2 object corresponding to the result of the operation.", 
            "title": "projectedOn"
        }, 
        {
            "location": "/engine/vector2/#tostring", 
            "text": "toString()  Converts the vector to a string.  Returns  Returns a string containing the coordinates of  this .  Example  using SurgeEngine.Vector2;\n...\none = Vector2(1,1);\nConsole.print(one); // using toString() implicitly", 
            "title": "toString"
        }, 
        {
            "location": "/engine/screen/", 
            "text": "Screen\n\n\nScreen settings.\n\n\nExample\n\n\n// display the size of the screen\nusing SurgeEngine.Video.Screen;\n\nobject \nApplication\n\n{\n    width = Screen.width;\n    height = Screen.height;\n\n    state \nmain\n\n    {\n        Console.print(width + \nx\n + height);\n        state = \ndone\n;\n    }\n\n    state \ndone\n\n    {\n    }\n}\n\n\n\n\nProperties\n\n\nwidth\n\n\nwidth\n: number, read-only.\n\n\nThe width of the screen, in pixels.\n\n\nheight\n\n\nheight\n: number, read-only.\n\n\nThe height of the screen, in pixels.", 
            "title": "Screen"
        }, 
        {
            "location": "/engine/screen/#screen", 
            "text": "Screen settings.  Example  // display the size of the screen\nusing SurgeEngine.Video.Screen;\n\nobject  Application \n{\n    width = Screen.width;\n    height = Screen.height;\n\n    state  main \n    {\n        Console.print(width +  x  + height);\n        state =  done ;\n    }\n\n    state  done \n    {\n    }\n}", 
            "title": "Screen"
        }, 
        {
            "location": "/engine/screen/#properties", 
            "text": "", 
            "title": "Properties"
        }, 
        {
            "location": "/engine/screen/#width", 
            "text": "width : number, read-only.  The width of the screen, in pixels.", 
            "title": "width"
        }, 
        {
            "location": "/engine/screen/#height", 
            "text": "height : number, read-only.  The height of the screen, in pixels.", 
            "title": "height"
        }, 
        {
            "location": "/engine/web/", 
            "text": "Web\n\n\nWeb routines.\n\n\nFunctions\n\n\nlaunchURL\n\n\nlaunchURL(url)\n\n\nLaunches a URL using the default web browser. It's mandatory to specify a protocol. The following protocols are currently supported: \nhttp://\n, \nhttps://\n, \nmailto:\n\n\nArguments\n\n\n\n\nurl\n: string. The URL to be launched.\n\n\n\n\nExample\n\n\nusing SurgeEngine.Web;\n\nobject \nApplication\n\n{\n    // Remember to change the state\n    // after calling launchURL\n    state \nmain\n\n    {\n        Web.launchURL(\nhttp://opensurge2d.org\n);\n        state = \ndone\n;\n    }\n\n    state \ndone\n\n    {\n    }\n}", 
            "title": "Web"
        }, 
        {
            "location": "/engine/web/#web", 
            "text": "Web routines.", 
            "title": "Web"
        }, 
        {
            "location": "/engine/web/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/engine/web/#launchurl", 
            "text": "launchURL(url)  Launches a URL using the default web browser. It's mandatory to specify a protocol. The following protocols are currently supported:  http:// ,  https:// ,  mailto:  Arguments   url : string. The URL to be launched.   Example  using SurgeEngine.Web;\n\nobject  Application \n{\n    // Remember to change the state\n    // after calling launchURL\n    state  main \n    {\n        Web.launchURL( http://opensurge2d.org );\n        state =  done ;\n    }\n\n    state  done \n    {\n    }\n}", 
            "title": "launchURL"
        }
    ]
}