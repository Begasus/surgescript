{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to SurgeScript! Unleash your creativity! SurgeScript is a scripting language for games. It lets you unleash your creativity and build your own amazing interactive content! It's such a joy to use SurgeScript! You will love it! How do I learn SurgeScript? Check out the SurgeScript Crash Course ! Also take a look on the video tutorials and on the examples folder that comes with the software. SurgeScript in a nutshell SurgeScript is: A scripting language for games Easy for beginners, powerful for experts Object-oriented, dynamically typed and based on state machines Free and open source software Built in C, which is nearly universal Named after a really charismatic character: Surge ! The only programming language in the world that natively allows you to tag objects with emoticons ;) Why use SurgeScript? Unlike other programming languages, SurgeScript has been designed with the specific needs of games in mind. Its features include: The state-machine pattern: objects are state machines The composition approach: you may design complex objects and behaviors by means of composition The hierarchy system: objects have a parent and may have children, in a tree-like structure The game loop: it's defined implicitly Other benefits include: Small footprint, easy to integrate C-like syntax, including plenty of features Automatic garbage collection Easy to extend via Plugins It's free and open source software These features come from the experience of the developer dealing with game engines, applications related to computer graphics and so on. Some of the best practices have been incorporated into the language itself, making things really easy for developers and modders. Who created SurgeScript? SurgeScript has been created by Alexandre Martins , a computer scientist from Brazil. He has also created the Open Surge game engine , hence the name SurgeScript.","title":"Introduction"},{"location":"#welcome-to-surgescript","text":"","title":"Welcome to SurgeScript!"},{"location":"#unleash-your-creativity","text":"SurgeScript is a scripting language for games. It lets you unleash your creativity and build your own amazing interactive content! It's such a joy to use SurgeScript! You will love it!","title":"Unleash your creativity!"},{"location":"#how-do-i-learn-surgescript","text":"Check out the SurgeScript Crash Course ! Also take a look on the video tutorials and on the examples folder that comes with the software.","title":"How do I learn SurgeScript?"},{"location":"#surgescript-in-a-nutshell","text":"SurgeScript is: A scripting language for games Easy for beginners, powerful for experts Object-oriented, dynamically typed and based on state machines Free and open source software Built in C, which is nearly universal Named after a really charismatic character: Surge ! The only programming language in the world that natively allows you to tag objects with emoticons ;)","title":"SurgeScript in a nutshell"},{"location":"#why-use-surgescript","text":"Unlike other programming languages, SurgeScript has been designed with the specific needs of games in mind. Its features include: The state-machine pattern: objects are state machines The composition approach: you may design complex objects and behaviors by means of composition The hierarchy system: objects have a parent and may have children, in a tree-like structure The game loop: it's defined implicitly Other benefits include: Small footprint, easy to integrate C-like syntax, including plenty of features Automatic garbage collection Easy to extend via Plugins It's free and open source software These features come from the experience of the developer dealing with game engines, applications related to computer graphics and so on. Some of the best practices have been incorporated into the language itself, making things really easy for developers and modders.","title":"Why use SurgeScript?"},{"location":"#who-created-surgescript","text":"SurgeScript has been created by Alexandre Martins , a computer scientist from Brazil. He has also created the Open Surge game engine , hence the name SurgeScript.","title":"Who created SurgeScript?"},{"location":"download/","text":"Download SurgeScript There are two ways to get SurgeScript: The first is to get Open Surge . This is recommended for most users. The second is to get the standalone version of the language. This is useful if you're a developer and want to integrate SurgeScript into your own projects. Open Surge To get Open Surge, visit opensurge2d.org and follow the instructions there. When you get Open Surge, you also get a full game engine featuring SurgeScript. This allows you to create your own scripts and games with plenty of interactivity and ease. Once you download Open Surge, the next step is to create your first script . Standalone version To get the standalone version, go to the SurgeScript page on GitHub . There you'll find instructions on how to compile SurgeScript. When you compile SurgeScript, you'll end up with a text-only program. There are no graphics and no game engine is attached to it. You can try your scripts using the command line. Once you get the standalone version, the next step is to create your first script .","title":"Download"},{"location":"download/#download-surgescript","text":"There are two ways to get SurgeScript: The first is to get Open Surge . This is recommended for most users. The second is to get the standalone version of the language. This is useful if you're a developer and want to integrate SurgeScript into your own projects.","title":"Download SurgeScript"},{"location":"download/#open-surge","text":"To get Open Surge, visit opensurge2d.org and follow the instructions there. When you get Open Surge, you also get a full game engine featuring SurgeScript. This allows you to create your own scripts and games with plenty of interactivity and ease. Once you download Open Surge, the next step is to create your first script .","title":"Open Surge"},{"location":"download/#standalone-version","text":"To get the standalone version, go to the SurgeScript page on GitHub . There you'll find instructions on how to compile SurgeScript. When you compile SurgeScript, you'll end up with a text-only program. There are no graphics and no game engine is attached to it. You can try your scripts using the command line. Once you get the standalone version, the next step is to create your first script .","title":"Standalone version"},{"location":"engine/actor/","text":"Actor The Actor component is used to associate a sprite to a target object. The target object is required to be an entity . It's recommended to use only one actor per entity. Factory Actor Actor(sprite) Spawns a new Actor component with the given sprite name. Arguments sprite : string. The name of the sprite (defined in the sprites/ folder). Returns An Actor component. Example using SurgeEngine.Actor; object SurgeTest is entity { // spawns an Actor with the SurgeTest sprite actor = Actor( SurgeTest ); state main { } } Properties anim anim : number. A shortcut to animation.id : an integer corresponding to the animation number. Defaults to 0. animation animation : Animation object, read-only. Reference to the Animation object of the Actor. alpha alpha : number. Opacity value, ranging from zero (0% opaque) to one (100% opaque). Defaults to 1.0. entity entity : object, read-only. The entity associated with this component. offset offset : Vector2 object. A (x,y) offset relative to the parent object. Defaults to zero. hflip hflip : boolean. Should the actor be flipped horizontally? Defaults to false . vflip vflip : boolean. Should the actor be flipped vertically? Defaults to false . visible visible : boolean. Should the actor be rendered? Defaults to true . width width : number, read-only. The width of the actor. height height : number, read-only. The height of the actor. zindex zindex : number. Objects with greater zindex are rendered in front of others. Defaults to 0.5.","title":"Actor"},{"location":"engine/actor/#actor","text":"The Actor component is used to associate a sprite to a target object. The target object is required to be an entity . It's recommended to use only one actor per entity.","title":"Actor"},{"location":"engine/actor/#factory","text":"","title":"Factory"},{"location":"engine/actor/#actor_1","text":"Actor(sprite) Spawns a new Actor component with the given sprite name. Arguments sprite : string. The name of the sprite (defined in the sprites/ folder). Returns An Actor component. Example using SurgeEngine.Actor; object SurgeTest is entity { // spawns an Actor with the SurgeTest sprite actor = Actor( SurgeTest ); state main { } }","title":"Actor"},{"location":"engine/actor/#properties","text":"","title":"Properties"},{"location":"engine/actor/#anim","text":"anim : number. A shortcut to animation.id : an integer corresponding to the animation number. Defaults to 0.","title":"anim"},{"location":"engine/actor/#animation","text":"animation : Animation object, read-only. Reference to the Animation object of the Actor.","title":"animation"},{"location":"engine/actor/#alpha","text":"alpha : number. Opacity value, ranging from zero (0% opaque) to one (100% opaque). Defaults to 1.0.","title":"alpha"},{"location":"engine/actor/#entity","text":"entity : object, read-only. The entity associated with this component.","title":"entity"},{"location":"engine/actor/#offset","text":"offset : Vector2 object. A (x,y) offset relative to the parent object. Defaults to zero.","title":"offset"},{"location":"engine/actor/#hflip","text":"hflip : boolean. Should the actor be flipped horizontally? Defaults to false .","title":"hflip"},{"location":"engine/actor/#vflip","text":"vflip : boolean. Should the actor be flipped vertically? Defaults to false .","title":"vflip"},{"location":"engine/actor/#visible","text":"visible : boolean. Should the actor be rendered? Defaults to true .","title":"visible"},{"location":"engine/actor/#width","text":"width : number, read-only. The width of the actor.","title":"width"},{"location":"engine/actor/#height","text":"height : number, read-only. The height of the actor.","title":"height"},{"location":"engine/actor/#zindex","text":"zindex : number. Objects with greater zindex are rendered in front of others. Defaults to 0.5.","title":"zindex"},{"location":"engine/animation/","text":"Animation Animation objects are used to gather data about specific animations. Although you can't spawn Animation objects directly, you can access them via other objects such as Actor and Player . Example using SurgeEngine.Actor; object MyExplosion is entity , disposable , private { actor = Actor( MyExplosion ); state main { if(actor.animation.finished) destroy(); } } Properties id id : number. The number of the current animation, defined in a .spr file. sprite sprite : string, read-only. The name of the sprite, defined in a .spr file. finished finished : boolean, read-only. Will be true if the current animation has finished playing. hotspot hotspot : Vector2 object, read-only. The position of the hot spot of the current animation. fps fps : number, read-only. Frames per second of the current animation. repeats repeats : boolean, read-only. Does the current animation repeat itself? frame frame : number, read-only. The current frame of the animation: an integer between 0 and frameCount - 1 , inclusive. frameCount frameCount : number, read-only. The number of frames of the current animation. speedFactor speedFactor : number. While the FPS rate controls the speed of the animation, the speed factor gives you an additional degree of control. This is a multiplier that defaults to 1.0, meaning that the animation will run using its normal speed. If it's set to 2.0, it will run using twice that speed. A value of 0.5 means half the speed, and so on.","title":"Animation"},{"location":"engine/animation/#animation","text":"Animation objects are used to gather data about specific animations. Although you can't spawn Animation objects directly, you can access them via other objects such as Actor and Player . Example using SurgeEngine.Actor; object MyExplosion is entity , disposable , private { actor = Actor( MyExplosion ); state main { if(actor.animation.finished) destroy(); } }","title":"Animation"},{"location":"engine/animation/#properties","text":"","title":"Properties"},{"location":"engine/animation/#id","text":"id : number. The number of the current animation, defined in a .spr file.","title":"id"},{"location":"engine/animation/#sprite","text":"sprite : string, read-only. The name of the sprite, defined in a .spr file.","title":"sprite"},{"location":"engine/animation/#finished","text":"finished : boolean, read-only. Will be true if the current animation has finished playing.","title":"finished"},{"location":"engine/animation/#hotspot","text":"hotspot : Vector2 object, read-only. The position of the hot spot of the current animation.","title":"hotspot"},{"location":"engine/animation/#fps","text":"fps : number, read-only. Frames per second of the current animation.","title":"fps"},{"location":"engine/animation/#repeats","text":"repeats : boolean, read-only. Does the current animation repeat itself?","title":"repeats"},{"location":"engine/animation/#frame","text":"frame : number, read-only. The current frame of the animation: an integer between 0 and frameCount - 1 , inclusive.","title":"frame"},{"location":"engine/animation/#framecount","text":"frameCount : number, read-only. The number of frames of the current animation.","title":"frameCount"},{"location":"engine/animation/#speedfactor","text":"speedFactor : number. While the FPS rate controls the speed of the animation, the speed factor gives you an additional degree of control. This is a multiplier that defaults to 1.0, meaning that the animation will run using its normal speed. If it's set to 2.0, it will run using twice that speed. A value of 0.5 means half the speed, and so on.","title":"speedFactor"},{"location":"engine/brick/","text":"Brick The Brick component is used to create brick-like objects, or bricks endowed with scripting capabilities. This allows you to create elevators, conditional barriers (e.g., doors), movable platforms with custom trajectories, and much more. The Brick component only affects collisions. The object that uses it is required to be an entity . This component doesn't do any rendering. Therefore, it's typically used in conjunction with the Actor component. Example using SurgeEngine.Actor; using SurgeEngine.Brick; object On/Off Platform is entity { actor = Actor( On/Off Platform ); // for rendering brick = Brick( On/Off Platform ); // for collision state main { if(timeout(2.0)) { brick.enabled = false; actor.visible = false; state = disabled ; } } state disabled { if(timeout(2.0)) { brick.enabled = true; actor.visible = true; state = main ; } } } Factory Brick Brick(spriteName) Spawns a new Brick component. Just like regular bricks, a Brick component has a collision mask associated with it. By default, the collision mask will be computed according to the animation 0 of the sprite named spriteName . Arguments spriteName : string. The name of a sprite. Returns A new Brick component. Properties enabled enabled : boolean. Whether the Brick component should affect collisions or not. Defaults to true . type type : string. The type of the Brick component specifies how it affects collisions. This value must be either \"solid\" or \"cloud\" . Defaults to \"solid\" . layer layer : string. Should the Brick component be tied to a specific layer? If so, which layer? This value must be one of the following: \"green\" , \"yellow\" , \"default\" . Defaults to \"default\" . offset offset : Vector2 object. A (x,y) offset relative to the parent object. Defaults to zero.","title":"Brick"},{"location":"engine/brick/#brick","text":"The Brick component is used to create brick-like objects, or bricks endowed with scripting capabilities. This allows you to create elevators, conditional barriers (e.g., doors), movable platforms with custom trajectories, and much more. The Brick component only affects collisions. The object that uses it is required to be an entity . This component doesn't do any rendering. Therefore, it's typically used in conjunction with the Actor component. Example using SurgeEngine.Actor; using SurgeEngine.Brick; object On/Off Platform is entity { actor = Actor( On/Off Platform ); // for rendering brick = Brick( On/Off Platform ); // for collision state main { if(timeout(2.0)) { brick.enabled = false; actor.visible = false; state = disabled ; } } state disabled { if(timeout(2.0)) { brick.enabled = true; actor.visible = true; state = main ; } } }","title":"Brick"},{"location":"engine/brick/#factory","text":"","title":"Factory"},{"location":"engine/brick/#brick_1","text":"Brick(spriteName) Spawns a new Brick component. Just like regular bricks, a Brick component has a collision mask associated with it. By default, the collision mask will be computed according to the animation 0 of the sprite named spriteName . Arguments spriteName : string. The name of a sprite. Returns A new Brick component.","title":"Brick"},{"location":"engine/brick/#properties","text":"","title":"Properties"},{"location":"engine/brick/#enabled","text":"enabled : boolean. Whether the Brick component should affect collisions or not. Defaults to true .","title":"enabled"},{"location":"engine/brick/#type","text":"type : string. The type of the Brick component specifies how it affects collisions. This value must be either \"solid\" or \"cloud\" . Defaults to \"solid\" .","title":"type"},{"location":"engine/brick/#layer","text":"layer : string. Should the Brick component be tied to a specific layer? If so, which layer? This value must be one of the following: \"green\" , \"yellow\" , \"default\" . Defaults to \"default\" .","title":"layer"},{"location":"engine/brick/#offset","text":"offset : Vector2 object. A (x,y) offset relative to the parent object. Defaults to zero.","title":"offset"},{"location":"engine/camera/","text":"Camera The Camera object can be used to control what content (in world space) is rendered to the screen. The Camera is represented by a 2-dimensional point in world space that is mapped to the center of the screen. HUD elements Objects tagged as \"detached\" do not follow the camera. They are not in world space, but in screen space. This is useful for creating HUD elements. Example // Import the Camera object using SurgeEngine.Camera; // Reading the Camera status // This app prints the position of the camera at every second object Application { state main { if(timeout(1)) state = print ; } state print { Console.print(Camera.position); state = main ; } } Properties position position : Vector2 object. The position of the camera in world space.","title":"Camera"},{"location":"engine/camera/#camera","text":"The Camera object can be used to control what content (in world space) is rendered to the screen. The Camera is represented by a 2-dimensional point in world space that is mapped to the center of the screen. HUD elements Objects tagged as \"detached\" do not follow the camera. They are not in world space, but in screen space. This is useful for creating HUD elements. Example // Import the Camera object using SurgeEngine.Camera; // Reading the Camera status // This app prints the position of the camera at every second object Application { state main { if(timeout(1)) state = print ; } state print { Console.print(Camera.position); state = main ; } }","title":"Camera"},{"location":"engine/camera/#properties","text":"","title":"Properties"},{"location":"engine/camera/#position","text":"position : Vector2 object. The position of the camera in world space.","title":"position"},{"location":"engine/collider/","text":"Collider A collider, or collision object, is used to detect collisions. There are different types of colliders, each with a different shape. They are usually centered on the hot spot of sprites, but that can be changed by altering their anchor . Colliders must be spawned as children of entities . To detect collisions, you may implement function onCollision() on the entity (see the example below), or use the colliders directly. Additionally, a single entity may have multiple colliders attached to it. This allows users to work with more complex shapes than simple primitives. A collider is an abstract concept, and hence can't be spawned directly. Rather, you can spawn colliders of specific shapes, such as CollisionBox and CollisionBall . All Colliders share some functionalities (detailed in this page), but there are functionalities tied to specific shapes. Example using SurgeEngine.Actor; using SurgeEngine.Player; using SurgeEngine.Collisions.CollisionBall; object CollisionDoll is entity { actor = Actor( CollisionDoll ); collider = CollisionBall(25); // ball with radius = 25px // The player has a built-in collider // Let's make it visible for debugging state main { player = Player.active; player.collider.visible = true; collider.visible = true; } // Detect collisions between a collider that is a child // of this object and any other collider in the game fun onCollision(otherCollider) { // A collision has occurred. Console.print( Collided with something ); // Collided with a player? if(otherCollider.entity.hasTag( player )) { player = otherCollider.entity; Console.print( Touched + player.name); } } } Properties entity entity : object, read-only. The Entity associated with this collider. visible visible : boolean. Useful for debugging. The default value is false . Functions collidesWith collidesWith(collider) Checks if this collider is colliding with some other collider. Arguments collider : Collider object. The other collider. Returns Returns true if there is a collision (the colliders overlap), or false otherwise. contains contains(x, y) Checks if the collider contains the point ( x , y ), given in world coordinates. Arguments x : number. The x-coordinate of the point. y : number. The y-coordinate of the point. Returns Returns true if the point is inside the collider, or false otherwise. setAnchor setAnchor(x, y) Defines the anchor of the collider to be ( x , y ), where these values are (usually) numbers between 0.0 and 1.0. Imagine a bounding box of the collider. Point (0.5, 0.5) is the default, representing its center. Point (0.0, 0.0) is the top-left and (1,0, 1.0), the bottom-right. The anchor of the collider will be aligned to the hot spot of the sprite of the entity. Arguments x : number. Usually a value between 0.0 and 1.0. y : number. Usually a value between 0.0 and 1.0.","title":"Collider"},{"location":"engine/collider/#collider","text":"A collider, or collision object, is used to detect collisions. There are different types of colliders, each with a different shape. They are usually centered on the hot spot of sprites, but that can be changed by altering their anchor . Colliders must be spawned as children of entities . To detect collisions, you may implement function onCollision() on the entity (see the example below), or use the colliders directly. Additionally, a single entity may have multiple colliders attached to it. This allows users to work with more complex shapes than simple primitives. A collider is an abstract concept, and hence can't be spawned directly. Rather, you can spawn colliders of specific shapes, such as CollisionBox and CollisionBall . All Colliders share some functionalities (detailed in this page), but there are functionalities tied to specific shapes. Example using SurgeEngine.Actor; using SurgeEngine.Player; using SurgeEngine.Collisions.CollisionBall; object CollisionDoll is entity { actor = Actor( CollisionDoll ); collider = CollisionBall(25); // ball with radius = 25px // The player has a built-in collider // Let's make it visible for debugging state main { player = Player.active; player.collider.visible = true; collider.visible = true; } // Detect collisions between a collider that is a child // of this object and any other collider in the game fun onCollision(otherCollider) { // A collision has occurred. Console.print( Collided with something ); // Collided with a player? if(otherCollider.entity.hasTag( player )) { player = otherCollider.entity; Console.print( Touched + player.name); } } }","title":"Collider"},{"location":"engine/collider/#properties","text":"","title":"Properties"},{"location":"engine/collider/#entity","text":"entity : object, read-only. The Entity associated with this collider.","title":"entity"},{"location":"engine/collider/#visible","text":"visible : boolean. Useful for debugging. The default value is false .","title":"visible"},{"location":"engine/collider/#functions","text":"","title":"Functions"},{"location":"engine/collider/#collideswith","text":"collidesWith(collider) Checks if this collider is colliding with some other collider. Arguments collider : Collider object. The other collider. Returns Returns true if there is a collision (the colliders overlap), or false otherwise.","title":"collidesWith"},{"location":"engine/collider/#contains","text":"contains(x, y) Checks if the collider contains the point ( x , y ), given in world coordinates. Arguments x : number. The x-coordinate of the point. y : number. The y-coordinate of the point. Returns Returns true if the point is inside the collider, or false otherwise.","title":"contains"},{"location":"engine/collider/#setanchor","text":"setAnchor(x, y) Defines the anchor of the collider to be ( x , y ), where these values are (usually) numbers between 0.0 and 1.0. Imagine a bounding box of the collider. Point (0.5, 0.5) is the default, representing its center. Point (0.0, 0.0) is the top-left and (1,0, 1.0), the bottom-right. The anchor of the collider will be aligned to the hot spot of the sprite of the entity. Arguments x : number. Usually a value between 0.0 and 1.0. y : number. Usually a value between 0.0 and 1.0.","title":"setAnchor"},{"location":"engine/collisionball/","text":"CollisionBall A CollisionBall is a special type of Collider that takes the shape of a ball. In 2D space, this is a circle with a specific radius. All functions and properties of Collider apply to this. Example using SurgeEngine.Actor; using SurgeEngine.Collisions.CollisionBall; object CollisionDoll is entity { actor = Actor( CollisionDoll ); collider = CollisionBall(25); // radius = 25px state main { collider.visible = true; // useful for debugging } fun onCollision(otherCollider) { Console.print( A collision has occurred. ); } } Factory Collisions.CollisionBall Collisions.CollisionBall(radius) Spawns a new CollisionBall with the specified radius, in pixels. Arguments radius : number. The radius of the CollisionBall. Returns A new CollisionBall with the specified radius. Properties center center : Vector2 , read-only. The center of the CollisionBall, in world space. radius radius : number. The radius of the CollisionBall, in pixels.","title":"CollisionBall"},{"location":"engine/collisionball/#collisionball","text":"A CollisionBall is a special type of Collider that takes the shape of a ball. In 2D space, this is a circle with a specific radius. All functions and properties of Collider apply to this. Example using SurgeEngine.Actor; using SurgeEngine.Collisions.CollisionBall; object CollisionDoll is entity { actor = Actor( CollisionDoll ); collider = CollisionBall(25); // radius = 25px state main { collider.visible = true; // useful for debugging } fun onCollision(otherCollider) { Console.print( A collision has occurred. ); } }","title":"CollisionBall"},{"location":"engine/collisionball/#factory","text":"","title":"Factory"},{"location":"engine/collisionball/#collisionscollisionball","text":"Collisions.CollisionBall(radius) Spawns a new CollisionBall with the specified radius, in pixels. Arguments radius : number. The radius of the CollisionBall. Returns A new CollisionBall with the specified radius.","title":"Collisions.CollisionBall"},{"location":"engine/collisionball/#properties","text":"","title":"Properties"},{"location":"engine/collisionball/#center","text":"center : Vector2 , read-only. The center of the CollisionBall, in world space.","title":"center"},{"location":"engine/collisionball/#radius","text":"radius : number. The radius of the CollisionBall, in pixels.","title":"radius"},{"location":"engine/collisionbox/","text":"CollisionBox A CollisionBox is a special type of Collider that takes the shape of a box. In 2D space, this is a rectangle with a specific width and height. All functions and properties of Collider apply to this. Example using SurgeEngine.Actor; using SurgeEngine.Collisions.CollisionBox; object CollisionDoll is entity { actor = Actor( CollisionDoll ); collider = CollisionBox(32, 64); // width = 32px, height = 64px state main { collider.visible = true; // useful for debugging } fun onCollision(otherCollider) { Console.print( A collision has occurred. ); } } Factory Collisions.CollisionBox Collisions.CollisionBox(width, height) Spawns a new CollisionBox with the specified dimensions, in pixels. Arguments width : number. The width of the CollisionBox. height : number. The height of the CollisionBox. Returns A new CollisionBox with the specified dimensions. Properties top top : number, read-only. The y-coordinate of top border of the CollisionBox, in world space. right right : number, read-only. The x-coordinate of right border of the CollisionBox, in world space. bottom bottom : number, read-only. The y-coordinate of bottom border of the CollisionBox, in world space. left left : number, read-only. The x-coordinate of left border of the CollisionBox, in world space. width width : number. The width of the CollisionBox, in pixels. height height : number. The height of the CollisionBox, in pixels.","title":"CollisionBox"},{"location":"engine/collisionbox/#collisionbox","text":"A CollisionBox is a special type of Collider that takes the shape of a box. In 2D space, this is a rectangle with a specific width and height. All functions and properties of Collider apply to this. Example using SurgeEngine.Actor; using SurgeEngine.Collisions.CollisionBox; object CollisionDoll is entity { actor = Actor( CollisionDoll ); collider = CollisionBox(32, 64); // width = 32px, height = 64px state main { collider.visible = true; // useful for debugging } fun onCollision(otherCollider) { Console.print( A collision has occurred. ); } }","title":"CollisionBox"},{"location":"engine/collisionbox/#factory","text":"","title":"Factory"},{"location":"engine/collisionbox/#collisionscollisionbox","text":"Collisions.CollisionBox(width, height) Spawns a new CollisionBox with the specified dimensions, in pixels. Arguments width : number. The width of the CollisionBox. height : number. The height of the CollisionBox. Returns A new CollisionBox with the specified dimensions.","title":"Collisions.CollisionBox"},{"location":"engine/collisionbox/#properties","text":"","title":"Properties"},{"location":"engine/collisionbox/#top","text":"top : number, read-only. The y-coordinate of top border of the CollisionBox, in world space.","title":"top"},{"location":"engine/collisionbox/#right","text":"right : number, read-only. The x-coordinate of right border of the CollisionBox, in world space.","title":"right"},{"location":"engine/collisionbox/#bottom","text":"bottom : number, read-only. The y-coordinate of bottom border of the CollisionBox, in world space.","title":"bottom"},{"location":"engine/collisionbox/#left","text":"left : number, read-only. The x-coordinate of left border of the CollisionBox, in world space.","title":"left"},{"location":"engine/collisionbox/#width","text":"width : number. The width of the CollisionBox, in pixels.","title":"width"},{"location":"engine/collisionbox/#height","text":"height : number. The height of the CollisionBox, in pixels.","title":"height"},{"location":"engine/entity/","text":"Entity Entity is not an object per-se. Rather, it's a class of objects. An entity is an object that is present in world space (for example: an item, a NPC, a baddie, and so on). Abstract objects or components are not entities. In Open Surge, all objects that are tagged \"entity\" are considered to be entities. Entites have special treatment in Open Surge. They are deactivated automatically if they get too far off camera. Behavior can be changed by adding different tags to your entities. Additionally, entities can have components associated to it, so they can be fully customized. Tip During level design, entities may be placed in world space using the editor palette. The icon of the entity will be the first animation (animation 0) of the sprite that has the name of the entity. Tags entity Tells Open Surge that the object is an entity and should be treated as such. // In the example below, MyExplosion (entity) has an Actor component // that gives it a visible form (a sprite) in world space. using SurgeEngine.Actor; object MyExplosion is entity , private , disposable { actor = Actor( MyExplosion ); state main { if(actor.animation.finished) destroy(); } } awake Tells Open Surge to not disable the object if it gets too far off camera. detached The object will not follow the camera - it will be rendered in screen space. disposable Will destroy the object automatically if it gets too far off camera. private Private entities cannot be spawned via the level editor (they will be hidden). Functions onReset onReset() If an entity* that has been placed in the level via the editor gets too far off camera, it will be deactivated and repositioned back to its spawn point (i.e., the place where it was originally). Whenever that happens, the engine will call this function if it's available in your entity. You may want to use this to reset the entity back to its initial state. Note*: entities tagged as awake or detached are not affected. Example using SurgeEngine.UI.Text; // The object below is a simple counter that gets // reseted whenever it gets too far off camera. object My Test Counter is entity { label = Text( default ); counter = 0; state main { Console.print( Starting the counter... ); state = wait ; } state wait { label.text = counter; if(timeout(1.0)) state = increment ; } state increment { counter++; state = wait ; } // Without implementing function onReset() below, // the counter would retain its state. fun onReset() { counter = 0; state = main ; } } onLeaveEditor onLeaveEditor() If declared, function onLeaveEditor() will be called whenever the player leaves the level editor and returns to the game. This might be useful to reconfigure your objects.","title":"Entity"},{"location":"engine/entity/#entity","text":"Entity is not an object per-se. Rather, it's a class of objects. An entity is an object that is present in world space (for example: an item, a NPC, a baddie, and so on). Abstract objects or components are not entities. In Open Surge, all objects that are tagged \"entity\" are considered to be entities. Entites have special treatment in Open Surge. They are deactivated automatically if they get too far off camera. Behavior can be changed by adding different tags to your entities. Additionally, entities can have components associated to it, so they can be fully customized. Tip During level design, entities may be placed in world space using the editor palette. The icon of the entity will be the first animation (animation 0) of the sprite that has the name of the entity.","title":"Entity"},{"location":"engine/entity/#tags","text":"","title":"Tags"},{"location":"engine/entity/#entity_1","text":"Tells Open Surge that the object is an entity and should be treated as such. // In the example below, MyExplosion (entity) has an Actor component // that gives it a visible form (a sprite) in world space. using SurgeEngine.Actor; object MyExplosion is entity , private , disposable { actor = Actor( MyExplosion ); state main { if(actor.animation.finished) destroy(); } }","title":"entity"},{"location":"engine/entity/#awake","text":"Tells Open Surge to not disable the object if it gets too far off camera.","title":"awake"},{"location":"engine/entity/#detached","text":"The object will not follow the camera - it will be rendered in screen space.","title":"detached"},{"location":"engine/entity/#disposable","text":"Will destroy the object automatically if it gets too far off camera.","title":"disposable"},{"location":"engine/entity/#private","text":"Private entities cannot be spawned via the level editor (they will be hidden).","title":"private"},{"location":"engine/entity/#functions","text":"","title":"Functions"},{"location":"engine/entity/#onreset","text":"onReset() If an entity* that has been placed in the level via the editor gets too far off camera, it will be deactivated and repositioned back to its spawn point (i.e., the place where it was originally). Whenever that happens, the engine will call this function if it's available in your entity. You may want to use this to reset the entity back to its initial state. Note*: entities tagged as awake or detached are not affected. Example using SurgeEngine.UI.Text; // The object below is a simple counter that gets // reseted whenever it gets too far off camera. object My Test Counter is entity { label = Text( default ); counter = 0; state main { Console.print( Starting the counter... ); state = wait ; } state wait { label.text = counter; if(timeout(1.0)) state = increment ; } state increment { counter++; state = wait ; } // Without implementing function onReset() below, // the counter would retain its state. fun onReset() { counter = 0; state = main ; } }","title":"onReset"},{"location":"engine/entity/#onleaveeditor","text":"onLeaveEditor() If declared, function onLeaveEditor() will be called whenever the player leaves the level editor and returns to the game. This might be useful to reconfigure your objects.","title":"onLeaveEditor"},{"location":"engine/input/","text":"Input The Input component is used to read input from the user. Factory Input Input(inputMap | null) Spawns a new Input component with the given input map. Note: to read input from a specific character, prefer using Player.input instead. Arguments inputMap : string | null. The name of the input map. If set to null , a default input map will be used. Returns An Input component. Example using SurgeEngine.Input; object Application { input = Input(null); state main { if(input.buttonDown( right )) Console.print( User is holding right ); } } Functions buttonDown buttonDown(buttonName) Checks if a button of the input map is currently being held down. Arguments buttonName : string. One of the following: \"up\", \"down\", \"left\", \"right\", \"fire1\", \"fire2\", ..., \"fire8\" . Returns Returns true if the specified button is being held down. buttonPressed buttonPressed(buttonName) Checks if a button has just been pressed. Arguments buttonName : string. One of the following: \"up\", \"down\", \"left\", \"right\", \"fire1\", \"fire2\", ..., \"fire8\" . Returns Returns true if the specified button has just been pressed. buttonReleased buttonReleased(buttonName) Checks if a button has just been released. Arguments buttonName : string. One of the following: \"up\", \"down\", \"left\", \"right\", \"fire1\", \"fire2\", ..., \"fire8\" . Returns Returns true if the specified button has just been released. simulateButtonDown simulateButtonDown(buttonName) Changes the input object so that buttonName will be identified as being held down in the current frame. Arguments buttonName : string. One of the following: \"up\", \"down\", \"left\", \"right\", \"fire1\", \"fire2\", ..., \"fire8\" .","title":"Input"},{"location":"engine/input/#input","text":"The Input component is used to read input from the user.","title":"Input"},{"location":"engine/input/#factory","text":"","title":"Factory"},{"location":"engine/input/#input_1","text":"Input(inputMap | null) Spawns a new Input component with the given input map. Note: to read input from a specific character, prefer using Player.input instead. Arguments inputMap : string | null. The name of the input map. If set to null , a default input map will be used. Returns An Input component. Example using SurgeEngine.Input; object Application { input = Input(null); state main { if(input.buttonDown( right )) Console.print( User is holding right ); } }","title":"Input"},{"location":"engine/input/#functions","text":"","title":"Functions"},{"location":"engine/input/#buttondown","text":"buttonDown(buttonName) Checks if a button of the input map is currently being held down. Arguments buttonName : string. One of the following: \"up\", \"down\", \"left\", \"right\", \"fire1\", \"fire2\", ..., \"fire8\" . Returns Returns true if the specified button is being held down.","title":"buttonDown"},{"location":"engine/input/#buttonpressed","text":"buttonPressed(buttonName) Checks if a button has just been pressed. Arguments buttonName : string. One of the following: \"up\", \"down\", \"left\", \"right\", \"fire1\", \"fire2\", ..., \"fire8\" . Returns Returns true if the specified button has just been pressed.","title":"buttonPressed"},{"location":"engine/input/#buttonreleased","text":"buttonReleased(buttonName) Checks if a button has just been released. Arguments buttonName : string. One of the following: \"up\", \"down\", \"left\", \"right\", \"fire1\", \"fire2\", ..., \"fire8\" . Returns Returns true if the specified button has just been released.","title":"buttonReleased"},{"location":"engine/input/#simulatebuttondown","text":"simulateButtonDown(buttonName) Changes the input object so that buttonName will be identified as being held down in the current frame. Arguments buttonName : string. One of the following: \"up\", \"down\", \"left\", \"right\", \"fire1\", \"fire2\", ..., \"fire8\" .","title":"simulateButtonDown"},{"location":"engine/lang/","text":"Lang Lang is a SurgeEngine element used to read translation-specific strings, as defined in the language files (.lng). Example using SurgeEngine.Lang; // Display the current language object Application { state main { currentLanguage = Lang[ LANG_LANGUAGE ]; Console.print( The current language is + currentLanguage); state = done ; } state done { } } Functions get get(key) Gets the value of the specified key. Instead of calling get() directly, you may equivalently use the [ ] operator. Arguments key : string. The key must always be a string. Returns The translation string associated with the specified key.","title":"Lang"},{"location":"engine/lang/#lang","text":"Lang is a SurgeEngine element used to read translation-specific strings, as defined in the language files (.lng). Example using SurgeEngine.Lang; // Display the current language object Application { state main { currentLanguage = Lang[ LANG_LANGUAGE ]; Console.print( The current language is + currentLanguage); state = done ; } state done { } }","title":"Lang"},{"location":"engine/lang/#functions","text":"","title":"Functions"},{"location":"engine/lang/#get","text":"get(key) Gets the value of the specified key. Instead of calling get() directly, you may equivalently use the [ ] operator. Arguments key : string. The key must always be a string. Returns The translation string associated with the specified key.","title":"get"},{"location":"engine/level/","text":"Level Level routines. A level is a scene in the game, represented by a .lev file in the levels/ folder. Whenever you spawn an object in SurgeScript, you should keep a reference to it, otherwise it will be automatically deleted by the Garbage Collector . Sometimes, you may want to spawn entities in your level, but keeping references to all of them may be inconvenient. If this is your case, you can spawn them as children of the Level object . It will keep references of the entities for you; therefore, they won't be garbage collected. Example using SurgeEngine.Level; using SurgeEngine.Player; object Application { state main { if(timeout(1)) state = explode ; } state explode { Level.spawn( MyExplosion ); // no need to keep references state = main ; } } object MyExplosion is entity , disposable , private { actor = Actor( MyExplosion ); state main { if(actor.animation.finished) destroy() } fun constructor() { // set initial position player = Player.active; actor.transform.position = player.transform.position; } } Properties name name : string, read-only. The name of the level. Example using SurgeEngine.Level; // Will display the name of the level object Application { state main { Console.print(Level.name); state = done ; } state done { } } act act : number, read-only. The act number (1, 2, 3...) of the current level. cleared cleared : boolean, read-only. Checks if the current level has been cleared by the player. If this is true , a level cleared animation should be played. Although the engine provides a default animation, you may use this property to design your own. See also: clear() . file file : string, read-only. The relative path of the .lev file of the current level. version version : string, read-only. The version of the level, defined in the .lev file. author author : string, read-only. The author of the level, defined in the .lev file. license license : string, read-only. The license of the level, defined in the .lev file. music music : Music object, read-only. The music of the level. waterlevel waterlevel : number. The y-coordinate, in world space, of the level water. Pixels not above this value are underwater. background background : string. The path to the background file (.bg) currently in use. Use this property to change the background of the level. Functions spawn spawn(objectName) Spawns an object as a child of Level. Such objects won't be garbage collected. Please note that the spawned object is required to be an entity . Arguments objectName : string. The name of the object to be spawned. Returns The spawned object. restart restart() Restarts the current level. quit quit() Prompts the user to see if he/she wants to quit the current level. abort abort() Quits the current level/quest without prompting the user. pause pause() Pauses the game. load load(filepath) Loads the specified level/quest. If you pass the path to a level (a .lev file in the levels/ folder), the specified level will be loaded. The state of the current level (position of the entities and so on) will be lost. If you pass the path to a quest (a .qst file in the quests/ folder), the specified quest will be loaded and, when it's completed, the engine will redirect the user back to the level he/she was before. This might be useful for creating bonuses, configuration screens, and so on. Arguments filepath : string. Relative path of the level or quest to be loaded. Example using SurgeEngine.Level; object LevelLoader { fun load(id) { if(id == beach ) Level.load( levels/my_beach_level.lev ); else if(id == forest ) Level.load( levels/my_forest_level.lev ); else Console.print( Unrecognized level: + id); } } clear clear() Clears the level without actually changing it. Once the level is cleared, a level cleared animation is played. See also: cleared . finish finish() Loads the next level in the current quest. This is the usual procedure after clearing the level .","title":"Level"},{"location":"engine/level/#level","text":"Level routines. A level is a scene in the game, represented by a .lev file in the levels/ folder. Whenever you spawn an object in SurgeScript, you should keep a reference to it, otherwise it will be automatically deleted by the Garbage Collector . Sometimes, you may want to spawn entities in your level, but keeping references to all of them may be inconvenient. If this is your case, you can spawn them as children of the Level object . It will keep references of the entities for you; therefore, they won't be garbage collected. Example using SurgeEngine.Level; using SurgeEngine.Player; object Application { state main { if(timeout(1)) state = explode ; } state explode { Level.spawn( MyExplosion ); // no need to keep references state = main ; } } object MyExplosion is entity , disposable , private { actor = Actor( MyExplosion ); state main { if(actor.animation.finished) destroy() } fun constructor() { // set initial position player = Player.active; actor.transform.position = player.transform.position; } }","title":"Level"},{"location":"engine/level/#properties","text":"","title":"Properties"},{"location":"engine/level/#name","text":"name : string, read-only. The name of the level. Example using SurgeEngine.Level; // Will display the name of the level object Application { state main { Console.print(Level.name); state = done ; } state done { } }","title":"name"},{"location":"engine/level/#act","text":"act : number, read-only. The act number (1, 2, 3...) of the current level.","title":"act"},{"location":"engine/level/#cleared","text":"cleared : boolean, read-only. Checks if the current level has been cleared by the player. If this is true , a level cleared animation should be played. Although the engine provides a default animation, you may use this property to design your own. See also: clear() .","title":"cleared"},{"location":"engine/level/#file","text":"file : string, read-only. The relative path of the .lev file of the current level.","title":"file"},{"location":"engine/level/#version","text":"version : string, read-only. The version of the level, defined in the .lev file.","title":"version"},{"location":"engine/level/#author","text":"author : string, read-only. The author of the level, defined in the .lev file.","title":"author"},{"location":"engine/level/#license","text":"license : string, read-only. The license of the level, defined in the .lev file.","title":"license"},{"location":"engine/level/#music","text":"music : Music object, read-only. The music of the level.","title":"music"},{"location":"engine/level/#waterlevel","text":"waterlevel : number. The y-coordinate, in world space, of the level water. Pixels not above this value are underwater.","title":"waterlevel"},{"location":"engine/level/#background","text":"background : string. The path to the background file (.bg) currently in use. Use this property to change the background of the level.","title":"background"},{"location":"engine/level/#functions","text":"","title":"Functions"},{"location":"engine/level/#spawn","text":"spawn(objectName) Spawns an object as a child of Level. Such objects won't be garbage collected. Please note that the spawned object is required to be an entity . Arguments objectName : string. The name of the object to be spawned. Returns The spawned object.","title":"spawn"},{"location":"engine/level/#restart","text":"restart() Restarts the current level.","title":"restart"},{"location":"engine/level/#quit","text":"quit() Prompts the user to see if he/she wants to quit the current level.","title":"quit"},{"location":"engine/level/#abort","text":"abort() Quits the current level/quest without prompting the user.","title":"abort"},{"location":"engine/level/#pause","text":"pause() Pauses the game.","title":"pause"},{"location":"engine/level/#load","text":"load(filepath) Loads the specified level/quest. If you pass the path to a level (a .lev file in the levels/ folder), the specified level will be loaded. The state of the current level (position of the entities and so on) will be lost. If you pass the path to a quest (a .qst file in the quests/ folder), the specified quest will be loaded and, when it's completed, the engine will redirect the user back to the level he/she was before. This might be useful for creating bonuses, configuration screens, and so on. Arguments filepath : string. Relative path of the level or quest to be loaded. Example using SurgeEngine.Level; object LevelLoader { fun load(id) { if(id == beach ) Level.load( levels/my_beach_level.lev ); else if(id == forest ) Level.load( levels/my_forest_level.lev ); else Console.print( Unrecognized level: + id); } }","title":"load"},{"location":"engine/level/#clear","text":"clear() Clears the level without actually changing it. Once the level is cleared, a level cleared animation is played. See also: cleared .","title":"clear"},{"location":"engine/level/#finish","text":"finish() Loads the next level in the current quest. This is the usual procedure after clearing the level .","title":"finish"},{"location":"engine/mouse/","text":"Mouse The Mouse object is used to read input from the mouse. Example // This example shows how to use the Collectible // sprite as a mouse cursor. Since MyCursor is // tagged as detached , it will be rendered in // screen space (not world space). using SurgeEngine.Actor; using SurgeEngine.Transform; using SurgeEngine.Input.Mouse; object MyCursor is entity , detached { actor = Actor( MyCursor ); transform = Transform(); state main { transform.position = Mouse.position; if(Mouse.buttonPressed( left )) Console.print( left click ); } fun constructor() { actor.zindex = 1.0; } } Properties position position : Vector2 object, read-only. The position of the mouse cursor, in screen space. Functions buttonDown buttonDown(buttonName) Checks if a mouse button is currently being held down. Arguments buttonName : string. One of the following: \"left\" , \"right\" , \"middle\" . Returns Returns true if the specified button is being held down. buttonPressed buttonPressed(buttonName) Checks if a mouse button has just been pressed. Arguments buttonName : string. One of the following: \"left\" , \"right\" , \"middle\" . Returns Returns true if the specified button has just been pressed (i.e., a click has just occurred). buttonReleased buttonReleased(buttonName) Checks if a mouse button has just been released. Arguments buttonName : string. One of the following: \"left\" , \"right\" , \"middle\" . Returns Returns true if the specified button has just been released.","title":"Mouse"},{"location":"engine/mouse/#mouse","text":"The Mouse object is used to read input from the mouse. Example // This example shows how to use the Collectible // sprite as a mouse cursor. Since MyCursor is // tagged as detached , it will be rendered in // screen space (not world space). using SurgeEngine.Actor; using SurgeEngine.Transform; using SurgeEngine.Input.Mouse; object MyCursor is entity , detached { actor = Actor( MyCursor ); transform = Transform(); state main { transform.position = Mouse.position; if(Mouse.buttonPressed( left )) Console.print( left click ); } fun constructor() { actor.zindex = 1.0; } }","title":"Mouse"},{"location":"engine/mouse/#properties","text":"","title":"Properties"},{"location":"engine/mouse/#position","text":"position : Vector2 object, read-only. The position of the mouse cursor, in screen space.","title":"position"},{"location":"engine/mouse/#functions","text":"","title":"Functions"},{"location":"engine/mouse/#buttondown","text":"buttonDown(buttonName) Checks if a mouse button is currently being held down. Arguments buttonName : string. One of the following: \"left\" , \"right\" , \"middle\" . Returns Returns true if the specified button is being held down.","title":"buttonDown"},{"location":"engine/mouse/#buttonpressed","text":"buttonPressed(buttonName) Checks if a mouse button has just been pressed. Arguments buttonName : string. One of the following: \"left\" , \"right\" , \"middle\" . Returns Returns true if the specified button has just been pressed (i.e., a click has just occurred).","title":"buttonPressed"},{"location":"engine/mouse/#buttonreleased","text":"buttonReleased(buttonName) Checks if a mouse button has just been released. Arguments buttonName : string. One of the following: \"left\" , \"right\" , \"middle\" . Returns Returns true if the specified button has just been released.","title":"buttonReleased"},{"location":"engine/music/","text":"Music The Music object lets you play music. This is meant to handle background music; therefore, only one music can be played at a time. Unlike regular sounds , musics are streamed, (i.e., not loaded completely in memory). Given the longer nature of musics, this improves memory usage and helps with the loading times. Example using SurgeEngine.Level; // Fades the music in a linear fashion ;) object MyMusicFader { public music = Level.music; prevVolume = music.volume; fadeTime = 1.0; // given in seconds state main { } state fadeout { music.volume -= Time.delta / fadeTime; if(music.volume = 0.0) { music.pause(); music.volume = prevVolume; state = main ; } } // call fadeOut() to make the // music fade smoothly fun fadeOut(seconds) { if(state == main ) prevVolume = music.volume; fadeTime = seconds; state = fadeout ; } } Factory Music Audio.Music(path) Creates a Music object associated with a certain file. Arguments path : string. The path of the music - usually a file in the musics/ folder. Returns A Music object. Example using SurgeEngine.Audio.Music; object MusicTest { music = Music( musics/options.ogg ); state main { // loop music if(!music.playing) music.play(); } } Properties playing playing : boolean, read-only. Will be true if the music is playing. volume volume : number. The volume of the music, a value between 0.0 and 1.0, inclusive (zero means silence). Functions play play() Plays the music (once). To make it loop, play it whenever music.playing is false . stop stop() Stops the music. Once the music is stopped, it can only be played again from the beginning. pause pause() Pauses the music. A paused music can be resumed later with play() .","title":"Music"},{"location":"engine/music/#music","text":"The Music object lets you play music. This is meant to handle background music; therefore, only one music can be played at a time. Unlike regular sounds , musics are streamed, (i.e., not loaded completely in memory). Given the longer nature of musics, this improves memory usage and helps with the loading times. Example using SurgeEngine.Level; // Fades the music in a linear fashion ;) object MyMusicFader { public music = Level.music; prevVolume = music.volume; fadeTime = 1.0; // given in seconds state main { } state fadeout { music.volume -= Time.delta / fadeTime; if(music.volume = 0.0) { music.pause(); music.volume = prevVolume; state = main ; } } // call fadeOut() to make the // music fade smoothly fun fadeOut(seconds) { if(state == main ) prevVolume = music.volume; fadeTime = seconds; state = fadeout ; } }","title":"Music"},{"location":"engine/music/#factory","text":"","title":"Factory"},{"location":"engine/music/#music_1","text":"Audio.Music(path) Creates a Music object associated with a certain file. Arguments path : string. The path of the music - usually a file in the musics/ folder. Returns A Music object. Example using SurgeEngine.Audio.Music; object MusicTest { music = Music( musics/options.ogg ); state main { // loop music if(!music.playing) music.play(); } }","title":"Music"},{"location":"engine/music/#properties","text":"","title":"Properties"},{"location":"engine/music/#playing","text":"playing : boolean, read-only. Will be true if the music is playing.","title":"playing"},{"location":"engine/music/#volume","text":"volume : number. The volume of the music, a value between 0.0 and 1.0, inclusive (zero means silence).","title":"volume"},{"location":"engine/music/#functions","text":"","title":"Functions"},{"location":"engine/music/#play","text":"play() Plays the music (once). To make it loop, play it whenever music.playing is false .","title":"play"},{"location":"engine/music/#stop","text":"stop() Stops the music. Once the music is stopped, it can only be played again from the beginning.","title":"stop"},{"location":"engine/music/#pause","text":"pause() Pauses the music. A paused music can be resumed later with play() .","title":"pause"},{"location":"engine/player/","text":"Player The Player object is used to control a specific player/character. Player objects are tagged player . That might be useful when dealing with collisions. Factory Player Player(playerName | playerId) Gets the Player object associated with a certain character. Arguments playerName : string. The name of the character (defined in the characters/ folder). playerId : number. The ID of the character (as defined in the .lev file), an integer between 0 and Player.count - 1 , inclusive. Returns A Player object. Example using SurgeEngine.Player; // Gives Surge 1 collectible each second // Just place it in your level object CollectibleGiver is entity , awake { player = Player( Surge ); state main { if(timeout(1)) state = give collectible ; } state give collectible { player.collectibles = player.collectibles + 1; state = main ; } } Player.active Player.active The active player, i.e., the one currently in focus. Returns A Player object. Example using SurgeEngine.Player; // Tells the name of the active player object Who am I { state main { Console.print( I am + Player.active.name); destroy(); } } Player.count Player.count Player count. Returns The number of players in the level. Player.initialLives Player.initialLives The initial number of lives set by the engine. Returns The initial number of lives. Properties name name : string, read-only. The name of the character. activity activity : string, read-only. The current state / activity of the player. One of the following: \"stopped\" , \"walking\" , \"running\" , \"jumping\" , \"springing\" , \"rolling\" , \"charging\" , \"pushing\" , \"gettinghit\" , \"dying\" , \"braking\" , \"balancing\" , \"drowning\" , \"breathing\" , \"ducking\" , \"lookingup\" , \"waiting\" , \"winning\" . using SurgeEngine.Player; // Place this inside your level to see the // current activity of the active player object ActivityDebugger is awake , entity { state main { player = Player.active; Console.print(player.activity); } } anim anim : number. A shortcut to animation.id : an integer corresponding to the animation number. animation animation : Animation object, read-only. Reference to the Animation object of the Player. input input : Input object, read-only. Reference to the Input object of the Player. Example using SurgeEngine.Player; object Application { state main { if(Player.active.input.buttonDown( right )) Console.print( Player is holding right ); } } attacking attacking : boolean, read-only. Is the player attacking? (jumping, rolling, and so on) midair midair : boolean, read-only. Is the player midair? secondsToDrown secondsToDrown : number, read-only. The number of seconds to drown, if underwater. direction direction : number, read-only. Direction will be +1 if the player is facing right, -1 if facing left. transform transform : Transform object, read-only. The transform of the Player. collider collider : Collider object, read-only. A collider associated with this Player. shield shield : string. One of the following: \"none\" , \"shield\" , \"fire\" , \"thunder\" , \"water\" , \"acid\" , \"wind\" . invincible invincible : boolean. Used to make the player invincible. Defaults to false . turbo turbo : boolean. Turbo mode (increases player speed). Defaults to false . frozen frozen : boolean. Disable/enable player movement. Defaults to false . underwater underwater : boolean. Get underwater / out of water. Defaults to false . layer layer : string. The current layer of the player. One of the following: \"green\" , \"yellow\" , \"default\" . This property tells you which bricks will be sensed, depending on their layer. visible visible : boolean. Should the player sprite be rendered? Defaults to true . collectibles collectibles : number. The number of collectibles, an integer shared between all player objects. lives lives : number. The number of lives, an integer shared between all player objects. score score : number. The score of the player, an integer value shared between all player objects. topspeed topspeed : number, read-only. The maximum speed the player can reach without items (i.e., running naturally), in pixels per second. speed speed : number. The speed of the player, in pixels per second. This will be mapped automatically to gsp or xsp , depending on whether the player is touching the ground or not. gsp gsp : number. Ground speed, in pixels per second. Prefer using speed instead, since gsp is only meaningful if the player is touching the ground. xsp xsp : number. Horizontal speed, in pixels per second (useful while midair). Prefer using speed instead. ysp ysp : number. Vertical speed, in pixels per second. angle angle : number. The angle of the player, in degrees. The same as transform.angle . width width : number, read-only. The width of the player sprite, in pixels. height height : number, read-only. The height of the player sprite, in pixels. Functions bounce bounce(hazard | null) Makes the player bounce after smashing a hazard. The trajectory of the movement will be computed according to the position of the hazard. If no hazard is present, you may pass null as the argument. Arguments hazard : Actor object. The hazard. Example using SurgeEngine.Player; using SurgeEngine.Actor; using SurgeEngine.Collisions.CollisionBox; object ShieldBox is entity { actor = Actor( ShieldBox ); shieldCollider = CollisionBox(32,32); state main { player = Player.active; if(player.attacking) { if(player.collider.collidesWith(shieldCollider)) { if(player.midair) player.bounce(actor); player.shield = fire ; destroy(); } } } } bounceBack bounceBack(hazard) Makes the player bounce after smashing a hazard. If the player comes at the hazard from below, the player is thrown downwards. If not, the player is thrown upwards. The hazard parameter is mandatory. Arguments hazard : Actor object. The hazard. hit hit(hazard | null) Makes the player get hit. Call it whenever the player gets hit by a hazard. The hit movement will be calculated according to the position of the hazard. If no hazard is present, you may pass null as the argument. Arguments hazard : Actor object. The hazard. kill kill() Kills the player. breathe breathe() Makes the player breathe (underwater only). springify springify() Activates the \"springing\" activity. roll roll() Makes the player roll. hlock hlock(seconds) Locks the horizontal controls of the player for a few seconds (left and right input will be ignored during that time). focus focus() Focuses on the player. The focused player is controlled by the user. Only one player can have focus at any given time. hasFocus hasFocus() Does the player have focus? Returns Returns true if the player has focus, false otherwise.","title":"Player"},{"location":"engine/player/#player","text":"The Player object is used to control a specific player/character. Player objects are tagged player . That might be useful when dealing with collisions.","title":"Player"},{"location":"engine/player/#factory","text":"","title":"Factory"},{"location":"engine/player/#player_1","text":"Player(playerName | playerId) Gets the Player object associated with a certain character. Arguments playerName : string. The name of the character (defined in the characters/ folder). playerId : number. The ID of the character (as defined in the .lev file), an integer between 0 and Player.count - 1 , inclusive. Returns A Player object. Example using SurgeEngine.Player; // Gives Surge 1 collectible each second // Just place it in your level object CollectibleGiver is entity , awake { player = Player( Surge ); state main { if(timeout(1)) state = give collectible ; } state give collectible { player.collectibles = player.collectibles + 1; state = main ; } }","title":"Player"},{"location":"engine/player/#playeractive","text":"Player.active The active player, i.e., the one currently in focus. Returns A Player object. Example using SurgeEngine.Player; // Tells the name of the active player object Who am I { state main { Console.print( I am + Player.active.name); destroy(); } }","title":"Player.active"},{"location":"engine/player/#playercount","text":"Player.count Player count. Returns The number of players in the level.","title":"Player.count"},{"location":"engine/player/#playerinitiallives","text":"Player.initialLives The initial number of lives set by the engine. Returns The initial number of lives.","title":"Player.initialLives"},{"location":"engine/player/#properties","text":"","title":"Properties"},{"location":"engine/player/#name","text":"name : string, read-only. The name of the character.","title":"name"},{"location":"engine/player/#activity","text":"activity : string, read-only. The current state / activity of the player. One of the following: \"stopped\" , \"walking\" , \"running\" , \"jumping\" , \"springing\" , \"rolling\" , \"charging\" , \"pushing\" , \"gettinghit\" , \"dying\" , \"braking\" , \"balancing\" , \"drowning\" , \"breathing\" , \"ducking\" , \"lookingup\" , \"waiting\" , \"winning\" . using SurgeEngine.Player; // Place this inside your level to see the // current activity of the active player object ActivityDebugger is awake , entity { state main { player = Player.active; Console.print(player.activity); } }","title":"activity"},{"location":"engine/player/#anim","text":"anim : number. A shortcut to animation.id : an integer corresponding to the animation number.","title":"anim"},{"location":"engine/player/#animation","text":"animation : Animation object, read-only. Reference to the Animation object of the Player.","title":"animation"},{"location":"engine/player/#input","text":"input : Input object, read-only. Reference to the Input object of the Player. Example using SurgeEngine.Player; object Application { state main { if(Player.active.input.buttonDown( right )) Console.print( Player is holding right ); } }","title":"input"},{"location":"engine/player/#attacking","text":"attacking : boolean, read-only. Is the player attacking? (jumping, rolling, and so on)","title":"attacking"},{"location":"engine/player/#midair","text":"midair : boolean, read-only. Is the player midair?","title":"midair"},{"location":"engine/player/#secondstodrown","text":"secondsToDrown : number, read-only. The number of seconds to drown, if underwater.","title":"secondsToDrown"},{"location":"engine/player/#direction","text":"direction : number, read-only. Direction will be +1 if the player is facing right, -1 if facing left.","title":"direction"},{"location":"engine/player/#transform","text":"transform : Transform object, read-only. The transform of the Player.","title":"transform"},{"location":"engine/player/#collider","text":"collider : Collider object, read-only. A collider associated with this Player.","title":"collider"},{"location":"engine/player/#shield","text":"shield : string. One of the following: \"none\" , \"shield\" , \"fire\" , \"thunder\" , \"water\" , \"acid\" , \"wind\" .","title":"shield"},{"location":"engine/player/#invincible","text":"invincible : boolean. Used to make the player invincible. Defaults to false .","title":"invincible"},{"location":"engine/player/#turbo","text":"turbo : boolean. Turbo mode (increases player speed). Defaults to false .","title":"turbo"},{"location":"engine/player/#frozen","text":"frozen : boolean. Disable/enable player movement. Defaults to false .","title":"frozen"},{"location":"engine/player/#underwater","text":"underwater : boolean. Get underwater / out of water. Defaults to false .","title":"underwater"},{"location":"engine/player/#layer","text":"layer : string. The current layer of the player. One of the following: \"green\" , \"yellow\" , \"default\" . This property tells you which bricks will be sensed, depending on their layer.","title":"layer"},{"location":"engine/player/#visible","text":"visible : boolean. Should the player sprite be rendered? Defaults to true .","title":"visible"},{"location":"engine/player/#collectibles","text":"collectibles : number. The number of collectibles, an integer shared between all player objects.","title":"collectibles"},{"location":"engine/player/#lives","text":"lives : number. The number of lives, an integer shared between all player objects.","title":"lives"},{"location":"engine/player/#score","text":"score : number. The score of the player, an integer value shared between all player objects.","title":"score"},{"location":"engine/player/#topspeed","text":"topspeed : number, read-only. The maximum speed the player can reach without items (i.e., running naturally), in pixels per second.","title":"topspeed"},{"location":"engine/player/#speed","text":"speed : number. The speed of the player, in pixels per second. This will be mapped automatically to gsp or xsp , depending on whether the player is touching the ground or not.","title":"speed"},{"location":"engine/player/#gsp","text":"gsp : number. Ground speed, in pixels per second. Prefer using speed instead, since gsp is only meaningful if the player is touching the ground.","title":"gsp"},{"location":"engine/player/#xsp","text":"xsp : number. Horizontal speed, in pixels per second (useful while midair). Prefer using speed instead.","title":"xsp"},{"location":"engine/player/#ysp","text":"ysp : number. Vertical speed, in pixels per second.","title":"ysp"},{"location":"engine/player/#angle","text":"angle : number. The angle of the player, in degrees. The same as transform.angle .","title":"angle"},{"location":"engine/player/#width","text":"width : number, read-only. The width of the player sprite, in pixels.","title":"width"},{"location":"engine/player/#height","text":"height : number, read-only. The height of the player sprite, in pixels.","title":"height"},{"location":"engine/player/#functions","text":"","title":"Functions"},{"location":"engine/player/#bounce","text":"bounce(hazard | null) Makes the player bounce after smashing a hazard. The trajectory of the movement will be computed according to the position of the hazard. If no hazard is present, you may pass null as the argument. Arguments hazard : Actor object. The hazard. Example using SurgeEngine.Player; using SurgeEngine.Actor; using SurgeEngine.Collisions.CollisionBox; object ShieldBox is entity { actor = Actor( ShieldBox ); shieldCollider = CollisionBox(32,32); state main { player = Player.active; if(player.attacking) { if(player.collider.collidesWith(shieldCollider)) { if(player.midair) player.bounce(actor); player.shield = fire ; destroy(); } } } }","title":"bounce"},{"location":"engine/player/#bounceback","text":"bounceBack(hazard) Makes the player bounce after smashing a hazard. If the player comes at the hazard from below, the player is thrown downwards. If not, the player is thrown upwards. The hazard parameter is mandatory. Arguments hazard : Actor object. The hazard.","title":"bounceBack"},{"location":"engine/player/#hit","text":"hit(hazard | null) Makes the player get hit. Call it whenever the player gets hit by a hazard. The hit movement will be calculated according to the position of the hazard. If no hazard is present, you may pass null as the argument. Arguments hazard : Actor object. The hazard.","title":"hit"},{"location":"engine/player/#kill","text":"kill() Kills the player.","title":"kill"},{"location":"engine/player/#breathe","text":"breathe() Makes the player breathe (underwater only).","title":"breathe"},{"location":"engine/player/#springify","text":"springify() Activates the \"springing\" activity.","title":"springify"},{"location":"engine/player/#roll","text":"roll() Makes the player roll.","title":"roll"},{"location":"engine/player/#hlock","text":"hlock(seconds) Locks the horizontal controls of the player for a few seconds (left and right input will be ignored during that time).","title":"hlock"},{"location":"engine/player/#focus","text":"focus() Focuses on the player. The focused player is controlled by the user. Only one player can have focus at any given time.","title":"focus"},{"location":"engine/player/#hasfocus","text":"hasFocus() Does the player have focus? Returns Returns true if the player has focus, false otherwise.","title":"hasFocus"},{"location":"engine/prefs/","text":"Prefs Prefs is a SurgeEngine component used to save/load data to/from the disk (permanent storage). Prefs is a (key, value) storage that works like a Dictionary, but its data can be persisted between game sessions. Example using SurgeEngine.Prefs; // Run the Application multiple times and see // how the counter increments object Application { state main { Prefs[ counter ] += 1; Console.print( counter: + Prefs[ counter ]); } fun constructor() { if(!Prefs.has( counter )) Prefs[ counter ] = 0; } } Functions get get(key) Gets the value of the specified key. Instead of calling get() directly, you may equivalently use the [ ] operator. Arguments key : string. The key must always be a string. Returns Returns the value associated with the specified key, or null if there is no such value. set set(key, value) Sets the value of the specified key. Instead of calling set() directly, you may equivalently use the [ ] operator. Arguments key : string. The key must always be a string. value : any type. The value you want to store. clear clear() Removes all entries from Prefs. Use this very carefully, because data will be lost. delete delete(key) Deletes the entry having the specified key. Arguments key : string. The key of the entry to be removed. has has(key) Checks if a specific entry exists. Arguments key : string. The key of the entry. Returns Returns true if the specified entry exists, false otherwise. save save() Writes the data to secondary storage. The data isn't saved immediately after you set an entry, but it is saved on key moments. Since the data is persisted automatically, normally you don't need to call this.","title":"Prefs"},{"location":"engine/prefs/#prefs","text":"Prefs is a SurgeEngine component used to save/load data to/from the disk (permanent storage). Prefs is a (key, value) storage that works like a Dictionary, but its data can be persisted between game sessions. Example using SurgeEngine.Prefs; // Run the Application multiple times and see // how the counter increments object Application { state main { Prefs[ counter ] += 1; Console.print( counter: + Prefs[ counter ]); } fun constructor() { if(!Prefs.has( counter )) Prefs[ counter ] = 0; } }","title":"Prefs"},{"location":"engine/prefs/#functions","text":"","title":"Functions"},{"location":"engine/prefs/#get","text":"get(key) Gets the value of the specified key. Instead of calling get() directly, you may equivalently use the [ ] operator. Arguments key : string. The key must always be a string. Returns Returns the value associated with the specified key, or null if there is no such value.","title":"get"},{"location":"engine/prefs/#set","text":"set(key, value) Sets the value of the specified key. Instead of calling set() directly, you may equivalently use the [ ] operator. Arguments key : string. The key must always be a string. value : any type. The value you want to store.","title":"set"},{"location":"engine/prefs/#clear","text":"clear() Removes all entries from Prefs. Use this very carefully, because data will be lost.","title":"clear"},{"location":"engine/prefs/#delete","text":"delete(key) Deletes the entry having the specified key. Arguments key : string. The key of the entry to be removed.","title":"delete"},{"location":"engine/prefs/#has","text":"has(key) Checks if a specific entry exists. Arguments key : string. The key of the entry. Returns Returns true if the specified entry exists, false otherwise.","title":"has"},{"location":"engine/prefs/#save","text":"save() Writes the data to secondary storage. The data isn't saved immediately after you set an entry, but it is saved on key moments. Since the data is persisted automatically, normally you don't need to call this.","title":"save"},{"location":"engine/screen/","text":"Screen Screen settings. Example // display the size of the screen using SurgeEngine.Video.Screen; object Application { width = Screen.width; height = Screen.height; state main { Console.print(width + x + height); state = done ; } state done { } } Properties width width : number, read-only. The width of the screen, in pixels. height height : number, read-only. The height of the screen, in pixels.","title":"Screen"},{"location":"engine/screen/#screen","text":"Screen settings. Example // display the size of the screen using SurgeEngine.Video.Screen; object Application { width = Screen.width; height = Screen.height; state main { Console.print(width + x + height); state = done ; } state done { } }","title":"Screen"},{"location":"engine/screen/#properties","text":"","title":"Properties"},{"location":"engine/screen/#width","text":"width : number, read-only. The width of the screen, in pixels.","title":"width"},{"location":"engine/screen/#height","text":"height : number, read-only. The height of the screen, in pixels.","title":"height"},{"location":"engine/sensor/","text":"Sensor A Sensor is used to detect collisions with bricks (obstacle, cloud). Due to performance optimizations, passable bricks (or bricks that are too far off camera) can't be sensed. Example using SurgeEngine.Actor; using SurgeEngine.Collisions.Sensor; object SensorToy is entity { actor = Actor( SensorToy ); sensor = Sensor(10, -50, 1, 50); state main { if(sensor.status != null) Console.print( Got a brick ); } fun constructor() { sensor.visible = true; } } Factory Sensor Collisions.Sensor(x, y, width, height) Spawns a new Sensor with the specified dimensions and having its top-left corner located at position ( x , y ) relative to the parent object. A Sensor is either a vertical or a horizontal bar that is 1-pixel thin. Both width and height must be positive integers, and at least one of them must be equal to 1. Arguments x : number. The x-position of the top-left corner of the sensor, relative to the parent object. y : number. The y-position of the top-left corner of the sensor, relative to the parent object. width : number. The width of the sensor, in pixels. Must be a positive integer. height : number. The height of the sensor, in pixels. Must be a positive integer. Returns A Sensor with the specified parameters. Properties visible visible : boolean. Should the sensor be rendered? Useful for debugging. Defaults to false . status status : string | null, read-only. The type of the brick colliding with the sensor (either \"solid\" or \"cloud\" ). If the sensor isn't colliding with a brick, its status will be null .","title":"Sensor"},{"location":"engine/sensor/#sensor","text":"A Sensor is used to detect collisions with bricks (obstacle, cloud). Due to performance optimizations, passable bricks (or bricks that are too far off camera) can't be sensed. Example using SurgeEngine.Actor; using SurgeEngine.Collisions.Sensor; object SensorToy is entity { actor = Actor( SensorToy ); sensor = Sensor(10, -50, 1, 50); state main { if(sensor.status != null) Console.print( Got a brick ); } fun constructor() { sensor.visible = true; } }","title":"Sensor"},{"location":"engine/sensor/#factory","text":"","title":"Factory"},{"location":"engine/sensor/#sensor_1","text":"Collisions.Sensor(x, y, width, height) Spawns a new Sensor with the specified dimensions and having its top-left corner located at position ( x , y ) relative to the parent object. A Sensor is either a vertical or a horizontal bar that is 1-pixel thin. Both width and height must be positive integers, and at least one of them must be equal to 1. Arguments x : number. The x-position of the top-left corner of the sensor, relative to the parent object. y : number. The y-position of the top-left corner of the sensor, relative to the parent object. width : number. The width of the sensor, in pixels. Must be a positive integer. height : number. The height of the sensor, in pixels. Must be a positive integer. Returns A Sensor with the specified parameters.","title":"Sensor"},{"location":"engine/sensor/#properties","text":"","title":"Properties"},{"location":"engine/sensor/#visible","text":"visible : boolean. Should the sensor be rendered? Useful for debugging. Defaults to false .","title":"visible"},{"location":"engine/sensor/#status","text":"status : string | null, read-only. The type of the brick colliding with the sensor (either \"solid\" or \"cloud\" ). If the sensor isn't colliding with a brick, its status will be null .","title":"status"},{"location":"engine/sound/","text":"Sound The Sound object lets you play samples, which are short sounds like: jump, brake, select, hit, etc. Sounds are loaded entirely in the memory; therefore, this object is meant to be used only with samples. If you need to play longer things like music, consider using Music instead. Example using SurgeEngine.Audio.Sound; // will play a sound every 5 seconds object SoundTest { sound = Sound( samples/jump.wav ); state main { sound.play(); state = wait ; } state wait { if(timeout(5.0)) state = main ; } } Factory Sound Audio.Sound(path) Creates a Sound object associated with a certain file. Arguments path : string. The path of the sound - usually a file in the samples/ folder. Returns A Sound object. Properties playing playing : boolean, read-only. Will be true if the sound is playing. volume volume : number. The volume of the sound, a value between 0.0 and 1.0, inclusive (zero means silence). Functions play play() Plays the sound. stop stop() Stops the sound.","title":"Sound"},{"location":"engine/sound/#sound","text":"The Sound object lets you play samples, which are short sounds like: jump, brake, select, hit, etc. Sounds are loaded entirely in the memory; therefore, this object is meant to be used only with samples. If you need to play longer things like music, consider using Music instead. Example using SurgeEngine.Audio.Sound; // will play a sound every 5 seconds object SoundTest { sound = Sound( samples/jump.wav ); state main { sound.play(); state = wait ; } state wait { if(timeout(5.0)) state = main ; } }","title":"Sound"},{"location":"engine/sound/#factory","text":"","title":"Factory"},{"location":"engine/sound/#sound_1","text":"Audio.Sound(path) Creates a Sound object associated with a certain file. Arguments path : string. The path of the sound - usually a file in the samples/ folder. Returns A Sound object.","title":"Sound"},{"location":"engine/sound/#properties","text":"","title":"Properties"},{"location":"engine/sound/#playing","text":"playing : boolean, read-only. Will be true if the sound is playing.","title":"playing"},{"location":"engine/sound/#volume","text":"volume : number. The volume of the sound, a value between 0.0 and 1.0, inclusive (zero means silence).","title":"volume"},{"location":"engine/sound/#functions","text":"","title":"Functions"},{"location":"engine/sound/#play","text":"play() Plays the sound.","title":"play"},{"location":"engine/sound/#stop","text":"stop() Stops the sound.","title":"stop"},{"location":"engine/surgeengine/","text":"SurgeEngine The SurgeEngine plugin is the interface between SurgeScript (scripting language) and Open Surge (game engine). Example using SurgeEngine; // Open Surge version object Application { state main { Console.print(SurgeEngine.version); state = blank ; } state blank { } } Properties version version : string, read-only. Open Surge version.","title":"SurgeEngine"},{"location":"engine/surgeengine/#surgeengine","text":"The SurgeEngine plugin is the interface between SurgeScript (scripting language) and Open Surge (game engine). Example using SurgeEngine; // Open Surge version object Application { state main { Console.print(SurgeEngine.version); state = blank ; } state blank { } }","title":"SurgeEngine"},{"location":"engine/surgeengine/#properties","text":"","title":"Properties"},{"location":"engine/surgeengine/#version","text":"version : string, read-only. Open Surge version.","title":"version"},{"location":"engine/text/","text":"Text The Text object allows you to display custom texts in the game. The parent object is required to be an entity . Factory Text UI.Text(font | null) Spawns a new Text object with the given font name. If null is provided as the font name, then a default font will be used. Arguments font : string. The name of a font (defined in the fonts/ folder). Returns A Text object. Example using SurgeEngine.UI.Text; using SurgeEngine.Transform; using SurgeEngine.Player; // Place this on your level to display // the name of the player object PlayerName is entity , awake { text = Text(null); transform = Transform(); state main { // position the text player = Player.active; transform.position = player.transform.position; transform.move(0, -50); // configure the text text.align = center ; text.text = player.name; } } Properties text text : string. The text to be displayed. font font : string, read-only. The name of the font in use. align align : string. The alignment of the text. One of the following: \"left\" , \"center\" , \"right\" . visible visible : boolean. Is the Text object visible? maxlength maxlength : number. The maximum number of characters to be displayed, ignoring tags and spaces. maxWidth maxWidth : number. The maximum width of the text, in pixels. Setting this value will enable wordwrap. zindex zindex : number. The zindex of the Text object. Defaults to 0.5. offset offset : Vector2 object. An (x,y) offset relative to the parent object. Defaults to zero.","title":"Text"},{"location":"engine/text/#text","text":"The Text object allows you to display custom texts in the game. The parent object is required to be an entity .","title":"Text"},{"location":"engine/text/#factory","text":"","title":"Factory"},{"location":"engine/text/#text_1","text":"UI.Text(font | null) Spawns a new Text object with the given font name. If null is provided as the font name, then a default font will be used. Arguments font : string. The name of a font (defined in the fonts/ folder). Returns A Text object. Example using SurgeEngine.UI.Text; using SurgeEngine.Transform; using SurgeEngine.Player; // Place this on your level to display // the name of the player object PlayerName is entity , awake { text = Text(null); transform = Transform(); state main { // position the text player = Player.active; transform.position = player.transform.position; transform.move(0, -50); // configure the text text.align = center ; text.text = player.name; } }","title":"Text"},{"location":"engine/text/#properties","text":"","title":"Properties"},{"location":"engine/text/#text_2","text":"text : string. The text to be displayed.","title":"text"},{"location":"engine/text/#font","text":"font : string, read-only. The name of the font in use.","title":"font"},{"location":"engine/text/#align","text":"align : string. The alignment of the text. One of the following: \"left\" , \"center\" , \"right\" .","title":"align"},{"location":"engine/text/#visible","text":"visible : boolean. Is the Text object visible?","title":"visible"},{"location":"engine/text/#maxlength","text":"maxlength : number. The maximum number of characters to be displayed, ignoring tags and spaces.","title":"maxlength"},{"location":"engine/text/#maxwidth","text":"maxWidth : number. The maximum width of the text, in pixels. Setting this value will enable wordwrap.","title":"maxWidth"},{"location":"engine/text/#zindex","text":"zindex : number. The zindex of the Text object. Defaults to 0.5.","title":"zindex"},{"location":"engine/text/#offset","text":"offset : Vector2 object. An (x,y) offset relative to the parent object. Defaults to zero.","title":"offset"},{"location":"engine/transform/","text":"Transform Transform encapsulates a 2D Transform. It comes with functions for translating, rotating and scaling things - and it's very useful for games! Whenever you spawn a Transform on your object, you gain power to command its position, rotation and scale. The Transform component can only be spawned on entities . If an entity with a Transform component has any children, the transform of the children will be affected by the transform of their parent. Example: if you move an object, its children will be moved by the same amount. Factory Transform Transform() Spawns a Transform on the object. The object is required to be an entity . Returns A Transform object. Example using SurgeEngine.Actor; using SurgeEngine.Transform; object MyLevelObject is entity { public transform = Transform(); actor = Actor( MyLevelObject ); state main { // prints the position of this entity Console.print(transform.position); } } Properties position position : Vector2 object. The position of the object in world coordinates. Only use this property if you need to read the position of the object or to set it to a fixed value. If you need to move the entity, use move instead. Example using SurgeEngine.Actor; using SurgeEngine.Player; using SurgeEngine.Transform; object MyLevelObject is entity { public transform = Transform(); actor = Actor( MyLevelObject ); state main { // this will show the distance between // this entity and the active player player = Player.active; Console.print(distanceTo(player)); } fun distanceTo(obj) { return transform.position.distanceTo(obj.transform.position); } } angle angle : number. The angle, in degrees, specifying the rotation of the object. Unless you need to read or to set the angle of the object to a pre-determined value, consider using rotate instead. localPosition localPosition : Vector2 object. The position of the object relative to the parent object. Only use this property if you need to read the position of the object or to set it to a fixed value. If you need to move the entity, use move instead. localAngle localAngle : number. The angle, in degrees, relative to the angle of the parent object. Unless you need to read or to set the angle of the object to a pre-determined value, consider using rotate instead. localScale localScale : Vector2 object. The local scale of the entity. Functions move move(dx, dy) Moves the object by ( dx , dy ). Arguments dx : number. The amount to move the object in the x-axis. dy : number. The amount to move the object in the y-axis. Example using SurgeEngine.Actor; using SurgeEngine.Transform; object MyLevelObject is entity { public transform = Transform(); actor = Actor( MyLevelObject ); state main { // move the entity at a speed of // 50 pixels/second, to the right transform.move(50 * Time.delta, 0); // the command below would move it // at a speed of 30 pixels per FRAME //transform.move(30, 0); // don't do this // since the framerate may vary across // different systems, it's advisable // to multiply the value by Time.delta // to make the behavior consistent. } } translate translate(delta) Translates the object by a delta vector. Arguments delta : Vector2 object. rotate rotate(deg) Rotates the object by deg degrees. Arguments deg : number. Example using SurgeEngine.Actor; using SurgeEngine.Transform; object MyLevelObject is entity { public transform = Transform(); actor = Actor( MyLevelObject ); state main { // rotate the entity at a speed of // 45 degrees per second transform.rotate(45 * Time.delta); } } lookAt lookAt(transform) Use this function to make your object look at some point in space. Arguments transform : Transform object. Example using SurgeEngine.Actor; using SurgeEngine.Player; using SurgeEngine.Transform; object MyLevelObject is entity { public transform = Transform(); actor = Actor( MyLevelObject ); state main { player = Player.active; transform.lookAt(player.transform); } }","title":"Transform"},{"location":"engine/transform/#transform","text":"Transform encapsulates a 2D Transform. It comes with functions for translating, rotating and scaling things - and it's very useful for games! Whenever you spawn a Transform on your object, you gain power to command its position, rotation and scale. The Transform component can only be spawned on entities . If an entity with a Transform component has any children, the transform of the children will be affected by the transform of their parent. Example: if you move an object, its children will be moved by the same amount.","title":"Transform"},{"location":"engine/transform/#factory","text":"","title":"Factory"},{"location":"engine/transform/#transform_1","text":"Transform() Spawns a Transform on the object. The object is required to be an entity . Returns A Transform object. Example using SurgeEngine.Actor; using SurgeEngine.Transform; object MyLevelObject is entity { public transform = Transform(); actor = Actor( MyLevelObject ); state main { // prints the position of this entity Console.print(transform.position); } }","title":"Transform"},{"location":"engine/transform/#properties","text":"","title":"Properties"},{"location":"engine/transform/#position","text":"position : Vector2 object. The position of the object in world coordinates. Only use this property if you need to read the position of the object or to set it to a fixed value. If you need to move the entity, use move instead. Example using SurgeEngine.Actor; using SurgeEngine.Player; using SurgeEngine.Transform; object MyLevelObject is entity { public transform = Transform(); actor = Actor( MyLevelObject ); state main { // this will show the distance between // this entity and the active player player = Player.active; Console.print(distanceTo(player)); } fun distanceTo(obj) { return transform.position.distanceTo(obj.transform.position); } }","title":"position"},{"location":"engine/transform/#angle","text":"angle : number. The angle, in degrees, specifying the rotation of the object. Unless you need to read or to set the angle of the object to a pre-determined value, consider using rotate instead.","title":"angle"},{"location":"engine/transform/#localposition","text":"localPosition : Vector2 object. The position of the object relative to the parent object. Only use this property if you need to read the position of the object or to set it to a fixed value. If you need to move the entity, use move instead.","title":"localPosition"},{"location":"engine/transform/#localangle","text":"localAngle : number. The angle, in degrees, relative to the angle of the parent object. Unless you need to read or to set the angle of the object to a pre-determined value, consider using rotate instead.","title":"localAngle"},{"location":"engine/transform/#localscale","text":"localScale : Vector2 object. The local scale of the entity.","title":"localScale"},{"location":"engine/transform/#functions","text":"","title":"Functions"},{"location":"engine/transform/#move","text":"move(dx, dy) Moves the object by ( dx , dy ). Arguments dx : number. The amount to move the object in the x-axis. dy : number. The amount to move the object in the y-axis. Example using SurgeEngine.Actor; using SurgeEngine.Transform; object MyLevelObject is entity { public transform = Transform(); actor = Actor( MyLevelObject ); state main { // move the entity at a speed of // 50 pixels/second, to the right transform.move(50 * Time.delta, 0); // the command below would move it // at a speed of 30 pixels per FRAME //transform.move(30, 0); // don't do this // since the framerate may vary across // different systems, it's advisable // to multiply the value by Time.delta // to make the behavior consistent. } }","title":"move"},{"location":"engine/transform/#translate","text":"translate(delta) Translates the object by a delta vector. Arguments delta : Vector2 object.","title":"translate"},{"location":"engine/transform/#rotate","text":"rotate(deg) Rotates the object by deg degrees. Arguments deg : number. Example using SurgeEngine.Actor; using SurgeEngine.Transform; object MyLevelObject is entity { public transform = Transform(); actor = Actor( MyLevelObject ); state main { // rotate the entity at a speed of // 45 degrees per second transform.rotate(45 * Time.delta); } }","title":"rotate"},{"location":"engine/transform/#lookat","text":"lookAt(transform) Use this function to make your object look at some point in space. Arguments transform : Transform object. Example using SurgeEngine.Actor; using SurgeEngine.Player; using SurgeEngine.Transform; object MyLevelObject is entity { public transform = Transform(); actor = Actor( MyLevelObject ); state main { player = Player.active; transform.lookAt(player.transform); } }","title":"lookAt"},{"location":"engine/vector2/","text":"Vector2 Vector2 is a vector in 2D space. A vector is a mathematical object that has direction and length, usually represented by an arrow. A Vector2 can also be represented by a pair of (x,y) coordinates. In SurgeScript, vectors are immutable. Once created, you can't change their coordinates directly. In order to bring about change (say, in the position of an entity ), you need to create a new vector. Vector2 objects have been designed in such a way that their functions make them chainable. You can compose different vector operations using english-based terms, as in the example below: Example using SurgeEngine.Player; using SurgeEngine.Vector2; ... player = Player.active; ... l = Vector2(6, 8).scaledBy(0.5).length; // number five u = Vector2.right.rotatedBy(45).scaledBy(2); // a vector v = player.transform.position.translatedBy(5,0); // a vector ... Factory Vector2 Vector2(x, y) Spawns a 2D vector with the given coordinates. Arguments x : number. The x-coordinate of the vector. y : number. The y-coordinate of the vector. Returns A Vector2 object. Example using SurgeEngine.Vector2; using SurgeEngine.Player; // This entity will lock the player on position (100, 100) object PlayerLocker is entity , awake { pos = Vector2(100, 100); state main { player = Player.active; player.transform.position = pos; } } Vector2.up Vector2.up The unit up vector. Returns Returns the unit up vector. Vector2.right Vector2.right The unit right vector. Returns Returns the unit right vector. Vector2.down Vector2.down The unit down vector. Returns Returns the unit down vector. Vector2.left Vector2.left The unit left vector. Returns Returns the unit left vector. Vector2.zero Vector2.zero The (0,0) vector. Returns Returns the (0,0) vector. Properties x x : number, read-only. The x-coordinate of the vector. y y : number, read-only. The y-coordinate of the vector. length length : number, read-only. The length of the vector. angle angle : number, read-only. The angle, in degrees, between the vector and the positive x-axis (as in polar coordinates). Functions plus plus(v) Returns a Vector2 corresponding to the addition between this and v . Arguments v : Vector2 object. Returns Returns a Vector2 object corresponding to the result of the operation. Example a = Vector2(3, 1); b = Vector2(2, 1); c = a.plus(b); // c = (5,2) minus minus(v) Returns a Vector2 corresponding to the subtraction between this and v . Arguments v : Vector2 object. Returns Returns a Vector2 object corresponding to the result of the operation. Example v = Vector2(5, 5); zero = v.minus(v); // zero = (0,0) dot dot(v) Returns the dot product between this and v . Arguments v : Vector2 object. Returns Returns a number: the dot product between this and v . normalized normalized() Returns a normalized copy of this : the new vector will have length one. Returns Returns a Vector2 object corresponding to the result of the operation. directionTo directionTo(v) Returns a unit vector pointing to v (from this ). Arguments v : Vector2 object. Returns Returns a Vector2 of length one corresponding to the result of the operation. distanceTo distanceTo(v) Considering this and v as points in space, this function returns the distance between them. Arguments v : Vector2 object. Returns Returns a number corresponding to the specified distance. Example using SurgeEngine.Transform; using SurgeEngine.Player; // This entity will show the distance between // itself and the active player object DistanceDebugger is entity , awake { transform = Transform(); state main { player = Player.active; playerpos = player.transform.position; distance = transform.position.distanceTo(playerpos); Console.print(distance); } } translatedBy translatedBy(dx,dy) Returns a copy of this translated by (dx,dy) . Arguments dx : number. The offset to be added to the x-coordinate. dy : number. The offset to be added to the y-coordinate. Returns Returns a Vector2 object corresponding to the result of the operation. Example using SurgeEngine.Vector2; ... one = Vector2(1,1); v = one.translatedBy(4,5); // (5,6) rotatedBy rotatedBy(deg) Returns a copy of this rotated by deg degrees. Arguments deg : number. The amount of degrees used on the rotation. Returns Returns a Vector2 object corresponding to the result of the operation. Example using SurgeEngine.Vector2; ... // A unit vector with an angle of 45 degrees // (relative to the positive x-axis) v = Vector2.right.rotatedBy(45); scaledBy scaledBy(s) Returns a copy of this scaled by s . The length of the resulting vector will be the length of this multiplied by s . Arguments s : number. The multiplier. Returns Returns a Vector2 object corresponding to the result of the operation. Example using SurgeEngine.Vector2; ... one = Vector2(1,1); two = one.scaledBy(2); // (2,2) half = one.scaledBy(0.5); // (0.5,0.5) projectedOn projectedOn(v) Returns a copy of this projected on nonzero vector v . Arguments v : Vector2 object. Returns Returns a Vector2 object corresponding to the result of the operation. toString toString() Converts the vector to a string. Returns Returns a string containing the coordinates of this . Example using SurgeEngine.Vector2; ... one = Vector2(1,1); Console.print(one); // using toString() implicitly","title":"Vector2"},{"location":"engine/vector2/#vector2","text":"Vector2 is a vector in 2D space. A vector is a mathematical object that has direction and length, usually represented by an arrow. A Vector2 can also be represented by a pair of (x,y) coordinates. In SurgeScript, vectors are immutable. Once created, you can't change their coordinates directly. In order to bring about change (say, in the position of an entity ), you need to create a new vector. Vector2 objects have been designed in such a way that their functions make them chainable. You can compose different vector operations using english-based terms, as in the example below: Example using SurgeEngine.Player; using SurgeEngine.Vector2; ... player = Player.active; ... l = Vector2(6, 8).scaledBy(0.5).length; // number five u = Vector2.right.rotatedBy(45).scaledBy(2); // a vector v = player.transform.position.translatedBy(5,0); // a vector ...","title":"Vector2"},{"location":"engine/vector2/#factory","text":"","title":"Factory"},{"location":"engine/vector2/#vector2_1","text":"Vector2(x, y) Spawns a 2D vector with the given coordinates. Arguments x : number. The x-coordinate of the vector. y : number. The y-coordinate of the vector. Returns A Vector2 object. Example using SurgeEngine.Vector2; using SurgeEngine.Player; // This entity will lock the player on position (100, 100) object PlayerLocker is entity , awake { pos = Vector2(100, 100); state main { player = Player.active; player.transform.position = pos; } }","title":"Vector2"},{"location":"engine/vector2/#vector2up","text":"Vector2.up The unit up vector. Returns Returns the unit up vector.","title":"Vector2.up"},{"location":"engine/vector2/#vector2right","text":"Vector2.right The unit right vector. Returns Returns the unit right vector.","title":"Vector2.right"},{"location":"engine/vector2/#vector2down","text":"Vector2.down The unit down vector. Returns Returns the unit down vector.","title":"Vector2.down"},{"location":"engine/vector2/#vector2left","text":"Vector2.left The unit left vector. Returns Returns the unit left vector.","title":"Vector2.left"},{"location":"engine/vector2/#vector2zero","text":"Vector2.zero The (0,0) vector. Returns Returns the (0,0) vector.","title":"Vector2.zero"},{"location":"engine/vector2/#properties","text":"","title":"Properties"},{"location":"engine/vector2/#x","text":"x : number, read-only. The x-coordinate of the vector.","title":"x"},{"location":"engine/vector2/#y","text":"y : number, read-only. The y-coordinate of the vector.","title":"y"},{"location":"engine/vector2/#length","text":"length : number, read-only. The length of the vector.","title":"length"},{"location":"engine/vector2/#angle","text":"angle : number, read-only. The angle, in degrees, between the vector and the positive x-axis (as in polar coordinates).","title":"angle"},{"location":"engine/vector2/#functions","text":"","title":"Functions"},{"location":"engine/vector2/#plus","text":"plus(v) Returns a Vector2 corresponding to the addition between this and v . Arguments v : Vector2 object. Returns Returns a Vector2 object corresponding to the result of the operation. Example a = Vector2(3, 1); b = Vector2(2, 1); c = a.plus(b); // c = (5,2)","title":"plus"},{"location":"engine/vector2/#minus","text":"minus(v) Returns a Vector2 corresponding to the subtraction between this and v . Arguments v : Vector2 object. Returns Returns a Vector2 object corresponding to the result of the operation. Example v = Vector2(5, 5); zero = v.minus(v); // zero = (0,0)","title":"minus"},{"location":"engine/vector2/#dot","text":"dot(v) Returns the dot product between this and v . Arguments v : Vector2 object. Returns Returns a number: the dot product between this and v .","title":"dot"},{"location":"engine/vector2/#normalized","text":"normalized() Returns a normalized copy of this : the new vector will have length one. Returns Returns a Vector2 object corresponding to the result of the operation.","title":"normalized"},{"location":"engine/vector2/#directionto","text":"directionTo(v) Returns a unit vector pointing to v (from this ). Arguments v : Vector2 object. Returns Returns a Vector2 of length one corresponding to the result of the operation.","title":"directionTo"},{"location":"engine/vector2/#distanceto","text":"distanceTo(v) Considering this and v as points in space, this function returns the distance between them. Arguments v : Vector2 object. Returns Returns a number corresponding to the specified distance. Example using SurgeEngine.Transform; using SurgeEngine.Player; // This entity will show the distance between // itself and the active player object DistanceDebugger is entity , awake { transform = Transform(); state main { player = Player.active; playerpos = player.transform.position; distance = transform.position.distanceTo(playerpos); Console.print(distance); } }","title":"distanceTo"},{"location":"engine/vector2/#translatedby","text":"translatedBy(dx,dy) Returns a copy of this translated by (dx,dy) . Arguments dx : number. The offset to be added to the x-coordinate. dy : number. The offset to be added to the y-coordinate. Returns Returns a Vector2 object corresponding to the result of the operation. Example using SurgeEngine.Vector2; ... one = Vector2(1,1); v = one.translatedBy(4,5); // (5,6)","title":"translatedBy"},{"location":"engine/vector2/#rotatedby","text":"rotatedBy(deg) Returns a copy of this rotated by deg degrees. Arguments deg : number. The amount of degrees used on the rotation. Returns Returns a Vector2 object corresponding to the result of the operation. Example using SurgeEngine.Vector2; ... // A unit vector with an angle of 45 degrees // (relative to the positive x-axis) v = Vector2.right.rotatedBy(45);","title":"rotatedBy"},{"location":"engine/vector2/#scaledby","text":"scaledBy(s) Returns a copy of this scaled by s . The length of the resulting vector will be the length of this multiplied by s . Arguments s : number. The multiplier. Returns Returns a Vector2 object corresponding to the result of the operation. Example using SurgeEngine.Vector2; ... one = Vector2(1,1); two = one.scaledBy(2); // (2,2) half = one.scaledBy(0.5); // (0.5,0.5)","title":"scaledBy"},{"location":"engine/vector2/#projectedon","text":"projectedOn(v) Returns a copy of this projected on nonzero vector v . Arguments v : Vector2 object. Returns Returns a Vector2 object corresponding to the result of the operation.","title":"projectedOn"},{"location":"engine/vector2/#tostring","text":"toString() Converts the vector to a string. Returns Returns a string containing the coordinates of this . Example using SurgeEngine.Vector2; ... one = Vector2(1,1); Console.print(one); // using toString() implicitly","title":"toString"},{"location":"engine/web/","text":"Web Web routines. Functions launchURL launchURL(url) Launches a URL using the default web browser. It's mandatory to specify a protocol. The following protocols are currently supported: http:// , https:// , mailto: Arguments url : string. The URL to be launched. Example using SurgeEngine.Web; object Application { // Remember to change the state // after calling launchURL state main { Web.launchURL( http://opensurge2d.org ); state = done ; } state done { } }","title":"Web"},{"location":"engine/web/#web","text":"Web routines.","title":"Web"},{"location":"engine/web/#functions","text":"","title":"Functions"},{"location":"engine/web/#launchurl","text":"launchURL(url) Launches a URL using the default web browser. It's mandatory to specify a protocol. The following protocols are currently supported: http:// , https:// , mailto: Arguments url : string. The URL to be launched. Example using SurgeEngine.Web; object Application { // Remember to change the state // after calling launchURL state main { Web.launchURL( http://opensurge2d.org ); state = done ; } state done { } }","title":"launchURL"},{"location":"reference/application/","text":"Application Represents the Application. You do not need to instantiate it, as it is instantiated automatically. This object can be accessed by any other object, in any script, simply by typing Application . Properties args args : Arguments object, read-only. Use this property to read the command line arguments. Functions exit exit() Exits the Application. crash crash(message) Exits the Application with an error message. Arguments message : string. The message to be displayed to the user. destroy destroy() A synonym for Application.exit() .","title":"Application"},{"location":"reference/application/#application","text":"Represents the Application. You do not need to instantiate it, as it is instantiated automatically. This object can be accessed by any other object, in any script, simply by typing Application .","title":"Application"},{"location":"reference/application/#properties","text":"","title":"Properties"},{"location":"reference/application/#args","text":"args : Arguments object, read-only. Use this property to read the command line arguments.","title":"args"},{"location":"reference/application/#functions","text":"","title":"Functions"},{"location":"reference/application/#exit","text":"exit() Exits the Application.","title":"exit"},{"location":"reference/application/#crash","text":"crash(message) Exits the Application with an error message. Arguments message : string. The message to be displayed to the user.","title":"crash"},{"location":"reference/application/#destroy","text":"destroy() A synonym for Application.exit() .","title":"destroy"},{"location":"reference/arguments/","text":"Arguments If you've launched your application via the command-line, this Array-like object can be used to read command-line arguments. This is available at Application.args . The example below prints all the arguments to the screen: // Method 1 (foreach) foreach(argument in Application.args) Console.print(argument); // Method 2 (for loops) for(i = 0; i Application.args.length; i++) Console.print(Application.args[i]); // Or, alternatively: Console.print(Application.args); Properties length length : number, read-only. The number of command-line arguments, including the executable. Functions get get(index) Gets the specified command-line argument. Instead of calling get() , one may use equivalently the [ ] operator. Arguments index : integer number between 0 and Application.args.length - 1 , inclusive. Returns A string with the specified command-line argument, or null if there is no such argument. Example // Suppose that you run surgescript via the command-line: // surgescript test_args.ss executable = Application.args[0]; // surgescript script_file = Application.args[1]; // test_args.ss option option(optionName) Gets the value of a certain command-line option. Arguments optionName : string. The option you want to read. Returns A string featuring the value of the desired command-line option, or null if such an option hasn't been provided by the user. Example // Suppose that you run surgescript via the command-line: // surgescript test_args.ss --my-option 12345 my_option = Application.args.option( --my-option ); // Options -p and --port are equivalent // surgescript test_args.ss -p 80 // surgescript test_args.ss --port 80 port = Application.args.option( --port ) || Application.args.option( -p ); // Default values (useful if the option is not present) // surgescript test_args.ss // surgescript test_args.ss --name alice name = Application.args.option( --name ) || anonymous ; hasOption hasOption(optionName) Checks if the specified option is present in the command-line. Arguments optionName : string. Returns Returns true if the specified option is present in the command-line; or false otherwise. iterator iterator() Spawns an iterator. Returns An iterator to loop through the command-line arguments. toString toString() Converts the command-line arguments to a string. Returns A string featuring the command-line arguments.","title":"Arguments"},{"location":"reference/arguments/#arguments","text":"If you've launched your application via the command-line, this Array-like object can be used to read command-line arguments. This is available at Application.args . The example below prints all the arguments to the screen: // Method 1 (foreach) foreach(argument in Application.args) Console.print(argument); // Method 2 (for loops) for(i = 0; i Application.args.length; i++) Console.print(Application.args[i]); // Or, alternatively: Console.print(Application.args);","title":"Arguments"},{"location":"reference/arguments/#properties","text":"","title":"Properties"},{"location":"reference/arguments/#length","text":"length : number, read-only. The number of command-line arguments, including the executable.","title":"length"},{"location":"reference/arguments/#functions","text":"","title":"Functions"},{"location":"reference/arguments/#get","text":"get(index) Gets the specified command-line argument. Instead of calling get() , one may use equivalently the [ ] operator. Arguments index : integer number between 0 and Application.args.length - 1 , inclusive. Returns A string with the specified command-line argument, or null if there is no such argument. Example // Suppose that you run surgescript via the command-line: // surgescript test_args.ss executable = Application.args[0]; // surgescript script_file = Application.args[1]; // test_args.ss","title":"get"},{"location":"reference/arguments/#option","text":"option(optionName) Gets the value of a certain command-line option. Arguments optionName : string. The option you want to read. Returns A string featuring the value of the desired command-line option, or null if such an option hasn't been provided by the user. Example // Suppose that you run surgescript via the command-line: // surgescript test_args.ss --my-option 12345 my_option = Application.args.option( --my-option ); // Options -p and --port are equivalent // surgescript test_args.ss -p 80 // surgescript test_args.ss --port 80 port = Application.args.option( --port ) || Application.args.option( -p ); // Default values (useful if the option is not present) // surgescript test_args.ss // surgescript test_args.ss --name alice name = Application.args.option( --name ) || anonymous ;","title":"option"},{"location":"reference/arguments/#hasoption","text":"hasOption(optionName) Checks if the specified option is present in the command-line. Arguments optionName : string. Returns Returns true if the specified option is present in the command-line; or false otherwise.","title":"hasOption"},{"location":"reference/arguments/#iterator","text":"iterator() Spawns an iterator. Returns An iterator to loop through the command-line arguments.","title":"iterator"},{"location":"reference/arguments/#tostring","text":"toString() Converts the command-line arguments to a string. Returns A string featuring the command-line arguments.","title":"toString"},{"location":"reference/array/","text":"Array An Array is a collection of values organized in sequencial fashion. To instantiate an Array, use the [ value_1, value_2, ..., value_n ] syntax rather than the spawn() function. Example: object Application { // The 'characters' array hold 3 strings characters = [ Surge , Neon , Charge ]; state main { // who are the characters? Console.print( The characters are: ); Console.print(characters[0]); Console.print(characters[1]); Console.print(characters[2]); // how many characters? Console.print( Number of characters: + characters.length); } } Output: The characters are: Surge Neon Charge Number of characters: 3 Note: Whenever you define a array, you spawn a new object. One is advised to NOT define arrays within states, because the code within states run continuously. Therefore, new objects will be created at every frame, not just once. Properties length length : number, read-only. The number of elements in the Array. Functions get get(index) Gets the specified element of the Array. Instead of calling get() directly, you may equivalently use the [ ] operator. Arguments index : integer number between 0 and this.length - 1 , inclusive. Returns The Array element at position index (0-based). Example characters = [ Surge , Neon , Charge ]; ... surge = characters[0]; // first element ( Surge ) neon = characters[1]; // second element ( Neon ) charge = characters[2]; // third element ( Charge ) set set(index, value) Sets to value the element of the Array at position index . Instead of calling set() directly, you may equivalently use the [ ] operator. Arguments index : integer number between 0 and this.length - 1 , inclusive. value : any type. The new value to be placed on the Array. Example characters = [ Surge , Neon , Charge ]; characters[0] = Gimacian ; Console.print(characters[0]); // Gimacian push push(value) Adds a new element to the end of the Array. Arguments value : any type. The element to be added to the Array. Example characters = [ Surge , Neon , Charge ]; characters.push( Gimacian ); Console.print(characters); // [ Surge , Neon , Charge , Gimacian ] pop pop() Removes the last element of the Array and returns it. Returns The removed element. shift shift() Removes the first element of the Array and returns it. Returns The removed element. unshift unshift(value) Adds a new element to the beginning of the Array. Arguments value : any type. The element to be added to the Array. clear clear() Clears the array. It will no longer hold any elements and its length will be set to zero. Available since: SurgeScript 0.5.3 indexOf indexOf(value) Search the Array for element value and return its position. Arguments value : any type. The element to be searched for. Returns The position of the searched element - a number between 0 and this.length - 1 , inclusive. If the desired element is not found, this function returns -1 . Example characters = [ Surge , Neon , Charge ]; ... two = characters.indexOf( Neon ); // 2 gimacian = characters.indexOf( Gimacian ); // -1 if(gimacian 0) Console.print( Not found ); sort sort(cmpFun) Sorts the Array. If no comparison functor is provided ( cmpFun is null ), the Array will be sorted in ascending order. Arguments cmpFun : object | null. This functor implements function call(a, b) that compares two array elements as described in the example below. Returns The sorted array. The returned array is the same array as you called sort() on; it's not a copy. Example // this example will print the elements // of the Array in ascending order object Application { arr = [ 3, 9, 4, 8, 5, 6, 7, 1, 2, 0 ]; state main { // sort and print the Array arr.sort(null); Console.print(arr); Application.exit(); } } Output: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ] // this example will print the elements // of the Array in descending order object Application { arr = [ 3, 9, 4, 8, 5, 6, 7, 1, 2, 0 ]; cmp = spawn( Sort.OrderByDesc ); state main { // sort and print the Array arr.sort(cmp); Console.print(arr); Application.exit(); } } object Sort.OrderByDesc { // This function compares two // elements of the Array: a and b. // // It should return a number: // 0 if a must come BEFORE b // = 0 if a and b are equivalent // 0 if a must come AFTER b fun call(a, b) { // sort in descending order return b - a; } } Output: [ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ] reverse reverse() Reverses the order of the elements in the Array. shuffle shuffle() Shuffles the elements of the Array, placing its elements at random spots. iterator iterator() Spawns an iterator. Returns An iterator to loop through the elements of the Array. toString toString() Converts the Array to a string. Returns A string.","title":"Array"},{"location":"reference/array/#array","text":"An Array is a collection of values organized in sequencial fashion. To instantiate an Array, use the [ value_1, value_2, ..., value_n ] syntax rather than the spawn() function. Example: object Application { // The 'characters' array hold 3 strings characters = [ Surge , Neon , Charge ]; state main { // who are the characters? Console.print( The characters are: ); Console.print(characters[0]); Console.print(characters[1]); Console.print(characters[2]); // how many characters? Console.print( Number of characters: + characters.length); } } Output: The characters are: Surge Neon Charge Number of characters: 3 Note: Whenever you define a array, you spawn a new object. One is advised to NOT define arrays within states, because the code within states run continuously. Therefore, new objects will be created at every frame, not just once.","title":"Array"},{"location":"reference/array/#properties","text":"","title":"Properties"},{"location":"reference/array/#length","text":"length : number, read-only. The number of elements in the Array.","title":"length"},{"location":"reference/array/#functions","text":"","title":"Functions"},{"location":"reference/array/#get","text":"get(index) Gets the specified element of the Array. Instead of calling get() directly, you may equivalently use the [ ] operator. Arguments index : integer number between 0 and this.length - 1 , inclusive. Returns The Array element at position index (0-based). Example characters = [ Surge , Neon , Charge ]; ... surge = characters[0]; // first element ( Surge ) neon = characters[1]; // second element ( Neon ) charge = characters[2]; // third element ( Charge )","title":"get"},{"location":"reference/array/#set","text":"set(index, value) Sets to value the element of the Array at position index . Instead of calling set() directly, you may equivalently use the [ ] operator. Arguments index : integer number between 0 and this.length - 1 , inclusive. value : any type. The new value to be placed on the Array. Example characters = [ Surge , Neon , Charge ]; characters[0] = Gimacian ; Console.print(characters[0]); // Gimacian","title":"set"},{"location":"reference/array/#push","text":"push(value) Adds a new element to the end of the Array. Arguments value : any type. The element to be added to the Array. Example characters = [ Surge , Neon , Charge ]; characters.push( Gimacian ); Console.print(characters); // [ Surge , Neon , Charge , Gimacian ]","title":"push"},{"location":"reference/array/#pop","text":"pop() Removes the last element of the Array and returns it. Returns The removed element.","title":"pop"},{"location":"reference/array/#shift","text":"shift() Removes the first element of the Array and returns it. Returns The removed element.","title":"shift"},{"location":"reference/array/#unshift","text":"unshift(value) Adds a new element to the beginning of the Array. Arguments value : any type. The element to be added to the Array.","title":"unshift"},{"location":"reference/array/#clear","text":"clear() Clears the array. It will no longer hold any elements and its length will be set to zero. Available since: SurgeScript 0.5.3","title":"clear"},{"location":"reference/array/#indexof","text":"indexOf(value) Search the Array for element value and return its position. Arguments value : any type. The element to be searched for. Returns The position of the searched element - a number between 0 and this.length - 1 , inclusive. If the desired element is not found, this function returns -1 . Example characters = [ Surge , Neon , Charge ]; ... two = characters.indexOf( Neon ); // 2 gimacian = characters.indexOf( Gimacian ); // -1 if(gimacian 0) Console.print( Not found );","title":"indexOf"},{"location":"reference/array/#sort","text":"sort(cmpFun) Sorts the Array. If no comparison functor is provided ( cmpFun is null ), the Array will be sorted in ascending order. Arguments cmpFun : object | null. This functor implements function call(a, b) that compares two array elements as described in the example below. Returns The sorted array. The returned array is the same array as you called sort() on; it's not a copy. Example // this example will print the elements // of the Array in ascending order object Application { arr = [ 3, 9, 4, 8, 5, 6, 7, 1, 2, 0 ]; state main { // sort and print the Array arr.sort(null); Console.print(arr); Application.exit(); } } Output: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ] // this example will print the elements // of the Array in descending order object Application { arr = [ 3, 9, 4, 8, 5, 6, 7, 1, 2, 0 ]; cmp = spawn( Sort.OrderByDesc ); state main { // sort and print the Array arr.sort(cmp); Console.print(arr); Application.exit(); } } object Sort.OrderByDesc { // This function compares two // elements of the Array: a and b. // // It should return a number: // 0 if a must come BEFORE b // = 0 if a and b are equivalent // 0 if a must come AFTER b fun call(a, b) { // sort in descending order return b - a; } } Output: [ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ]","title":"sort"},{"location":"reference/array/#reverse","text":"reverse() Reverses the order of the elements in the Array.","title":"reverse"},{"location":"reference/array/#shuffle","text":"shuffle() Shuffles the elements of the Array, placing its elements at random spots.","title":"shuffle"},{"location":"reference/array/#iterator","text":"iterator() Spawns an iterator. Returns An iterator to loop through the elements of the Array.","title":"iterator"},{"location":"reference/array/#tostring","text":"toString() Converts the Array to a string. Returns A string.","title":"toString"},{"location":"reference/boolean/","text":"Boolean Routines for booleans. The Boolean object is not supposed to be used directly. The functions below are available for primitive values of the boolean type. Functions valueOf valueOf() The primitive value of the boolean, i.e., the boolean itself. Returns The boolean. toString toString() Convert boolean to string. Returns The boolean converted to a string. equals equals(b) Compares the boolean to another boolean b . Arguments b : boolean. The value to compare the boolean to. Returns Returns true if the booleans are equal.","title":"Boolean"},{"location":"reference/boolean/#boolean","text":"Routines for booleans. The Boolean object is not supposed to be used directly. The functions below are available for primitive values of the boolean type.","title":"Boolean"},{"location":"reference/boolean/#functions","text":"","title":"Functions"},{"location":"reference/boolean/#valueof","text":"valueOf() The primitive value of the boolean, i.e., the boolean itself. Returns The boolean.","title":"valueOf"},{"location":"reference/boolean/#tostring","text":"toString() Convert boolean to string. Returns The boolean converted to a string.","title":"toString"},{"location":"reference/boolean/#equals","text":"equals(b) Compares the boolean to another boolean b . Arguments b : boolean. The value to compare the boolean to. Returns Returns true if the booleans are equal.","title":"equals"},{"location":"reference/console/","text":"Console The Console is a mechanism that allows users to interact with your app via a text-based interface. You can print data to the user and read data from the user. Functions print print(line) Prints a line to the console. Arguments line : string. The message to be printed. Example // this will print Hello, there! and quit object Application { state main { Console.print( Hello, there! ); Application.exit(); } } write write(str) Writes a string to the console, without a line break at the end. Arguments str : string. The string to be written. readline readline() Reads a line from the standard input. Returns Returns the string just read, without a line break at the end. Example // will ask the name of the user until a name is given object Application { state main { Console.print( Hey pal, what's your name? ); name = Console.readline(); if(name != ) { Console.print( Nice to meet you, + name); Application.exit(); } } }","title":"Console"},{"location":"reference/console/#console","text":"The Console is a mechanism that allows users to interact with your app via a text-based interface. You can print data to the user and read data from the user.","title":"Console"},{"location":"reference/console/#functions","text":"","title":"Functions"},{"location":"reference/console/#print","text":"print(line) Prints a line to the console. Arguments line : string. The message to be printed. Example // this will print Hello, there! and quit object Application { state main { Console.print( Hello, there! ); Application.exit(); } }","title":"print"},{"location":"reference/console/#write","text":"write(str) Writes a string to the console, without a line break at the end. Arguments str : string. The string to be written.","title":"write"},{"location":"reference/console/#readline","text":"readline() Reads a line from the standard input. Returns Returns the string just read, without a line break at the end. Example // will ask the name of the user until a name is given object Application { state main { Console.print( Hey pal, what's your name? ); name = Console.readline(); if(name != ) { Console.print( Nice to meet you, + name); Application.exit(); } } }","title":"readline"},{"location":"reference/date/","text":"Date Date is used to retrieve current date and time. You can access this object simply by typing Date . Example: // What day is today? object Application { // show the day state main { today = Date.year + - + f(Date.month) + - + f(Date.day); Console.print( Today is + today); Application.exit(); } // add a leading zero fun f(x) { if(x = 10) return x; else return 0 + x; } } Available since: SurgeScript 0.5.2 Properties year year : number, read-only. The current year. month month : number, read-only. Month of the year (1-12). day day : number. Day of the month (1-31). hour hour : number. Hours since midnight (0-23). minute minute : number. Minutes after the hour (0-59). second second : number. Seconds after the minute (0-59). weekday weekday : number. Days since Sunday (0-6). unixtime unixtime : number. Number of seconds since Jan 1st, 1970 00:00:00 UTC. Functions timezoneOffset timezoneOffset() The difference, in minutes, from the Coordinated Universal Time (UTC) to the timezone of the host. Example: if your timezone is UTC-03:00, this function returns -180. Available since: SurgeScript 0.5.2 Returns The timezone difference in minutes. toString toString() Converts the current date and time to a string. The string is formatted according to the ISO 8601 standard. Available since: SurgeScript 0.5.2 Returns The current date and time expressed according to ISO 8601.","title":"Date"},{"location":"reference/date/#date","text":"Date is used to retrieve current date and time. You can access this object simply by typing Date . Example: // What day is today? object Application { // show the day state main { today = Date.year + - + f(Date.month) + - + f(Date.day); Console.print( Today is + today); Application.exit(); } // add a leading zero fun f(x) { if(x = 10) return x; else return 0 + x; } } Available since: SurgeScript 0.5.2","title":"Date"},{"location":"reference/date/#properties","text":"","title":"Properties"},{"location":"reference/date/#year","text":"year : number, read-only. The current year.","title":"year"},{"location":"reference/date/#month","text":"month : number, read-only. Month of the year (1-12).","title":"month"},{"location":"reference/date/#day","text":"day : number. Day of the month (1-31).","title":"day"},{"location":"reference/date/#hour","text":"hour : number. Hours since midnight (0-23).","title":"hour"},{"location":"reference/date/#minute","text":"minute : number. Minutes after the hour (0-59).","title":"minute"},{"location":"reference/date/#second","text":"second : number. Seconds after the minute (0-59).","title":"second"},{"location":"reference/date/#weekday","text":"weekday : number. Days since Sunday (0-6).","title":"weekday"},{"location":"reference/date/#unixtime","text":"unixtime : number. Number of seconds since Jan 1st, 1970 00:00:00 UTC.","title":"unixtime"},{"location":"reference/date/#functions","text":"","title":"Functions"},{"location":"reference/date/#timezoneoffset","text":"timezoneOffset() The difference, in minutes, from the Coordinated Universal Time (UTC) to the timezone of the host. Example: if your timezone is UTC-03:00, this function returns -180. Available since: SurgeScript 0.5.2 Returns The timezone difference in minutes.","title":"timezoneOffset"},{"location":"reference/date/#tostring","text":"toString() Converts the current date and time to a string. The string is formatted according to the ISO 8601 standard. Available since: SurgeScript 0.5.2 Returns The current date and time expressed according to ISO 8601.","title":"toString"},{"location":"reference/dictionary/","text":"Dictionary A Dictionary is a collection of key-value pairs. Dictionary keys are strings. Their corresponding values can be of any type. To create a Dictionary, use the { key_1: value_1, key_2: value_2, ..., key_n: value_n } syntax rather than the spawn() function. Example: object Application { dictionary = { Surge : 35, Neon : 20, Charge : 37.5, Gimacian : 70 }; state main { // usage example Console.print(dictionary[ Surge ]); // will print 35 Console.print(dictionary[ Neon ]); // will print 20 // will print all entries foreach(entry in dictionary) Console.print(entry.key + : + entry.value); // done! Application.exit(); } } Output: 35 20 Surge: 35 Neon: 20 Charge: 37.5 Gimacian: 70 Note: Whenever you define a dictionary, you spawn a new object. One is advised to NOT define dictionaries within states, because the code within states run continuously. Therefore, new objects will be created at every frame of the application, not just once. Properties count count : number, read-only. The number of elements in the Dictionary. Functions get get(key) Gets the value of the specified key in the Dictionary. Instead of calling get() directly, you may equivalently use the [ ] operator. Arguments key : string. Returns The value corresponding to the specified key, or null if there is no such an entry in the Dictionary. Example dict = { Surge : 10 }; ten = dict[ Surge ]; set set(key, value) Sets the value of the specified key in the Dictionary. Instead of calling set() directly, you may equivalently use the [ ] operator. Arguments key : string. value : any type. Example dict = { }; dict[ Surge ] = 10; clear clear() Removes all entries from the Dictionary. delete delete(key) Deletes the entry having the specified key. Arguments key : string. The key of the entry to be removed. has has(key) Checks if an entry having the specified key belongs to the Dictionary. Arguments key : string. The key of the entry. Returns Returns true if the Dictionary has such an entry. keys keys() Gets a collection containing the keys of the Dictionary. Returns Returns a new Array containing the keys of the Dictionary. iterator iterator() Spawns an iterator. Returns An iterator to loop through the elements of the Dictionary. toString toString() Converts the Dictionary to a string. Returns A string.","title":"Dictionary"},{"location":"reference/dictionary/#dictionary","text":"A Dictionary is a collection of key-value pairs. Dictionary keys are strings. Their corresponding values can be of any type. To create a Dictionary, use the { key_1: value_1, key_2: value_2, ..., key_n: value_n } syntax rather than the spawn() function. Example: object Application { dictionary = { Surge : 35, Neon : 20, Charge : 37.5, Gimacian : 70 }; state main { // usage example Console.print(dictionary[ Surge ]); // will print 35 Console.print(dictionary[ Neon ]); // will print 20 // will print all entries foreach(entry in dictionary) Console.print(entry.key + : + entry.value); // done! Application.exit(); } } Output: 35 20 Surge: 35 Neon: 20 Charge: 37.5 Gimacian: 70 Note: Whenever you define a dictionary, you spawn a new object. One is advised to NOT define dictionaries within states, because the code within states run continuously. Therefore, new objects will be created at every frame of the application, not just once.","title":"Dictionary"},{"location":"reference/dictionary/#properties","text":"","title":"Properties"},{"location":"reference/dictionary/#count","text":"count : number, read-only. The number of elements in the Dictionary.","title":"count"},{"location":"reference/dictionary/#functions","text":"","title":"Functions"},{"location":"reference/dictionary/#get","text":"get(key) Gets the value of the specified key in the Dictionary. Instead of calling get() directly, you may equivalently use the [ ] operator. Arguments key : string. Returns The value corresponding to the specified key, or null if there is no such an entry in the Dictionary. Example dict = { Surge : 10 }; ten = dict[ Surge ];","title":"get"},{"location":"reference/dictionary/#set","text":"set(key, value) Sets the value of the specified key in the Dictionary. Instead of calling set() directly, you may equivalently use the [ ] operator. Arguments key : string. value : any type. Example dict = { }; dict[ Surge ] = 10;","title":"set"},{"location":"reference/dictionary/#clear","text":"clear() Removes all entries from the Dictionary.","title":"clear"},{"location":"reference/dictionary/#delete","text":"delete(key) Deletes the entry having the specified key. Arguments key : string. The key of the entry to be removed.","title":"delete"},{"location":"reference/dictionary/#has","text":"has(key) Checks if an entry having the specified key belongs to the Dictionary. Arguments key : string. The key of the entry. Returns Returns true if the Dictionary has such an entry.","title":"has"},{"location":"reference/dictionary/#keys","text":"keys() Gets a collection containing the keys of the Dictionary. Returns Returns a new Array containing the keys of the Dictionary.","title":"keys"},{"location":"reference/dictionary/#iterator","text":"iterator() Spawns an iterator. Returns An iterator to loop through the elements of the Dictionary.","title":"iterator"},{"location":"reference/dictionary/#tostring","text":"toString() Converts the Dictionary to a string. Returns A string.","title":"toString"},{"location":"reference/gc/","text":"GC SurgeScript features a Garbage Collector (GC) that automatically disposes objects that cannot be reached from the root (i.e., their references are lost). The Garbage Collector is available at System.gc . Generally, you do not need to modify any of its settings. Properties interval interval : number. Every interval seconds, the garbage collector will be called automatically. objectCount objectCount : number, read-only. How many objects were disposed when the garbage collector was last called. Functions collect collect() Calls the Garbage Collector manually.","title":"GC"},{"location":"reference/gc/#gc","text":"SurgeScript features a Garbage Collector (GC) that automatically disposes objects that cannot be reached from the root (i.e., their references are lost). The Garbage Collector is available at System.gc . Generally, you do not need to modify any of its settings.","title":"GC"},{"location":"reference/gc/#properties","text":"","title":"Properties"},{"location":"reference/gc/#interval","text":"interval : number. Every interval seconds, the garbage collector will be called automatically.","title":"interval"},{"location":"reference/gc/#objectcount","text":"objectCount : number, read-only. How many objects were disposed when the garbage collector was last called.","title":"objectCount"},{"location":"reference/gc/#functions","text":"","title":"Functions"},{"location":"reference/gc/#collect","text":"collect() Calls the Garbage Collector manually.","title":"collect"},{"location":"reference/iterator/","text":"Iterator In SurgeScript, Iterator is an abstract contract, or protocol, that define a set of functions that should be written in concrete implementations. If you're familiar with object oriented programming, Iterator is an interface. Iterators are used to traverse containers / collections / data structures and access its elements. Concrete implementations of Iterator include: ArrayIterator and DictionaryIterator . If you wish to write your own iterators , you need to specify the functions described below . The data structure that you wish to traverse should include an iterator() function that spawns the concrete implementation of the Iterator. Thus, the parent object of the Iterator will be the structure to be traversed. The basic usage of an Iterator is as follows: // container is an object such as an Array iterator = container.iterator(); // spawn an iterator to traverse the container while(iterator.hasNext()) { element = iterator.next(); Console.print(element); } Functions hasNext hasNext() Checks if there are more elements to be accessed in the iteration. Returns Returns true if there are more elements to be visited, or false otherwise. next next() Gets the next element of the container and advances the iteration. Returns The next element of the container, or null if there is no such element. The first call to next() returns the first element of the container, and so on.","title":"Iterator"},{"location":"reference/iterator/#iterator","text":"In SurgeScript, Iterator is an abstract contract, or protocol, that define a set of functions that should be written in concrete implementations. If you're familiar with object oriented programming, Iterator is an interface. Iterators are used to traverse containers / collections / data structures and access its elements. Concrete implementations of Iterator include: ArrayIterator and DictionaryIterator . If you wish to write your own iterators , you need to specify the functions described below . The data structure that you wish to traverse should include an iterator() function that spawns the concrete implementation of the Iterator. Thus, the parent object of the Iterator will be the structure to be traversed. The basic usage of an Iterator is as follows: // container is an object such as an Array iterator = container.iterator(); // spawn an iterator to traverse the container while(iterator.hasNext()) { element = iterator.next(); Console.print(element); }","title":"Iterator"},{"location":"reference/iterator/#functions","text":"","title":"Functions"},{"location":"reference/iterator/#hasnext","text":"hasNext() Checks if there are more elements to be accessed in the iteration. Returns Returns true if there are more elements to be visited, or false otherwise.","title":"hasNext"},{"location":"reference/iterator/#next","text":"next() Gets the next element of the container and advances the iteration. Returns The next element of the container, or null if there is no such element. The first call to next() returns the first element of the container, and so on.","title":"next"},{"location":"reference/math/","text":"Math Built-in mathematical functions. The Math object can be accessed simply by typing Math . Examples: // Math functions two = Math.sqrt(4); // square root of 4 eight = Math.pow(2, 3); // 2 raised to the 3rd power zero = Math.sin(0); // sine of 0 seven = Math.max(5, 7); // maximum of 5 and 7 Properties pi pi : number, read-only. An approximation of pi (3.1415926535...) epsilon epsilon : number, read-only. The difference between 1 and the smallest floating point number that is greater than 1. infinity infinity : number, read-only. A floating point representation of positive infinity. NaN NaN : number, read-only. A numeric data type representing Not-a-Number. Available since: SurgeScript 0.5.3 Functions sqrt sqrt(x) Square root function. Arguments x : number. Returns The square root of x . pow pow(x, p) Raise to power. Arguments x : number. The base. p : number. The exponent. Returns Returns x raised to the p power. exp e(x) Exponential function. Arguments x : number. Returns Returns e raised to the x power. log log(x) Natural logarithm. Arguments x : number. Returns The natural logarithm (base e ) of x . log10 log10(x) Base 10 logarithm. Arguments x : number. Returns The base 10 logarithm of x . sin sin(x) Sine function. Arguments x : number. Angle in radians. Returns The sine of x . cos cos(x) Cosine function. Arguments x : number. Angle in radians. Returns The cosine of x . tan tan(x) Tangent function. Arguments x : number. Angle in radians. Returns The tangent of x . asin asin(x) Arc-sine function. Arguments x : number. Returns The angle in radians whose sine is x . acos acos(x) Arc-cosine function. Arguments x : number. Returns The angle in radians whose cosine is x . atan atan(x) Arc-tangent function. Arguments x : number. Returns The angle in radians whose tangent is x . atan2 atan2(y, x) Function atan2. Arguments y : number. x : number. Returns The angle, in radians, between the positive x-axis and the (x, y) vector. deg2rad deg2rad(degrees) Converts degrees to radians. Available since: SurgeScript 0.5.3 Arguments degrees : number. Returns The converted value. rad2deg rad2deg(radians) Converts radians to degrees. Available since: SurgeScript 0.5.3 Arguments radians : number. Returns The converted value. random random() Random value. Returns A random number between 0 (inclusive) and 1 (exclusive). floor floor(x) Floor function. Arguments x : number. Returns The largest integer less or equal than x . ceil ceil(x) Ceiling function. Arguments x : number. Returns The smallest integer greater or equal than x . round round(x) Round to the nearest integer. Arguments x : number. Returns Returns x rounded to the nearest integer. If the fraction of x is 0.5, this function uses the commercial rounding tie-breaking method. mod mod(x, y) Modulus function. Used to get the remainder of a division. Deprecated since SurgeScript 0.5.3. Use the remainder operator (%) instead, e.g. x % y . Arguments x : number. y : number. Returns The remainder of x / y . sign sign(x) The sign of x . Arguments x : number. Returns Returns 1 if x is positive or zero; or -1 if x is negative. abs abs(x) Absolute value of x . Arguments x : number. Returns Returns -x if x is negative, or x otherwise. min min(x, y) The minimum of two values. Arguments x : number. y : number. Returns Returns the smallest of two values: x and y . max max(x, y) The maximum of two values. Arguments x : number. y : number. Returns Returns the largest of two values: x and y . clamp clamp(val, min, max) Clamps a value between a minimum and a maximum. Arguments val : number. The value to be clamped. min : number. Minimum value. max : number. Maximum value. Returns Returns val clamped between min and max . Function clamp behave as follows: if val min , it returns min if val max , it returns max otherwise, it returns val approximately approximately(x, y) Compares two floating point values. Since comparing two floating point numbers for equality directly may result in inaccuracies, this is a handy function. Arguments x : number. y : number. Returns Returns true if x and y are \"approximately\" equal. lerp lerp(a, b, t) Linear interpolation. Arguments a : number. b : number. t : number. A value between 0 and 1. Returns Returns the linear interpolation between a and b by t . Value t is clamped automatically to range [0, 1] . As an example, note that lerp : returns a if t is 0 returns b if t is 1 returns (a + b) / 2 if t is 0.5 smoothstep smoothstep(a, b, t) Interpolation smoothing at the limits. Arguments a : number. b : number. t : number. A value between 0 and 1. Returns Returns an interpolated value between a and b by t , in a similar way to lerp . Unlike the linear lerp , smoothstep is smooth at the limits. This is useful to create smooth transitions and animations. Value t is clamped automatically to range [0, 1] .","title":"Math"},{"location":"reference/math/#math","text":"Built-in mathematical functions. The Math object can be accessed simply by typing Math . Examples: // Math functions two = Math.sqrt(4); // square root of 4 eight = Math.pow(2, 3); // 2 raised to the 3rd power zero = Math.sin(0); // sine of 0 seven = Math.max(5, 7); // maximum of 5 and 7","title":"Math"},{"location":"reference/math/#properties","text":"","title":"Properties"},{"location":"reference/math/#pi","text":"pi : number, read-only. An approximation of pi (3.1415926535...)","title":"pi"},{"location":"reference/math/#epsilon","text":"epsilon : number, read-only. The difference between 1 and the smallest floating point number that is greater than 1.","title":"epsilon"},{"location":"reference/math/#infinity","text":"infinity : number, read-only. A floating point representation of positive infinity.","title":"infinity"},{"location":"reference/math/#nan","text":"NaN : number, read-only. A numeric data type representing Not-a-Number. Available since: SurgeScript 0.5.3","title":"NaN"},{"location":"reference/math/#functions","text":"","title":"Functions"},{"location":"reference/math/#sqrt","text":"sqrt(x) Square root function. Arguments x : number. Returns The square root of x .","title":"sqrt"},{"location":"reference/math/#pow","text":"pow(x, p) Raise to power. Arguments x : number. The base. p : number. The exponent. Returns Returns x raised to the p power.","title":"pow"},{"location":"reference/math/#exp","text":"e(x) Exponential function. Arguments x : number. Returns Returns e raised to the x power.","title":"exp"},{"location":"reference/math/#log","text":"log(x) Natural logarithm. Arguments x : number. Returns The natural logarithm (base e ) of x .","title":"log"},{"location":"reference/math/#log10","text":"log10(x) Base 10 logarithm. Arguments x : number. Returns The base 10 logarithm of x .","title":"log10"},{"location":"reference/math/#sin","text":"sin(x) Sine function. Arguments x : number. Angle in radians. Returns The sine of x .","title":"sin"},{"location":"reference/math/#cos","text":"cos(x) Cosine function. Arguments x : number. Angle in radians. Returns The cosine of x .","title":"cos"},{"location":"reference/math/#tan","text":"tan(x) Tangent function. Arguments x : number. Angle in radians. Returns The tangent of x .","title":"tan"},{"location":"reference/math/#asin","text":"asin(x) Arc-sine function. Arguments x : number. Returns The angle in radians whose sine is x .","title":"asin"},{"location":"reference/math/#acos","text":"acos(x) Arc-cosine function. Arguments x : number. Returns The angle in radians whose cosine is x .","title":"acos"},{"location":"reference/math/#atan","text":"atan(x) Arc-tangent function. Arguments x : number. Returns The angle in radians whose tangent is x .","title":"atan"},{"location":"reference/math/#atan2","text":"atan2(y, x) Function atan2. Arguments y : number. x : number. Returns The angle, in radians, between the positive x-axis and the (x, y) vector.","title":"atan2"},{"location":"reference/math/#deg2rad","text":"deg2rad(degrees) Converts degrees to radians. Available since: SurgeScript 0.5.3 Arguments degrees : number. Returns The converted value.","title":"deg2rad"},{"location":"reference/math/#rad2deg","text":"rad2deg(radians) Converts radians to degrees. Available since: SurgeScript 0.5.3 Arguments radians : number. Returns The converted value.","title":"rad2deg"},{"location":"reference/math/#random","text":"random() Random value. Returns A random number between 0 (inclusive) and 1 (exclusive).","title":"random"},{"location":"reference/math/#floor","text":"floor(x) Floor function. Arguments x : number. Returns The largest integer less or equal than x .","title":"floor"},{"location":"reference/math/#ceil","text":"ceil(x) Ceiling function. Arguments x : number. Returns The smallest integer greater or equal than x .","title":"ceil"},{"location":"reference/math/#round","text":"round(x) Round to the nearest integer. Arguments x : number. Returns Returns x rounded to the nearest integer. If the fraction of x is 0.5, this function uses the commercial rounding tie-breaking method.","title":"round"},{"location":"reference/math/#mod","text":"mod(x, y) Modulus function. Used to get the remainder of a division. Deprecated since SurgeScript 0.5.3. Use the remainder operator (%) instead, e.g. x % y . Arguments x : number. y : number. Returns The remainder of x / y .","title":"mod"},{"location":"reference/math/#sign","text":"sign(x) The sign of x . Arguments x : number. Returns Returns 1 if x is positive or zero; or -1 if x is negative.","title":"sign"},{"location":"reference/math/#abs","text":"abs(x) Absolute value of x . Arguments x : number. Returns Returns -x if x is negative, or x otherwise.","title":"abs"},{"location":"reference/math/#min","text":"min(x, y) The minimum of two values. Arguments x : number. y : number. Returns Returns the smallest of two values: x and y .","title":"min"},{"location":"reference/math/#max","text":"max(x, y) The maximum of two values. Arguments x : number. y : number. Returns Returns the largest of two values: x and y .","title":"max"},{"location":"reference/math/#clamp","text":"clamp(val, min, max) Clamps a value between a minimum and a maximum. Arguments val : number. The value to be clamped. min : number. Minimum value. max : number. Maximum value. Returns Returns val clamped between min and max . Function clamp behave as follows: if val min , it returns min if val max , it returns max otherwise, it returns val","title":"clamp"},{"location":"reference/math/#approximately","text":"approximately(x, y) Compares two floating point values. Since comparing two floating point numbers for equality directly may result in inaccuracies, this is a handy function. Arguments x : number. y : number. Returns Returns true if x and y are \"approximately\" equal.","title":"approximately"},{"location":"reference/math/#lerp","text":"lerp(a, b, t) Linear interpolation. Arguments a : number. b : number. t : number. A value between 0 and 1. Returns Returns the linear interpolation between a and b by t . Value t is clamped automatically to range [0, 1] . As an example, note that lerp : returns a if t is 0 returns b if t is 1 returns (a + b) / 2 if t is 0.5","title":"lerp"},{"location":"reference/math/#smoothstep","text":"smoothstep(a, b, t) Interpolation smoothing at the limits. Arguments a : number. b : number. t : number. A value between 0 and 1. Returns Returns an interpolated value between a and b by t , in a similar way to lerp . Unlike the linear lerp , smoothstep is smooth at the limits. This is useful to create smooth transitions and animations. Value t is clamped automatically to range [0, 1] .","title":"smoothstep"},{"location":"reference/number/","text":"Number Routines for numbers. The Number object is not supposed to be used directly. The functions below are available for primitive values of the number type. Example: x = 2.toString(); // x is 2 t = typeof(x); // t is string Note: the SurgeScript Runtime stores numbers as 64-bit floating point values (following the IEEE 754 standard). Integer numbers are accurate up to 15 digits. Functions valueOf valueOf() The primitive value of the number, i.e., the number itself. Returns The number. toString toString() Converts the number to a string. Returns The number converted to a string. equals equals(x) Compares the number to another number x . This routine performs a comparison between floating point numbers. It's recommended to use Math.approximately() instead. Arguments x : number. The value to compare the number to. Returns Returns true if the numbers are equal. isFinite isFinite() Checks if the number is finite. Available since: SurgeScript 0.5.2 Returns Returns true if the number is finite. isNaN isNaN() Checks if the value is NaN (Not-a-Number). Available since: SurgeScript 0.5.2 Returns Returns true if the value is NaN. isInteger isInteger() Checks if the number is an integer. Available since: SurgeScript 0.5.2 Returns Returns true if the number is an integer.","title":"Number"},{"location":"reference/number/#number","text":"Routines for numbers. The Number object is not supposed to be used directly. The functions below are available for primitive values of the number type. Example: x = 2.toString(); // x is 2 t = typeof(x); // t is string Note: the SurgeScript Runtime stores numbers as 64-bit floating point values (following the IEEE 754 standard). Integer numbers are accurate up to 15 digits.","title":"Number"},{"location":"reference/number/#functions","text":"","title":"Functions"},{"location":"reference/number/#valueof","text":"valueOf() The primitive value of the number, i.e., the number itself. Returns The number.","title":"valueOf"},{"location":"reference/number/#tostring","text":"toString() Converts the number to a string. Returns The number converted to a string.","title":"toString"},{"location":"reference/number/#equals","text":"equals(x) Compares the number to another number x . This routine performs a comparison between floating point numbers. It's recommended to use Math.approximately() instead. Arguments x : number. The value to compare the number to. Returns Returns true if the numbers are equal.","title":"equals"},{"location":"reference/number/#isfinite","text":"isFinite() Checks if the number is finite. Available since: SurgeScript 0.5.2 Returns Returns true if the number is finite.","title":"isFinite"},{"location":"reference/number/#isnan","text":"isNaN() Checks if the value is NaN (Not-a-Number). Available since: SurgeScript 0.5.2 Returns Returns true if the value is NaN.","title":"isNaN"},{"location":"reference/number/#isinteger","text":"isInteger() Checks if the number is an integer. Available since: SurgeScript 0.5.2 Returns Returns true if the number is an integer.","title":"isInteger"},{"location":"reference/object/","text":"Object In SurgeScript, all objects are also instances of Object . This means that the properties and functions listed below are available for all objects: Properties parent parent : object, read-only. Reference to the parent object. childCount childCount : number, read-only. The number of children of the object. __name __name : string, read-only. The name of the object. __active __active : boolean. Indicates whether the object is active or not. Objects are active by default. Whenever an object is set to be inactive, its state machine is paused. Additionally, the state machines of all its descendants are also paused. __functions __functions : Array object, read-only. The functions of this object represented as a collection of strings. __timespent __timespent : number, read-only. The approximate time spent in this object in the last frame (in seconds). __file __file : string, read-only. The source file of this object. Available since: SurgeScript 0.5.3 Functions spawn spawn(objectName) Spawns an object named objectName . Arguments objectName : string. The name of the object to be spawned / instantiated. Returns A new object of the desired name. Note that the newly created object will be a child of this . destroy destroy() Destroys the object. child child(childName | childId) Looks for a child named childName (or matching childId ). Arguments childName : string. The name of the desired child. childId : number. The id of the desired child, an integer between 0 and childCount - 1 , inclusive. Returns The desired child, or null if there is no such object. children children(childName) Finds all children named childName . Since this function spawns a new array at each call, it's recommended to cache its return value. Available since: SurgeScript 0.5.4 Arguments childName : string. The name of the desired children. Returns A new array containing all children named childName . If no such children are found, an empty array is returned. sibling sibling(siblingName) Looks for a sibling named siblingName . Two objects are siblings if they share the same parent. Arguments siblingName : string. The name of the desired sibling. Returns A sibling of name siblingName , or null if there is no such object. findObject findObject(objectName) Finds a descendant (child, grand-child, and so on) named objectName . Since this function traverses the object tree , it's recommended to cache its return value. Do not use it in loops or states, as it might be slow. Arguments objectName : string. The name of the desired object. Returns A descendant named objectName , or null if there is no such object. Example object TestObject { // will search for SomeOtherObject in the Application obj = Application.findObject( SomeOtherObject ); state main { if(obj != null) Console.print( Found the object. ); else Console.print( Object not found. ); destroy(); } } findObjects findObjects(objectName) Finds all descendants named objectName . Since this function traverses the object tree , it's recommended to cache its return value. Do not use it in loops or states, as it might be slow. Available since: SurgeScript 0.5.4 Arguments objectName : string. The name of the objects to be found. Returns A new array containing all the descendants named objectName . If no such descendants are found, an empty array is returned. findObjectWithTag findObjectWithTag(tagName) Finds a descendant tagged tagName . Since this function traverses the object tree , it's recommended to cache its return value. Do not use it in loops or states, as it might be slow. Available since: SurgeScript 0.5.4 Arguments tagName : string. The name of a tag. Returns A descendant tagged tagName , or null if there is no such object. findObjectsWithTag findObjectsWithTag(tagName) Finds all descendants tagged tagName . Since this function traverses the object tree , it's recommended to cache its return value. Do not use it in loops or states, as it might be slow. Available since: SurgeScript 0.5.4 Arguments tagName : string. The name of a tag. Returns A new array containing all the descendants tagged tagName . If no such descendants are found, an empty array is returned. toString toString() Converts the object to a string. This function is designed to be overloaded by your own objects. Returns A string. equals equals(otherObject) Compares this object to otherObject . This function is designed to be overloaded by your own objects. Arguments otherObject : object. An object to compare this to. Returns Returns true if the objects are equal; false otherwise. hasFunction hasFunction(functionName) Checks if the object has a function named functionName . Arguments functionName : string. The name of the function. Returns Returns true if the object has a function named functionName . hasTag hasTag(tagName) Checks if the object has been tagged with tagName . Arguments tagName : string. The name of the tag. Returns Returns true if the object has been tagged with tagName . __invoke __invoke(functionName, paramsArray) Invokes function functionName , passing the parameters specified in paramsArray . Please note that the number of elements of paramsArray must be the same as the number of parameters required by the function to be invoked. Available since: SurgeScript 0.5.2 Arguments functionName : string. The name of the function to be called. paramsArray : Array . The parameters to be passed to the function. Returns Returns the value returned by the invoked function. Example // The program below will print: // 12 // 12 // true object Application { state main { Console.print(this.sum(5, 7)); Console.print(this.__invoke( sum , [5, 7])); Console.print(sum(5, 7) == __invoke( sum , [5, 7])); Application.exit(); } fun sum(a, b) { return a + b; } }","title":"Object"},{"location":"reference/object/#object","text":"In SurgeScript, all objects are also instances of Object . This means that the properties and functions listed below are available for all objects:","title":"Object"},{"location":"reference/object/#properties","text":"","title":"Properties"},{"location":"reference/object/#parent","text":"parent : object, read-only. Reference to the parent object.","title":"parent"},{"location":"reference/object/#childcount","text":"childCount : number, read-only. The number of children of the object.","title":"childCount"},{"location":"reference/object/#__name","text":"__name : string, read-only. The name of the object.","title":"__name"},{"location":"reference/object/#__active","text":"__active : boolean. Indicates whether the object is active or not. Objects are active by default. Whenever an object is set to be inactive, its state machine is paused. Additionally, the state machines of all its descendants are also paused.","title":"__active"},{"location":"reference/object/#__functions","text":"__functions : Array object, read-only. The functions of this object represented as a collection of strings.","title":"__functions"},{"location":"reference/object/#__timespent","text":"__timespent : number, read-only. The approximate time spent in this object in the last frame (in seconds).","title":"__timespent"},{"location":"reference/object/#__file","text":"__file : string, read-only. The source file of this object. Available since: SurgeScript 0.5.3","title":"__file"},{"location":"reference/object/#functions","text":"","title":"Functions"},{"location":"reference/object/#spawn","text":"spawn(objectName) Spawns an object named objectName . Arguments objectName : string. The name of the object to be spawned / instantiated. Returns A new object of the desired name. Note that the newly created object will be a child of this .","title":"spawn"},{"location":"reference/object/#destroy","text":"destroy() Destroys the object.","title":"destroy"},{"location":"reference/object/#child","text":"child(childName | childId) Looks for a child named childName (or matching childId ). Arguments childName : string. The name of the desired child. childId : number. The id of the desired child, an integer between 0 and childCount - 1 , inclusive. Returns The desired child, or null if there is no such object.","title":"child"},{"location":"reference/object/#children","text":"children(childName) Finds all children named childName . Since this function spawns a new array at each call, it's recommended to cache its return value. Available since: SurgeScript 0.5.4 Arguments childName : string. The name of the desired children. Returns A new array containing all children named childName . If no such children are found, an empty array is returned.","title":"children"},{"location":"reference/object/#sibling","text":"sibling(siblingName) Looks for a sibling named siblingName . Two objects are siblings if they share the same parent. Arguments siblingName : string. The name of the desired sibling. Returns A sibling of name siblingName , or null if there is no such object.","title":"sibling"},{"location":"reference/object/#findobject","text":"findObject(objectName) Finds a descendant (child, grand-child, and so on) named objectName . Since this function traverses the object tree , it's recommended to cache its return value. Do not use it in loops or states, as it might be slow. Arguments objectName : string. The name of the desired object. Returns A descendant named objectName , or null if there is no such object. Example object TestObject { // will search for SomeOtherObject in the Application obj = Application.findObject( SomeOtherObject ); state main { if(obj != null) Console.print( Found the object. ); else Console.print( Object not found. ); destroy(); } }","title":"findObject"},{"location":"reference/object/#findobjects","text":"findObjects(objectName) Finds all descendants named objectName . Since this function traverses the object tree , it's recommended to cache its return value. Do not use it in loops or states, as it might be slow. Available since: SurgeScript 0.5.4 Arguments objectName : string. The name of the objects to be found. Returns A new array containing all the descendants named objectName . If no such descendants are found, an empty array is returned.","title":"findObjects"},{"location":"reference/object/#findobjectwithtag","text":"findObjectWithTag(tagName) Finds a descendant tagged tagName . Since this function traverses the object tree , it's recommended to cache its return value. Do not use it in loops or states, as it might be slow. Available since: SurgeScript 0.5.4 Arguments tagName : string. The name of a tag. Returns A descendant tagged tagName , or null if there is no such object.","title":"findObjectWithTag"},{"location":"reference/object/#findobjectswithtag","text":"findObjectsWithTag(tagName) Finds all descendants tagged tagName . Since this function traverses the object tree , it's recommended to cache its return value. Do not use it in loops or states, as it might be slow. Available since: SurgeScript 0.5.4 Arguments tagName : string. The name of a tag. Returns A new array containing all the descendants tagged tagName . If no such descendants are found, an empty array is returned.","title":"findObjectsWithTag"},{"location":"reference/object/#tostring","text":"toString() Converts the object to a string. This function is designed to be overloaded by your own objects. Returns A string.","title":"toString"},{"location":"reference/object/#equals","text":"equals(otherObject) Compares this object to otherObject . This function is designed to be overloaded by your own objects. Arguments otherObject : object. An object to compare this to. Returns Returns true if the objects are equal; false otherwise.","title":"equals"},{"location":"reference/object/#hasfunction","text":"hasFunction(functionName) Checks if the object has a function named functionName . Arguments functionName : string. The name of the function. Returns Returns true if the object has a function named functionName .","title":"hasFunction"},{"location":"reference/object/#hastag","text":"hasTag(tagName) Checks if the object has been tagged with tagName . Arguments tagName : string. The name of the tag. Returns Returns true if the object has been tagged with tagName .","title":"hasTag"},{"location":"reference/object/#__invoke","text":"__invoke(functionName, paramsArray) Invokes function functionName , passing the parameters specified in paramsArray . Please note that the number of elements of paramsArray must be the same as the number of parameters required by the function to be invoked. Available since: SurgeScript 0.5.2 Arguments functionName : string. The name of the function to be called. paramsArray : Array . The parameters to be passed to the function. Returns Returns the value returned by the invoked function. Example // The program below will print: // 12 // 12 // true object Application { state main { Console.print(this.sum(5, 7)); Console.print(this.__invoke( sum , [5, 7])); Console.print(sum(5, 7) == __invoke( sum , [5, 7])); Application.exit(); } fun sum(a, b) { return a + b; } }","title":"__invoke"},{"location":"reference/plugin/","text":"Plugin SurgeScript features a plugin system that allows you to extend the functionalities of the language. Plugins are objects that can be accessed anywhere in the code. They can be imported using a using statement. Also, the plugin system can be accessed simply by typing Plugin . Example: // File: app.ss // Plugins are used to extend the language. You can // import them into your source file using the // using statement: using StringUtils; // An application that uses the imported plugin object Application { str = alucard ; state main { Console.print( Reverse a string: ); Console.print(str); Console.print(StringUtils.reverse(str)); Application.exit(); } } // File: string_utils.ss // Plugins are objects annotated with @Plugin . // They are spawned automatically and can be // accessed anywhere in the code. @Plugin object StringUtils { fun reverse(str) { buf = ; for(i = str.length - 1; i = 0; i--) buf += str[i]; return buf; } } Available since: SurgeScript 0.5.2 Properties count count : number, read-only. The number of plugins. Functions spawn spawn(pluginName) Spawns object pluginName as a plugin. This function is not to be used directly, as SurgeScript spawns the plugins automatically for you. SurgeScript recognizes an object as a plugin when you annotate it with @Plugin . Arguments pluginName : string. The name of the object to be spawned as a plugin. It's not recommended to include special characters in the plugin name. get get(pluginName) Gets a reference to the plugin named pluginName . The [ ] operator can be used instead of the get() function, as in Plugin[pluginName] . Rather than using this function, it's recommended to import the desired plugin using the using myPlugin; statement at the beginning of your code. Your plugin will be available as myPlugin . Arguments pluginName : string. The name of the plugin. Example using StringUtils; ... b = (Plugin[ StringUtils ] === StringUtils); // b is true c = (Plugin.StringUtils === StringUtils); // c is true","title":"Plugin"},{"location":"reference/plugin/#plugin","text":"SurgeScript features a plugin system that allows you to extend the functionalities of the language. Plugins are objects that can be accessed anywhere in the code. They can be imported using a using statement. Also, the plugin system can be accessed simply by typing Plugin . Example: // File: app.ss // Plugins are used to extend the language. You can // import them into your source file using the // using statement: using StringUtils; // An application that uses the imported plugin object Application { str = alucard ; state main { Console.print( Reverse a string: ); Console.print(str); Console.print(StringUtils.reverse(str)); Application.exit(); } } // File: string_utils.ss // Plugins are objects annotated with @Plugin . // They are spawned automatically and can be // accessed anywhere in the code. @Plugin object StringUtils { fun reverse(str) { buf = ; for(i = str.length - 1; i = 0; i--) buf += str[i]; return buf; } } Available since: SurgeScript 0.5.2","title":"Plugin"},{"location":"reference/plugin/#properties","text":"","title":"Properties"},{"location":"reference/plugin/#count","text":"count : number, read-only. The number of plugins.","title":"count"},{"location":"reference/plugin/#functions","text":"","title":"Functions"},{"location":"reference/plugin/#spawn","text":"spawn(pluginName) Spawns object pluginName as a plugin. This function is not to be used directly, as SurgeScript spawns the plugins automatically for you. SurgeScript recognizes an object as a plugin when you annotate it with @Plugin . Arguments pluginName : string. The name of the object to be spawned as a plugin. It's not recommended to include special characters in the plugin name.","title":"spawn"},{"location":"reference/plugin/#get","text":"get(pluginName) Gets a reference to the plugin named pluginName . The [ ] operator can be used instead of the get() function, as in Plugin[pluginName] . Rather than using this function, it's recommended to import the desired plugin using the using myPlugin; statement at the beginning of your code. Your plugin will be available as myPlugin . Arguments pluginName : string. The name of the plugin. Example using StringUtils; ... b = (Plugin[ StringUtils ] === StringUtils); // b is true c = (Plugin.StringUtils === StringUtils); // c is true","title":"get"},{"location":"reference/string/","text":"String Routines for strings. The String object is not supposed to be used directly (generally speaking). The functions below are available for primitive values of the string type. Example: // Useful string routines x = SurgeScript .toLowerCase(); // surgescript y = x.substr(0, 5); // surge z = x[0]; // s (first character of x) n = y.length; // 5 Please note that strings in SurgeScript are immutable. Once a string is set, its individual characters cannot be changed. If you need to modify the content of a string, reassign the variable to a new string. Properties length length : number, read-only. The length of the string. Functions valueOf valueOf() The primitive value of the string, i.e., the string itself. Returns The string. toString toString() Convert to string. Returns The string itself. equals equals(str) Compares the string to another string str . Arguments str : string. Returns Returns true if the strings are equal. get get(i) Gets the i -th character of the string. The [ ] operator can be used equivalently. Arguments i : integer number. A value between 0 (inclusive) and the length of the string (exclusive). Returns The i -th character of the string (0-based index). indexOf indexOf(str) Finds the position of the first occurrence of str in the string. Arguments str : string. The string to be searched for. Returns The position (0-based index) of the first occurrence of str in the string, or -1 if there is no such occurrence. Example name = SurgeScript ; a = name.indexOf( Surge ); // a is 0 b = name.indexOf( Neon ); // b is -1 c = name.indexOf( e ); // c is 4 d = name.indexOf( script ); // d is -1, as the search is case-sensitive substr substr(start, length) Extracts the substring starting at position start with length length . Arguments start : number. The start position. length : number. The length of the substring. Returns The substring with length length starting at start . Example name = SurgeScript ; surge = name.substr(0, 5); // Surge script = name.substr(5, 6); // Script e = name.substr(4, 2); // e empty = name.substr(555, 1); // concat concat(str) Concatenates two strings. This is the same as using the + operator. Arguments str : string. Returns The caller string concatenated with str at the end. Example name = Surge .concat( Script ); // SurgeScript name = Surge + Script ; // SurgeScript replace replace(oldstr, newstr) Replaces all occurrences of oldstr to newstr in the caller string. Arguments oldstr : string. The substring to be replaced. newstr : string. The substring that should appear in the result. Returns The caller string having all its occurrences of oldstr replaced to newstr . Example // dst is Gimacian, Neon and Charge src = Surge, Neon and Charge ; dst = src.replace( Surge , Gimacian ); toLowerCase toLowerCase() Converts the string to lower case. Returns The string converted to lower case. toUpperCase toUpperCase() Converts the string to upper case. Returns The string converted to upper case. isNullOrEmpty isNullOrEmpty(value) This method of the String object can be used directly. It checks if the given value is either null or an empty string. Available since: SurgeScript 0.5.3 Arguments value : string | null. The value to be tested. Returns Returns true if value is either null or an empty string. Example name = Surge ; //name = ; //name = null; if(!String.isNullOrEmpty(name)) Console.print(name);","title":"String"},{"location":"reference/string/#string","text":"Routines for strings. The String object is not supposed to be used directly (generally speaking). The functions below are available for primitive values of the string type. Example: // Useful string routines x = SurgeScript .toLowerCase(); // surgescript y = x.substr(0, 5); // surge z = x[0]; // s (first character of x) n = y.length; // 5 Please note that strings in SurgeScript are immutable. Once a string is set, its individual characters cannot be changed. If you need to modify the content of a string, reassign the variable to a new string.","title":"String"},{"location":"reference/string/#properties","text":"","title":"Properties"},{"location":"reference/string/#length","text":"length : number, read-only. The length of the string.","title":"length"},{"location":"reference/string/#functions","text":"","title":"Functions"},{"location":"reference/string/#valueof","text":"valueOf() The primitive value of the string, i.e., the string itself. Returns The string.","title":"valueOf"},{"location":"reference/string/#tostring","text":"toString() Convert to string. Returns The string itself.","title":"toString"},{"location":"reference/string/#equals","text":"equals(str) Compares the string to another string str . Arguments str : string. Returns Returns true if the strings are equal.","title":"equals"},{"location":"reference/string/#get","text":"get(i) Gets the i -th character of the string. The [ ] operator can be used equivalently. Arguments i : integer number. A value between 0 (inclusive) and the length of the string (exclusive). Returns The i -th character of the string (0-based index).","title":"get"},{"location":"reference/string/#indexof","text":"indexOf(str) Finds the position of the first occurrence of str in the string. Arguments str : string. The string to be searched for. Returns The position (0-based index) of the first occurrence of str in the string, or -1 if there is no such occurrence. Example name = SurgeScript ; a = name.indexOf( Surge ); // a is 0 b = name.indexOf( Neon ); // b is -1 c = name.indexOf( e ); // c is 4 d = name.indexOf( script ); // d is -1, as the search is case-sensitive","title":"indexOf"},{"location":"reference/string/#substr","text":"substr(start, length) Extracts the substring starting at position start with length length . Arguments start : number. The start position. length : number. The length of the substring. Returns The substring with length length starting at start . Example name = SurgeScript ; surge = name.substr(0, 5); // Surge script = name.substr(5, 6); // Script e = name.substr(4, 2); // e empty = name.substr(555, 1); //","title":"substr"},{"location":"reference/string/#concat","text":"concat(str) Concatenates two strings. This is the same as using the + operator. Arguments str : string. Returns The caller string concatenated with str at the end. Example name = Surge .concat( Script ); // SurgeScript name = Surge + Script ; // SurgeScript","title":"concat"},{"location":"reference/string/#replace","text":"replace(oldstr, newstr) Replaces all occurrences of oldstr to newstr in the caller string. Arguments oldstr : string. The substring to be replaced. newstr : string. The substring that should appear in the result. Returns The caller string having all its occurrences of oldstr replaced to newstr . Example // dst is Gimacian, Neon and Charge src = Surge, Neon and Charge ; dst = src.replace( Surge , Gimacian );","title":"replace"},{"location":"reference/string/#tolowercase","text":"toLowerCase() Converts the string to lower case. Returns The string converted to lower case.","title":"toLowerCase"},{"location":"reference/string/#touppercase","text":"toUpperCase() Converts the string to upper case. Returns The string converted to upper case.","title":"toUpperCase"},{"location":"reference/string/#isnullorempty","text":"isNullOrEmpty(value) This method of the String object can be used directly. It checks if the given value is either null or an empty string. Available since: SurgeScript 0.5.3 Arguments value : string | null. The value to be tested. Returns Returns true if value is either null or an empty string. Example name = Surge ; //name = ; //name = null; if(!String.isNullOrEmpty(name)) Console.print(name);","title":"isNullOrEmpty"},{"location":"reference/surgescript/","text":"SurgeScript Data related to the scripting language itself. You can access this object simply by typing SurgeScript . Example: // Prints the version of the SurgeScript runtime object Application { state main { Console.print(SurgeScript.version); } } Available since: SurgeScript 0.5.2 Properties version version : string, read-only. Version number of the SurgeScript runtime.","title":"SurgeScript"},{"location":"reference/surgescript/#surgescript","text":"Data related to the scripting language itself. You can access this object simply by typing SurgeScript . Example: // Prints the version of the SurgeScript runtime object Application { state main { Console.print(SurgeScript.version); } } Available since: SurgeScript 0.5.2","title":"SurgeScript"},{"location":"reference/surgescript/#properties","text":"","title":"Properties"},{"location":"reference/surgescript/#version","text":"version : string, read-only. Version number of the SurgeScript runtime.","title":"version"},{"location":"reference/system/","text":"System The root object. Used to gather data from the language and to access special objects. It can be accessed by typing System . Properties tags tags : Tag System object, read-only. A reference to the Tag System. gc gc : Garbage Collector object, read-only. A reference to the Garbage Collector object. objectCount objectCount : number, read-only. The total number of objects at this moment. Functions exit exit() Exits the Application. destroy destroy() The same as exit() .","title":"System"},{"location":"reference/system/#system","text":"The root object. Used to gather data from the language and to access special objects. It can be accessed by typing System .","title":"System"},{"location":"reference/system/#properties","text":"","title":"Properties"},{"location":"reference/system/#tags","text":"tags : Tag System object, read-only. A reference to the Tag System.","title":"tags"},{"location":"reference/system/#gc","text":"gc : Garbage Collector object, read-only. A reference to the Garbage Collector object.","title":"gc"},{"location":"reference/system/#objectcount","text":"objectCount : number, read-only. The total number of objects at this moment.","title":"objectCount"},{"location":"reference/system/#functions","text":"","title":"Functions"},{"location":"reference/system/#exit","text":"exit() Exits the Application.","title":"exit"},{"location":"reference/system/#destroy","text":"destroy() The same as exit() .","title":"destroy"},{"location":"reference/tags/","text":"TagSystem Utility functions for dealing with object tags. This object is available at System.tags and shouldn't be instantiated directly. Functions list list() Lists all tags used in all objects. Returns This function spawns a new Array object with all tags and returns it. select select(tagName) Selects all objects that are tagged with tagName . Arguments tagName : string. Returns This function returns a new Array with all the names of the objects tagged with tagName .","title":"TagSystem"},{"location":"reference/tags/#tagsystem","text":"Utility functions for dealing with object tags. This object is available at System.tags and shouldn't be instantiated directly.","title":"TagSystem"},{"location":"reference/tags/#functions","text":"","title":"Functions"},{"location":"reference/tags/#list","text":"list() Lists all tags used in all objects. Returns This function spawns a new Array object with all tags and returns it.","title":"list"},{"location":"reference/tags/#select","text":"select(tagName) Selects all objects that are tagged with tagName . Arguments tagName : string. Returns This function returns a new Array with all the names of the objects tagged with tagName .","title":"select"},{"location":"reference/time/","text":"Time Time utilities. This object is available simply by typing Time . Properties time time : number, read-only. The number of seconds since the application was started at the beginning of this frame. delta delta : number, read-only. The time, in seconds, taken to complete the last frame of the application. Use this value to make your application behave consistently regardless of the frame rate. tickCount tickCount : number, read-only. The number of seconds since the application was started at the moment this property is evaluated. Note: Since Time.tickCount may return different values during the same frame of your application, it's generally advisable to use Time.time instead.","title":"Time"},{"location":"reference/time/#time","text":"Time utilities. This object is available simply by typing Time .","title":"Time"},{"location":"reference/time/#properties","text":"","title":"Properties"},{"location":"reference/time/#time_1","text":"time : number, read-only. The number of seconds since the application was started at the beginning of this frame.","title":"time"},{"location":"reference/time/#delta","text":"delta : number, read-only. The time, in seconds, taken to complete the last frame of the application. Use this value to make your application behave consistently regardless of the frame rate.","title":"delta"},{"location":"reference/time/#tickcount","text":"tickCount : number, read-only. The number of seconds since the application was started at the moment this property is evaluated. Note: Since Time.tickCount may return different values during the same frame of your application, it's generally advisable to use Time.time instead.","title":"tickCount"},{"location":"tutorials/advanced_features/","text":"Advanced features This section describes advanced features of SurgeScript. Lookup operator Some programming languages, such as C++, have a feature called operator overloading . It's a syntactic sugar that allows the programmer to attribute custom implementations to different operators. In SurgeScript, the [] operator (also called the lookup operator ), used by Arrays and Dictionaries, is used to get and set values from/to the data structure. In fact, the [] operator can be used with any object. It is necessary to define, in your object, functions get() and set() with the following signature: fun get(key) { // custom implementation } fun set(key, value) { // custom implementation } Given an object obj , the expression x = obj[key] is equivalent to x = obj.get(key) . Similarly, obj[key] = value is equivalent to obj.set(key, value) . Functors In SurgeScript, objects can be made to behave like functions. We call these objects functors (or function objects ). To make an object behave like a function, you have to overload the () operator (also known as the function operator ). This is done by defining function call() in your object: fun call() { // custom implementation } Function call() may take any number of parameters. Given an object f , the expression y = f(x) is equivalent to y = f.call(x) . Notice that, since f is an object, you may exchange its implementation during runtime. Assertions The assert(condition) statement specifies a condition that you expect to be true at a certain point in your code. If that condition turns out to be false, the code will be interrupted with an assertion failed error. Example: assert(name == Surge ); // will crash if name isn't Surge Modifiers In SurgeScript, a modifier (or modifier function ) provides an elegant way of configuring objects. This is not a feature per se, but rather a way of doing things. Consider the object below - it simply displays a message at regular intervals: object Parrot { message = I am a Parrot ; state main { if(timeout(1.0)) state = print ; } state print { Console.print(message); state = main ; } // setMessage() is a modifier function // A modifier always returns this fun setMessage(newMessage) { message = newMessage; return this; } } Suppose that, in your Application, you would like to spawn that object and modify its message. One way of doing it would be making its internal variable public and changing its contents in the constructor function of your Application. A more concise and elegant way of doing it would be calling function setMessage() just after you spawn the object: object Application { parrot = spawn( Parrot ).setMessage( Hello! ); state main { } } Take note that the modifier function does two things: It modifies the internals of the object in some way It always returns this (that is, the object itself) That being said, you may call such a function from your Application, just after spawn() , and you'll still have a reference to the spawned object. Moreover, since modifiers always return this , you may chain multiple modifiers into a single statement, making your code concise and your statement descriptive. Example: parrot = spawn( Parrot ).setMessage( Hello! ).setInterval(2.0); Factory In SurgeScript, a factory is a functor that spawns an object for you. The object can be spawned and configured in a single call. In the example below, factory Greeter spawns and configures Greeting objects. We annotate the factory with @Plugin , so it can be imported anywhere in the code. To the end-user, calling Greeter() is simpler than manually spawning and configuring a Greeting every time it is needed. // Factory example using Greeter; // import the factory object Application { state main { // This will print: // Hello, alex! g = Greeter( alex ); g.greet(); exit(); } } // File: greeting.ss object Greeting { public name = anon ; fun greet() { Console.print( Hello, + name + ! ); } } @Plugin object Greeter { // Greeter is a factory. It spawns and configures // a Greeting object for you. Being a plugin, // Greeter can be used anywhere in the code. fun call(name) { g = spawn( Greeting ); g.name = name; return g; } } Please note: in the example above, objects spawned by the factory will be children of the factory. If you need the parent of the spawned object to be the caller object, then you might simply write g = caller.spawn(\"Greeter\") . Keyword caller points to the object that called the function (or null if not applicable). Iterators As seen in the loops section, the foreach loop may be used to iterate through a collection. In SurgeScript, a collection is an object (but the opposite is not always true). You may implement your own collections by implementing function iterator() . If you have ever used Java, you'll find this to be familiar. object MyCollection { fun iterator() { // function iterator() takes no arguments and // should return a new iterator object } } For each collection you define, you should also define its iterator object. The iterator object should implement functions next() and hasNext() (both take no arguments): object MyIterator { fun next() { // returns the next element of the collection // and advances the iteration pointer // the collection is usually the parent object } function hasNext() { // returns true if the enumeration isn't over // returns false if there are no more elements } } You may iterate through a collection using the following code: it = collection.iterator(); while(it.hasNext()) { x = it.next(); // do something with x // x is an element of the collection Console.print(x); } Or, alternatively, using the compact foreach: foreach(x in collection) { Console.print(x); } For the sake of completion, the following code demonstrates how to implement a custom collection that hold even numbers from 0 up to 20. object Application { evenNumbers = spawn( EvenNumbers ); state main { // iterate the collection foreach(number in evenNumbers) Console.print(number); // we're done! state = done ; } state done { } } object EvenNumbers { fun iterator() { return spawn( EvenIterator ); } } object EvenIterator { nextNumber = 0; fun next() { currentNumber = nextNumber; nextNumber += 2; return currentNumber; } fun hasNext() { return nextNumber = 20; } } The result of this code is: 0 2 4 6 8 10 12 14 16 18 20","title":"Advanced features"},{"location":"tutorials/advanced_features/#advanced-features","text":"This section describes advanced features of SurgeScript.","title":"Advanced features"},{"location":"tutorials/advanced_features/#lookup-operator","text":"Some programming languages, such as C++, have a feature called operator overloading . It's a syntactic sugar that allows the programmer to attribute custom implementations to different operators. In SurgeScript, the [] operator (also called the lookup operator ), used by Arrays and Dictionaries, is used to get and set values from/to the data structure. In fact, the [] operator can be used with any object. It is necessary to define, in your object, functions get() and set() with the following signature: fun get(key) { // custom implementation } fun set(key, value) { // custom implementation } Given an object obj , the expression x = obj[key] is equivalent to x = obj.get(key) . Similarly, obj[key] = value is equivalent to obj.set(key, value) .","title":"Lookup operator"},{"location":"tutorials/advanced_features/#functors","text":"In SurgeScript, objects can be made to behave like functions. We call these objects functors (or function objects ). To make an object behave like a function, you have to overload the () operator (also known as the function operator ). This is done by defining function call() in your object: fun call() { // custom implementation } Function call() may take any number of parameters. Given an object f , the expression y = f(x) is equivalent to y = f.call(x) . Notice that, since f is an object, you may exchange its implementation during runtime.","title":"Functors"},{"location":"tutorials/advanced_features/#assertions","text":"The assert(condition) statement specifies a condition that you expect to be true at a certain point in your code. If that condition turns out to be false, the code will be interrupted with an assertion failed error. Example: assert(name == Surge ); // will crash if name isn't Surge","title":"Assertions"},{"location":"tutorials/advanced_features/#modifiers","text":"In SurgeScript, a modifier (or modifier function ) provides an elegant way of configuring objects. This is not a feature per se, but rather a way of doing things. Consider the object below - it simply displays a message at regular intervals: object Parrot { message = I am a Parrot ; state main { if(timeout(1.0)) state = print ; } state print { Console.print(message); state = main ; } // setMessage() is a modifier function // A modifier always returns this fun setMessage(newMessage) { message = newMessage; return this; } } Suppose that, in your Application, you would like to spawn that object and modify its message. One way of doing it would be making its internal variable public and changing its contents in the constructor function of your Application. A more concise and elegant way of doing it would be calling function setMessage() just after you spawn the object: object Application { parrot = spawn( Parrot ).setMessage( Hello! ); state main { } } Take note that the modifier function does two things: It modifies the internals of the object in some way It always returns this (that is, the object itself) That being said, you may call such a function from your Application, just after spawn() , and you'll still have a reference to the spawned object. Moreover, since modifiers always return this , you may chain multiple modifiers into a single statement, making your code concise and your statement descriptive. Example: parrot = spawn( Parrot ).setMessage( Hello! ).setInterval(2.0);","title":"Modifiers"},{"location":"tutorials/advanced_features/#factory","text":"In SurgeScript, a factory is a functor that spawns an object for you. The object can be spawned and configured in a single call. In the example below, factory Greeter spawns and configures Greeting objects. We annotate the factory with @Plugin , so it can be imported anywhere in the code. To the end-user, calling Greeter() is simpler than manually spawning and configuring a Greeting every time it is needed. // Factory example using Greeter; // import the factory object Application { state main { // This will print: // Hello, alex! g = Greeter( alex ); g.greet(); exit(); } } // File: greeting.ss object Greeting { public name = anon ; fun greet() { Console.print( Hello, + name + ! ); } } @Plugin object Greeter { // Greeter is a factory. It spawns and configures // a Greeting object for you. Being a plugin, // Greeter can be used anywhere in the code. fun call(name) { g = spawn( Greeting ); g.name = name; return g; } } Please note: in the example above, objects spawned by the factory will be children of the factory. If you need the parent of the spawned object to be the caller object, then you might simply write g = caller.spawn(\"Greeter\") . Keyword caller points to the object that called the function (or null if not applicable).","title":"Factory"},{"location":"tutorials/advanced_features/#iterators","text":"As seen in the loops section, the foreach loop may be used to iterate through a collection. In SurgeScript, a collection is an object (but the opposite is not always true). You may implement your own collections by implementing function iterator() . If you have ever used Java, you'll find this to be familiar. object MyCollection { fun iterator() { // function iterator() takes no arguments and // should return a new iterator object } } For each collection you define, you should also define its iterator object. The iterator object should implement functions next() and hasNext() (both take no arguments): object MyIterator { fun next() { // returns the next element of the collection // and advances the iteration pointer // the collection is usually the parent object } function hasNext() { // returns true if the enumeration isn't over // returns false if there are no more elements } } You may iterate through a collection using the following code: it = collection.iterator(); while(it.hasNext()) { x = it.next(); // do something with x // x is an element of the collection Console.print(x); } Or, alternatively, using the compact foreach: foreach(x in collection) { Console.print(x); } For the sake of completion, the following code demonstrates how to implement a custom collection that hold even numbers from 0 up to 20. object Application { evenNumbers = spawn( EvenNumbers ); state main { // iterate the collection foreach(number in evenNumbers) Console.print(number); // we're done! state = done ; } state done { } } object EvenNumbers { fun iterator() { return spawn( EvenIterator ); } } object EvenIterator { nextNumber = 0; fun next() { currentNumber = nextNumber; nextNumber += 2; return currentNumber; } fun hasNext() { return nextNumber = 20; } } The result of this code is: 0 2 4 6 8 10 12 14 16 18 20","title":"Iterators"},{"location":"tutorials/best_practices/","text":"Best Practices Read the Components section. It's crucial that you understand it. Follow the golden rule: objects should not mess with each others' internals! Objects should not change other objects' variables or states directly (won't allow it!) Objects should define functions that can be operated upon by the external world (API) Use camelCase names for both variables and functions. Use 4 spaces when indenting your code. Combine related plugins into a single package. Do not pollute the global namespace. Read the SurgeScript documentation often.","title":"Best practices"},{"location":"tutorials/best_practices/#best-practices","text":"Read the Components section. It's crucial that you understand it. Follow the golden rule: objects should not mess with each others' internals! Objects should not change other objects' variables or states directly (won't allow it!) Objects should define functions that can be operated upon by the external world (API) Use camelCase names for both variables and functions. Use 4 spaces when indenting your code. Combine related plugins into a single package. Do not pollute the global namespace. Read the SurgeScript documentation often.","title":"Best Practices"},{"location":"tutorials/comments/","text":"Comments Comments are used to make your code more human-readable. They are ignored by the computer. SurgeScript allows two kinds of comments: single-line comments and multi-line comments. Single-line comments Single-line comments start with a // . Example: // This line has no effect on the code (it's just for improved readability) x = 3 + 4; // x is now 7 Multi-line comments Multi-line comments start with a /* and end with a */ . Example: /* * Comments can, but don't have to, take * multiple lines if you use this form. */ x = 3 + 4; /* x is now 7 */ Comments of this form cannot be nested.","title":"Comments"},{"location":"tutorials/comments/#comments","text":"Comments are used to make your code more human-readable. They are ignored by the computer. SurgeScript allows two kinds of comments: single-line comments and multi-line comments.","title":"Comments"},{"location":"tutorials/comments/#single-line-comments","text":"Single-line comments start with a // . Example: // This line has no effect on the code (it's just for improved readability) x = 3 + 4; // x is now 7","title":"Single-line comments"},{"location":"tutorials/comments/#multi-line-comments","text":"Multi-line comments start with a /* and end with a */ . Example: /* * Comments can, but don't have to, take * multiple lines if you use this form. */ x = 3 + 4; /* x is now 7 */ Comments of this form cannot be nested.","title":"Multi-line comments"},{"location":"tutorials/components/","text":"Components Entity Component System (ECS) is a software pattern used in game development. The idea is that in-game objects (called entities ) can be customized by adding or removing objects (called components ) during runtime. Components add functionalities or behaviors to the entities to which they are attached to. In SurgeScript, both entities and components are objects - the difference is conceptual. As an example, consider an in-game object called Parrot . Objects by themselves are empty; they do nothing. However, an interesting behavior of parrots is that they are blabbers: they keep repeating the same thing over and over again. So, let's create an empty object Parrot and spawn on it the Blabber component: object Parrot is entity { blabber = spawn( Blabber ); state main { } } object Blabber { state main { if(timeout(2)) // blab every 2 seconds state = blab ; } state blab { Console.print( Hello! ); state = main ; } } Now, whenever you spawn a Parrot, it will keep blabbing ( parroting ) unceasingly: Hello! Hello! Hello! ... Suppose now that your Parrot is a Kamikaze Robot: it blabs so much that it will explode itself after some time. We'll attach a Time Bomb to the parroting robot, so that it will stop blabbing after a while: object Time Bomb { state main { if(timeout(15)) // explode after 15 seconds state = explode ; } state explode { Console.print( BOOOM! ); parent.destroy(); // destroy the parent object } } object Parrot is entity { blabber = spawn( Blabber ); bomb = spawn( Time Bomb ); state main { } } Now, here's the result: Hello! Hello! Hello! Hello! Hello! Hello! Hello! BOOOM! In this example, Parrot is an entity and Blabber and Time Bomb are its components. Once the entity is destroyed, its components (its children) are also destroyed automatically. Design considerations In some implementations of ECS, entities are implemented as integers and components consist of raw data only. The game logic is executed by the System layer, which iterates throughout all entities continuously and executes the logic according to the components attached to them. In SurgeScript, components execute their own code and can be attached to entities simply by spawning them as children. Still, you can use the former approach if you wish to do so. Composition over inheritance SurgeScript does not support inheritance, a feature found in other object-oriented languages. The usage of components is encouraged instead. SurgeScript favors composition over inheritance, allowing for greater flexibility when defining in-game objects.","title":"Components"},{"location":"tutorials/components/#components","text":"Entity Component System (ECS) is a software pattern used in game development. The idea is that in-game objects (called entities ) can be customized by adding or removing objects (called components ) during runtime. Components add functionalities or behaviors to the entities to which they are attached to. In SurgeScript, both entities and components are objects - the difference is conceptual. As an example, consider an in-game object called Parrot . Objects by themselves are empty; they do nothing. However, an interesting behavior of parrots is that they are blabbers: they keep repeating the same thing over and over again. So, let's create an empty object Parrot and spawn on it the Blabber component: object Parrot is entity { blabber = spawn( Blabber ); state main { } } object Blabber { state main { if(timeout(2)) // blab every 2 seconds state = blab ; } state blab { Console.print( Hello! ); state = main ; } } Now, whenever you spawn a Parrot, it will keep blabbing ( parroting ) unceasingly: Hello! Hello! Hello! ... Suppose now that your Parrot is a Kamikaze Robot: it blabs so much that it will explode itself after some time. We'll attach a Time Bomb to the parroting robot, so that it will stop blabbing after a while: object Time Bomb { state main { if(timeout(15)) // explode after 15 seconds state = explode ; } state explode { Console.print( BOOOM! ); parent.destroy(); // destroy the parent object } } object Parrot is entity { blabber = spawn( Blabber ); bomb = spawn( Time Bomb ); state main { } } Now, here's the result: Hello! Hello! Hello! Hello! Hello! Hello! Hello! BOOOM! In this example, Parrot is an entity and Blabber and Time Bomb are its components. Once the entity is destroyed, its components (its children) are also destroyed automatically.","title":"Components"},{"location":"tutorials/components/#design-considerations","text":"In some implementations of ECS, entities are implemented as integers and components consist of raw data only. The game logic is executed by the System layer, which iterates throughout all entities continuously and executes the logic according to the components attached to them. In SurgeScript, components execute their own code and can be attached to entities simply by spawning them as children. Still, you can use the former approach if you wish to do so.","title":"Design considerations"},{"location":"tutorials/components/#composition-over-inheritance","text":"SurgeScript does not support inheritance, a feature found in other object-oriented languages. The usage of components is encouraged instead. SurgeScript favors composition over inheritance, allowing for greater flexibility when defining in-game objects.","title":"Composition over inheritance"},{"location":"tutorials/conditionals/","text":"Conditionals Introduction Conditionals are if ... then ... statements. If a certain condition evaluates to true , execute a block of code. If not, don't execute it. if(condition) { // this will be executed only if // the condition is true } Alternatively, we may include an else statement followed by a block of code that will only be executed if the condition is not true: if(condition) { // this will be executed only if // the condition is true } else { // this will be executed only if // the condition is false } Example The following example will print underaged if variable age is less than 18, or adult otherwise: object Application { age = 23; state main { if(age 18) { // variable age is less than 18 Console.print( underaged ); } else { // variable age is not less than 18 Console.print( adult ); } } } Inline conditionals Just like other languages with C-based syntax, the expression condition ? true_value : false_value evaluates to true_value if condition is true and to false_value if condition is false . For example, the script below will print underaged if variable age is less than 18, or adult otherwise: object Application { age = 23; message = age 18 ? underaged : adult ; state main { Console.print(message); } }","title":"Conditionals"},{"location":"tutorials/conditionals/#conditionals","text":"","title":"Conditionals"},{"location":"tutorials/conditionals/#introduction","text":"Conditionals are if ... then ... statements. If a certain condition evaluates to true , execute a block of code. If not, don't execute it. if(condition) { // this will be executed only if // the condition is true } Alternatively, we may include an else statement followed by a block of code that will only be executed if the condition is not true: if(condition) { // this will be executed only if // the condition is true } else { // this will be executed only if // the condition is false }","title":"Introduction"},{"location":"tutorials/conditionals/#example","text":"The following example will print underaged if variable age is less than 18, or adult otherwise: object Application { age = 23; state main { if(age 18) { // variable age is less than 18 Console.print( underaged ); } else { // variable age is not less than 18 Console.print( adult ); } } }","title":"Example"},{"location":"tutorials/conditionals/#inline-conditionals","text":"Just like other languages with C-based syntax, the expression condition ? true_value : false_value evaluates to true_value if condition is true and to false_value if condition is false . For example, the script below will print underaged if variable age is less than 18, or adult otherwise: object Application { age = 23; message = age 18 ? underaged : adult ; state main { Console.print(message); } }","title":"Inline conditionals"},{"location":"tutorials/expressions/","text":"Expressions SurgeScript supports many kinds of expressions. Expressions may involve strings, numbers or booleans. Let's study each case: Constants Constants are types of expressions. They may be numbers, strings, booleans... You may attribute constant values to variables using the assignment operator ( = ): // strings name = Surge ; // variable name receives string Surge message = Surge's home ; otherMessage = 'Single-quoted strings are also allowed'; // numbers weight = 35; speed = 42.2; // booleans like = true; crazy = false; // null next = null; Arithmetic operators SurgeScript can perform basic arithmetic. The operators are as follows: Operator Meaning + Addition - Subtraction * Multiplication / Division % Remainder The multiplication, division and remainder operators have precedence over the addition and the subtraction operators. Examples: two = 1 + 1; ten = 5 * 2; eleven = 5 * 2 + 1; four = two * two; fifteen = eleven + four; three = fifteen / 5; positive = +5; negative = -1; zero = 15 - 10 - 5; one = 15 - (10 + 4); twelve = (2 + 2) * 3; prime = -(-15 + 8); seven = 5 + 5 % 3; negativeTwo = -5 % 3; Comparison operators Comparison operators compare two operands. Operator Meaning == Equality operator != Inequality operator Less than = Less or equal > Greater than >= Greater or equal === Strong equality !== Strong inequality Examples: x = 1; y = (x == 1); // y is true z = (x != 1); // z is false w = x 1; // w is false t = x = 1; // t is true Pay attention! Notice that the equality operator, used for comparing expressions for equality, is == . Pay attention! Don't confuse the equality operator ( == ) with the assignment operator ( = ). The expression (x = 1) always evaluates to 1, whereas (x == 1) is true only if x equals 1. Strong equality Unlike their counterparts, strong equality/inequality operators compare not only the content of the operands, but also their type. While \"1\" == 1 evalutes to true , \"1\" === 1 does not. Logical operators Logical operators involve booleans ( true or false values). While the not operator requires only one operand, operators and and or require two. Operator Meaning and || or ! not The table below summarizes the basic logical expressions: Expression Result a b true only if both a and b are true a || b true if either a or b are true (or both) !a true if a is false, false if a is true Notice that not has higher precedence than the other two operators. Examples: x = 5 2; // evaluates to false y = !x; // evaluates to true z = 18 35 || x; // evaluates to true w = (z x) || true; // evaluates to true t = !x x; // evaluates to false Textual expressions You may concatenate strings with the + operator. Example: message = Surge + rocks! ; // evaluates to Surge rocks! Other data types, such as numbers and booleans, may also be implicitly converted to strings when using this feature. Example: group = Jackson + 5; // evaluates to Jackson 5 Assignment operators The attribution operator ( = ) may be used to attribute data to variables. However, there's more to that. The expression variable = \"data\" is itself evaluated to string \"data\" . Likewise, the expression variable = variable + 5 is evaluated to variable + 5 and may be shortened to variable += 5 . Let's see what kind of assignment expressions we have: Expression Translates to Meaning x = value x = value Assigns value to x x += value x = x + value Adds value to x x -= value x = x - value Subtracts value from x x *= value x = x * value Multiplies x by value x /= value x = x / value Divides x by value x %= value x = x % value Sets x to the remainder of x / value Example: language = Surge ; language += Script ; // language now evaluates to SurgeScript number = 5; number += 2; // number now evaluates to 7 Increment and decrement Increment and decrement operators should be used only on numeric variables. Expression Meaning x++ Increments x by 1 and returns the old value of x x-- Decrements x by 1 and returns the old value of x ++x Increments x by 1 and returns the new value of x --x Decrements x by 1 and returns the new value of x Example: x = 1; // x is 1 y = x++; // y is 1 z = ++x; // z is 3 w = --x; // w is 2 t = --x; // t is 1 Console.print(x); // prints 1 Chained expressions You may chain assignment operations: x = y = z = 1; Using commas will evaluate all expressions between then and return the right-most one: x = 1; // x is 1 y = x++, 2; // y is 2 z = y--, --x; // z is 1 // x, y and z end up equal to 1 Other expressions this The keyword this represents the object in which it appears. Example: this.destroy(); // destroys this object typeof The expression typeof(expr) (or simply typeof expr ), is evaluated to a string informing the type of expr . The possible types are: number , string , boolean , null , object . Example: t = typeof 5; // t will hold the string number timeout The expression timeout(seconds) is a handy feature of SurgeScript. It is evaluated to true if the object has been on the same state for the specified amount of time or more. It can only be used inside states. Example: object Application { state main { if(timeout(2.0)) { Console.print( 2 seconds have passed ); state = done ; } } state done { } }","title":"Expressions"},{"location":"tutorials/expressions/#expressions","text":"SurgeScript supports many kinds of expressions. Expressions may involve strings, numbers or booleans. Let's study each case:","title":"Expressions"},{"location":"tutorials/expressions/#constants","text":"Constants are types of expressions. They may be numbers, strings, booleans... You may attribute constant values to variables using the assignment operator ( = ): // strings name = Surge ; // variable name receives string Surge message = Surge's home ; otherMessage = 'Single-quoted strings are also allowed'; // numbers weight = 35; speed = 42.2; // booleans like = true; crazy = false; // null next = null;","title":"Constants"},{"location":"tutorials/expressions/#arithmetic-operators","text":"SurgeScript can perform basic arithmetic. The operators are as follows: Operator Meaning + Addition - Subtraction * Multiplication / Division % Remainder The multiplication, division and remainder operators have precedence over the addition and the subtraction operators. Examples: two = 1 + 1; ten = 5 * 2; eleven = 5 * 2 + 1; four = two * two; fifteen = eleven + four; three = fifteen / 5; positive = +5; negative = -1; zero = 15 - 10 - 5; one = 15 - (10 + 4); twelve = (2 + 2) * 3; prime = -(-15 + 8); seven = 5 + 5 % 3; negativeTwo = -5 % 3;","title":"Arithmetic operators"},{"location":"tutorials/expressions/#comparison-operators","text":"Comparison operators compare two operands. Operator Meaning == Equality operator != Inequality operator Less than = Less or equal > Greater than >= Greater or equal === Strong equality !== Strong inequality Examples: x = 1; y = (x == 1); // y is true z = (x != 1); // z is false w = x 1; // w is false t = x = 1; // t is true Pay attention! Notice that the equality operator, used for comparing expressions for equality, is == . Pay attention! Don't confuse the equality operator ( == ) with the assignment operator ( = ). The expression (x = 1) always evaluates to 1, whereas (x == 1) is true only if x equals 1. Strong equality Unlike their counterparts, strong equality/inequality operators compare not only the content of the operands, but also their type. While \"1\" == 1 evalutes to true , \"1\" === 1 does not.","title":"Comparison operators"},{"location":"tutorials/expressions/#logical-operators","text":"Logical operators involve booleans ( true or false values). While the not operator requires only one operand, operators and and or require two. Operator Meaning and || or ! not The table below summarizes the basic logical expressions: Expression Result a b true only if both a and b are true a || b true if either a or b are true (or both) !a true if a is false, false if a is true Notice that not has higher precedence than the other two operators. Examples: x = 5 2; // evaluates to false y = !x; // evaluates to true z = 18 35 || x; // evaluates to true w = (z x) || true; // evaluates to true t = !x x; // evaluates to false","title":"Logical operators"},{"location":"tutorials/expressions/#textual-expressions","text":"You may concatenate strings with the + operator. Example: message = Surge + rocks! ; // evaluates to Surge rocks! Other data types, such as numbers and booleans, may also be implicitly converted to strings when using this feature. Example: group = Jackson + 5; // evaluates to Jackson 5","title":"Textual expressions"},{"location":"tutorials/expressions/#assignment-operators","text":"The attribution operator ( = ) may be used to attribute data to variables. However, there's more to that. The expression variable = \"data\" is itself evaluated to string \"data\" . Likewise, the expression variable = variable + 5 is evaluated to variable + 5 and may be shortened to variable += 5 . Let's see what kind of assignment expressions we have: Expression Translates to Meaning x = value x = value Assigns value to x x += value x = x + value Adds value to x x -= value x = x - value Subtracts value from x x *= value x = x * value Multiplies x by value x /= value x = x / value Divides x by value x %= value x = x % value Sets x to the remainder of x / value Example: language = Surge ; language += Script ; // language now evaluates to SurgeScript number = 5; number += 2; // number now evaluates to 7","title":"Assignment operators"},{"location":"tutorials/expressions/#increment-and-decrement","text":"Increment and decrement operators should be used only on numeric variables. Expression Meaning x++ Increments x by 1 and returns the old value of x x-- Decrements x by 1 and returns the old value of x ++x Increments x by 1 and returns the new value of x --x Decrements x by 1 and returns the new value of x Example: x = 1; // x is 1 y = x++; // y is 1 z = ++x; // z is 3 w = --x; // w is 2 t = --x; // t is 1 Console.print(x); // prints 1","title":"Increment and decrement"},{"location":"tutorials/expressions/#chained-expressions","text":"You may chain assignment operations: x = y = z = 1; Using commas will evaluate all expressions between then and return the right-most one: x = 1; // x is 1 y = x++, 2; // y is 2 z = y--, --x; // z is 1 // x, y and z end up equal to 1","title":"Chained expressions"},{"location":"tutorials/expressions/#other-expressions","text":"","title":"Other expressions"},{"location":"tutorials/expressions/#this","text":"The keyword this represents the object in which it appears. Example: this.destroy(); // destroys this object","title":"this"},{"location":"tutorials/expressions/#typeof","text":"The expression typeof(expr) (or simply typeof expr ), is evaluated to a string informing the type of expr . The possible types are: number , string , boolean , null , object . Example: t = typeof 5; // t will hold the string number","title":"typeof"},{"location":"tutorials/expressions/#timeout","text":"The expression timeout(seconds) is a handy feature of SurgeScript. It is evaluated to true if the object has been on the same state for the specified amount of time or more. It can only be used inside states. Example: object Application { state main { if(timeout(2.0)) { Console.print( 2 seconds have passed ); state = done ; } } state done { } }","title":"timeout"},{"location":"tutorials/functions/","text":"Functions Functions are blocks of code that you can reuse throughout your program. They may receive input parameters and they always output something. The syntax is as follows: fun function_name(param_1, param_2, param_3, ..., param_n) { // block of code // to be executed } Functions may be associated to objects. Any function associated to an object may be used (called) by the object itself or by other objects. This means that functions are public (they are visible to the outside world). Note: functions should be defined after the states. Return statement Use the return statement to stop executing the function and to return some value to the caller. Example: // This function will return the double of input parameter x fun double(x) { return 2 * x; Console.print( This line will never be executed. ); } If no value is specified after the return keyword, the function will be stopped and its return value will be null . Additionally, if no return statement is found, then the return value will also be null . Note : an object state may also contain one or more return statements to stop the execution of its code. However, return values must not be specified in that context, since states do not return values. Simple example In the example below, we have an object called Calculator with two functions: greet() and sum() . greet() takes no input parameters and just greets the user. On the other hand, sum() takes two input parameters, a and b , and returns the sum a + b : object Calculator { fun greet() { Console.print( Hello! I am a Calculator! ); } fun sum(a, b) { return a + b; } } In function sum() , variables a and b hold the input data and are only visible inside the function. Now, let's create a program that uses this Calculator . Remember that the functions defined above can be called by any object, including Application : object Application { calculator = spawn( Calculator ); state main { // greet the user calculator.greet(); // do some computation result = calculator.sum(5, 7); Console.print(result); // we're done! //Application.exit(); } } The output of the above program is: Hello! I am a Calculator! 12 Notice that the Application does not need to know how the functions of the Calculator are implemented. It just needs to know what they do. This means that you may change the implementation of the Calculator without changing the Application , and the end-result will stay the same. Recursive functions In SurgeScript, a function is said to be recursive when it calls itself within its code. Recursion can be useful in many ways; namely, when you define a problem in terms of itself. In mathematics, the factorial of a non-negative integer number n , denoted as n! , is such an example: n! = { n * (n-1)! if n 1 { 1 otherwise One interesting example of recursion that arises in computer science is called the binary search algorithm. Given a sorted Array , the binary search finds the position of a target value without having to inspect the whole collection. In the example below, bsearch() is a recursive function: object BinarySearch { // Given an array *sorted in ascending order*, find() // finds the position of the target value in the array. // It returns its index, or -1 if the target is not found. fun find(array, value) { return bsearch(array, value, 0, array.length - 1); } // Performs a binary search in array[start..end] fun bsearch(array, value, start, end) { // get the middle point mid = start + Math.floor((end - start) / 2); // compare the middle point to the target value if(start end) return -1; // target not found else if(value == array[mid]) return mid; // found the target value else if(value array[mid]) return bsearch(array, value, start, mid - 1); else return bsearch(array, value, mid + 1, end); } } Recursive functions must have at least one base case. A base case is a scenario that does not need recursion to solve the problem. In the factorial example, the base case is n = 1 (the factorial is 1). In the binary search example, the base case is start end , meaning that the array is empty and the target value cannot be found, or value == array[mid] , meaning that the target value has been found at mid . ...as the sages say: to understand recursion, you must first understand recursion . Constructors and destructors In SurgeScript, constructors and destructors are special functions that are called whenever objects are created and destroyed, respectively. It's not mandatory to define them, but it may be useful to do so (you may want to set up things in your constructors, for example). Neither may receive any arguments (see also: modifier functions ). Let's take our Calculator again. In the following example, constructor() is called automatically whenever a Calculator object is created. Likewise, destructor() is called automatically when the object is destroyed. object Calculator { fun constructor() { Console.print( Creating a Calculator... ); } fun destructor() { Console.print( Destroying a Calculator... ); } fun greet() { Console.print( Hello! I am a Calculator! ); } fun sum(a, b) { return a + b; } } Now, if we run the Application of the previous section without any modification, the output of the program will be: Creating a Calculator... Hello! I am a Calculator! 12 Destroying a Calculator... Please note that, for any object, its constructor() runs before its main state.","title":"Functions"},{"location":"tutorials/functions/#functions","text":"Functions are blocks of code that you can reuse throughout your program. They may receive input parameters and they always output something. The syntax is as follows: fun function_name(param_1, param_2, param_3, ..., param_n) { // block of code // to be executed } Functions may be associated to objects. Any function associated to an object may be used (called) by the object itself or by other objects. This means that functions are public (they are visible to the outside world). Note: functions should be defined after the states.","title":"Functions"},{"location":"tutorials/functions/#return-statement","text":"Use the return statement to stop executing the function and to return some value to the caller. Example: // This function will return the double of input parameter x fun double(x) { return 2 * x; Console.print( This line will never be executed. ); } If no value is specified after the return keyword, the function will be stopped and its return value will be null . Additionally, if no return statement is found, then the return value will also be null . Note : an object state may also contain one or more return statements to stop the execution of its code. However, return values must not be specified in that context, since states do not return values.","title":"Return statement"},{"location":"tutorials/functions/#simple-example","text":"In the example below, we have an object called Calculator with two functions: greet() and sum() . greet() takes no input parameters and just greets the user. On the other hand, sum() takes two input parameters, a and b , and returns the sum a + b : object Calculator { fun greet() { Console.print( Hello! I am a Calculator! ); } fun sum(a, b) { return a + b; } } In function sum() , variables a and b hold the input data and are only visible inside the function. Now, let's create a program that uses this Calculator . Remember that the functions defined above can be called by any object, including Application : object Application { calculator = spawn( Calculator ); state main { // greet the user calculator.greet(); // do some computation result = calculator.sum(5, 7); Console.print(result); // we're done! //Application.exit(); } } The output of the above program is: Hello! I am a Calculator! 12 Notice that the Application does not need to know how the functions of the Calculator are implemented. It just needs to know what they do. This means that you may change the implementation of the Calculator without changing the Application , and the end-result will stay the same.","title":"Simple example"},{"location":"tutorials/functions/#recursive-functions","text":"In SurgeScript, a function is said to be recursive when it calls itself within its code. Recursion can be useful in many ways; namely, when you define a problem in terms of itself. In mathematics, the factorial of a non-negative integer number n , denoted as n! , is such an example: n! = { n * (n-1)! if n 1 { 1 otherwise One interesting example of recursion that arises in computer science is called the binary search algorithm. Given a sorted Array , the binary search finds the position of a target value without having to inspect the whole collection. In the example below, bsearch() is a recursive function: object BinarySearch { // Given an array *sorted in ascending order*, find() // finds the position of the target value in the array. // It returns its index, or -1 if the target is not found. fun find(array, value) { return bsearch(array, value, 0, array.length - 1); } // Performs a binary search in array[start..end] fun bsearch(array, value, start, end) { // get the middle point mid = start + Math.floor((end - start) / 2); // compare the middle point to the target value if(start end) return -1; // target not found else if(value == array[mid]) return mid; // found the target value else if(value array[mid]) return bsearch(array, value, start, mid - 1); else return bsearch(array, value, mid + 1, end); } } Recursive functions must have at least one base case. A base case is a scenario that does not need recursion to solve the problem. In the factorial example, the base case is n = 1 (the factorial is 1). In the binary search example, the base case is start end , meaning that the array is empty and the target value cannot be found, or value == array[mid] , meaning that the target value has been found at mid . ...as the sages say: to understand recursion, you must first understand recursion .","title":"Recursive functions"},{"location":"tutorials/functions/#constructors-and-destructors","text":"In SurgeScript, constructors and destructors are special functions that are called whenever objects are created and destroyed, respectively. It's not mandatory to define them, but it may be useful to do so (you may want to set up things in your constructors, for example). Neither may receive any arguments (see also: modifier functions ). Let's take our Calculator again. In the following example, constructor() is called automatically whenever a Calculator object is created. Likewise, destructor() is called automatically when the object is destroyed. object Calculator { fun constructor() { Console.print( Creating a Calculator... ); } fun destructor() { Console.print( Destroying a Calculator... ); } fun greet() { Console.print( Hello! I am a Calculator! ); } fun sum(a, b) { return a + b; } } Now, if we run the Application of the previous section without any modification, the output of the program will be: Creating a Calculator... Hello! I am a Calculator! 12 Destroying a Calculator... Please note that, for any object, its constructor() runs before its main state.","title":"Constructors and destructors"},{"location":"tutorials/hello/","text":"Hello, World! SurgeScript creates automatically an object called Application . That object is defined by the user. Let's see how we can use that to make a simple program: object Application { state main { Console.print( Hello, world! ); Application.exit(); } } In SurgeScript, each object defines a state machine (more on that later). The initial state is called main . In the code just presented, we display a Hello, world! message and then exit the app. Now let's test your scripts .","title":"Hello, World!"},{"location":"tutorials/hello/#hello-world","text":"SurgeScript creates automatically an object called Application . That object is defined by the user. Let's see how we can use that to make a simple program: object Application { state main { Console.print( Hello, world! ); Application.exit(); } } In SurgeScript, each object defines a state machine (more on that later). The initial state is called main . In the code just presented, we display a Hello, world! message and then exit the app. Now let's test your scripts .","title":"Hello, World!"},{"location":"tutorials/loops/","text":"Loops While loops In a while loop, you execute a certain block of code while a condition is true. The syntax is as follows: while(condition) { // block of code // to be executed } The example below counts from 1 to 10: i = 1; while(i = 10) { Console.print(i); i = i + 1; } For loops A for loop is a more controlled repetition structure when compared to the while loop. For loops support an initialization command, a condition and an increment command. The syntax is as follows: for(initialization; condition; increment) { // block of code // to be executed } The code just displayed is equivalent to: initialization; while(condition) { // block of code // to be executed increment; } The example below counts from 1 to 10: for(i = 1; i = 10; i++) { Console.print(i); } Foreach Foreach loops are used to iterate throughout collections (such as Arrays). Basically: for each element x in the collection, do something with x . The syntax is as follows: foreach(element in collection) { // block of code // to be executed } The example below counts from 1 to 10: collection = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; foreach(x in collection) { Console.print(x); }","title":"Loops"},{"location":"tutorials/loops/#loops","text":"","title":"Loops"},{"location":"tutorials/loops/#while-loops","text":"In a while loop, you execute a certain block of code while a condition is true. The syntax is as follows: while(condition) { // block of code // to be executed } The example below counts from 1 to 10: i = 1; while(i = 10) { Console.print(i); i = i + 1; }","title":"While loops"},{"location":"tutorials/loops/#for-loops","text":"A for loop is a more controlled repetition structure when compared to the while loop. For loops support an initialization command, a condition and an increment command. The syntax is as follows: for(initialization; condition; increment) { // block of code // to be executed } The code just displayed is equivalent to: initialization; while(condition) { // block of code // to be executed increment; } The example below counts from 1 to 10: for(i = 1; i = 10; i++) { Console.print(i); }","title":"For loops"},{"location":"tutorials/loops/#foreach","text":"Foreach loops are used to iterate throughout collections (such as Arrays). Basically: for each element x in the collection, do something with x . The syntax is as follows: foreach(element in collection) { // block of code // to be executed } The example below counts from 1 to 10: collection = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; foreach(x in collection) { Console.print(x); }","title":"Foreach"},{"location":"tutorials/object_tree/","text":"Object tree In SurgeScript, objects have a hierarchical relationship. Suppose that object P spawns (or instantiates ) object C. We say that object P is the parent of C. Similarly, object C is a child of P. An object may spawn many children. However, all objects have only one parent. This relationship between objects form a hierarchy (or a tree). The Figure below shows an example: In this example, Level is the parent of GameItem1 and GameItem2. Components A and B are children of GameItem1, but not of GameItem2. Level has two children and GameItem2 has zero. In SurgeScript, the root of the hierarchy is a predefined object called System . Its parent is itself. All other objects are descendants of System . Spawning objects You can use spawn() to instantiate an object. Example: object Parent { child = spawn( Child ); state main { } } object Child { state main { } } Function spawn() may be invoked on objects other than the caller. In this case, the caller won't be the parent of the newly created object: object Parent { child = spawn( Child ); grandChild = child.spawn( Child ); state main { } } Automatic Garbage Collection When you spawn an object, make sure you store a reference to it somewhere. If an object cannot be reached from the root (no reachable object has any references to it), it will be automatically destroyed by SurgeScript's built-in Garbage Collector. Destroying objects Objects can be destroyed manually by calling destroy() . Whenever an object is destroyed, its children are destroyed as well. object Foo { state main { Console.print( This object does nothing. ); destroy(); } } Traversing the hierarchy Relevant data about the object hierarchy can be obtained using the following properties and functions (read more on the Object reference ): Function / property Description obj.parent (read-only) The parent object obj.childCount (read-only) Number of immediate children obj.child(name) Gets a child object named name obj.findObject(name) Finds* a descendant named name obj.sibling(name) Gets a sibling** named name Notes: * findObject() may be slow, as it performs a deep search within the object tree. One is encouraged to cache the result of this function (for example, in the object constructor) and to avoid using it in states or loops. ** We say that two distinct objects are siblings if they share the same parent. Example: object Parent { child = spawn( Child ); otherChild = spawn( Child ); state main { Console.print( This object has + childCount + children. ); destroy(); } } The output is as follows: This object has 2 children.","title":"Object tree"},{"location":"tutorials/object_tree/#object-tree","text":"In SurgeScript, objects have a hierarchical relationship. Suppose that object P spawns (or instantiates ) object C. We say that object P is the parent of C. Similarly, object C is a child of P. An object may spawn many children. However, all objects have only one parent. This relationship between objects form a hierarchy (or a tree). The Figure below shows an example: In this example, Level is the parent of GameItem1 and GameItem2. Components A and B are children of GameItem1, but not of GameItem2. Level has two children and GameItem2 has zero. In SurgeScript, the root of the hierarchy is a predefined object called System . Its parent is itself. All other objects are descendants of System .","title":"Object tree"},{"location":"tutorials/object_tree/#spawning-objects","text":"You can use spawn() to instantiate an object. Example: object Parent { child = spawn( Child ); state main { } } object Child { state main { } } Function spawn() may be invoked on objects other than the caller. In this case, the caller won't be the parent of the newly created object: object Parent { child = spawn( Child ); grandChild = child.spawn( Child ); state main { } } Automatic Garbage Collection When you spawn an object, make sure you store a reference to it somewhere. If an object cannot be reached from the root (no reachable object has any references to it), it will be automatically destroyed by SurgeScript's built-in Garbage Collector.","title":"Spawning objects"},{"location":"tutorials/object_tree/#destroying-objects","text":"Objects can be destroyed manually by calling destroy() . Whenever an object is destroyed, its children are destroyed as well. object Foo { state main { Console.print( This object does nothing. ); destroy(); } }","title":"Destroying objects"},{"location":"tutorials/object_tree/#traversing-the-hierarchy","text":"Relevant data about the object hierarchy can be obtained using the following properties and functions (read more on the Object reference ): Function / property Description obj.parent (read-only) The parent object obj.childCount (read-only) Number of immediate children obj.child(name) Gets a child object named name obj.findObject(name) Finds* a descendant named name obj.sibling(name) Gets a sibling** named name Notes: * findObject() may be slow, as it performs a deep search within the object tree. One is encouraged to cache the result of this function (for example, in the object constructor) and to avoid using it in states or loops. ** We say that two distinct objects are siblings if they share the same parent. Example: object Parent { child = spawn( Child ); otherChild = spawn( Child ); state main { Console.print( This object has + childCount + children. ); destroy(); } } The output is as follows: This object has 2 children.","title":"Traversing the hierarchy"},{"location":"tutorials/objects/","text":"Introduction to objects In SurgeScript, objects are units of code and data. Each object defines a finite state machine, a mathematical construct used to describe the behavior of in-game objects. Did you know? Games implement what is called a game loop. In SurgeScript, the game loop is defined implicitly via state machines. State machines are one of the key features of SurgeScript. State machines A finite state machine is a mathematical abstraction composed of a finite number of states and by transitions between these states. Only one state can be active at any given time (we'll call it the active state). There must be one initial state (i.e., the first one to be active). A transition is a change of the active state that is triggered when a certain condition is met. As a concrete example, suppose that you want to create a door in your game. You, the developer, may open or close the door at will. But what is a door? We have just given informal description of the problem. However, we need to transform it in something more rigorous. Example: A door is an object with two states (see the Figure below): Opened (initial state) Closed From the Opened state, only one transition is possible: Close. Once the Close transition is called, the door will go to the Closed state. Conversely, from the Closed state, only one transition is available: Open. When the Open transition is executed, the door will return to the Opened state. Objects in SurgeScript In SurgeScript, each object has a name. Objects may have any number of states you'd like. The initial state is always called main . The syntax is as follows: object name of the object { state state name { // code goes here } } The following code shows an example of a door that opens and closes (it keep changing states) every 2 seconds: object Cosmic Door { state main { // the object starts at the main state state = opened ; // go to the opened state } state opened { if(timeout(2)) // if we have been on the opened state for 2+ seconds state = closed ; // go to the closed state } state closed { if(timeout(2)) state = opened ; } } Notice how the code just shown defines states and transitions between these states. Each state contains its own code. Note: once a state is active, its code will be repeated (at every frame of the application) until the state changes or until the object is destroyed.","title":"Introduction to objects"},{"location":"tutorials/objects/#introduction-to-objects","text":"In SurgeScript, objects are units of code and data. Each object defines a finite state machine, a mathematical construct used to describe the behavior of in-game objects. Did you know? Games implement what is called a game loop. In SurgeScript, the game loop is defined implicitly via state machines. State machines are one of the key features of SurgeScript.","title":"Introduction to objects"},{"location":"tutorials/objects/#state-machines","text":"A finite state machine is a mathematical abstraction composed of a finite number of states and by transitions between these states. Only one state can be active at any given time (we'll call it the active state). There must be one initial state (i.e., the first one to be active). A transition is a change of the active state that is triggered when a certain condition is met. As a concrete example, suppose that you want to create a door in your game. You, the developer, may open or close the door at will. But what is a door? We have just given informal description of the problem. However, we need to transform it in something more rigorous. Example: A door is an object with two states (see the Figure below): Opened (initial state) Closed From the Opened state, only one transition is possible: Close. Once the Close transition is called, the door will go to the Closed state. Conversely, from the Closed state, only one transition is available: Open. When the Open transition is executed, the door will return to the Opened state.","title":"State machines"},{"location":"tutorials/objects/#objects-in-surgescript","text":"In SurgeScript, each object has a name. Objects may have any number of states you'd like. The initial state is always called main . The syntax is as follows: object name of the object { state state name { // code goes here } } The following code shows an example of a door that opens and closes (it keep changing states) every 2 seconds: object Cosmic Door { state main { // the object starts at the main state state = opened ; // go to the opened state } state opened { if(timeout(2)) // if we have been on the opened state for 2+ seconds state = closed ; // go to the closed state } state closed { if(timeout(2)) state = opened ; } } Notice how the code just shown defines states and transitions between these states. Each state contains its own code. Note: once a state is active, its code will be repeated (at every frame of the application) until the state changes or until the object is destroyed.","title":"Objects in SurgeScript"},{"location":"tutorials/plugins/","text":"Plugins Plugins are objects that allow you to extend the functionalities of the language. Once declared, they can be imported anywhere in the code. They can also be easily shared with others, so everyone benefits. Available since: SurgeScript 0.5.2 Basic example Suppose you want to extend the language by adding new routines related to string manipulation. The routines you want will be used frequently throughout your project, and you'd like easy access to them. This makes it perfect for implementing them as a plugin. We'll define an object called StringUtils with a reverse() function that reverses a string. We make the object a plugin by annotating it with @Plugin . Take a look at the example below: // File: stringutils.ss @Plugin object StringUtils { fun reverse(str) { buf = ; for(i = str.length - 1; i = 0; i--) buf += str[i]; return buf; } } When you annotate an object definition with @Plugin , SurgeScript will spawn an instance of such an object before spawning the Application . Additionally, the plugin object may be imported anywhere with the using keyword: // File: app.ss using StringUtils; object Application { state main { str = StringUtils.reverse( alucard ); Console.print(str); // will print dracula exit(); } } Note: it's recommended not to include any special characters in the name of your plugins. In the example above, Application and StringUtils are located in two separate files. If you want to test them using the SurgeScript command line utility, pass both files as parameters: surgescript plugin.ss app.ss Spawning order Although plugins are spawned before the Application object, for the time being they are spawned in no particular order. You may not access a plugin from within the constructor of another plugin, as of now there is no dependency resolver implemented. Use the main state. Package example You may use the Plugin system to create an independent package that aggregates many functionalities. This lets you separate your code in coherent, logical units and also helps you to distribute it. Suppose that user Parrot , the owner of ParrotSoft , created SurgeScript utilities related to string manipulation, matrix math and complex numbers. He decided to share his code as a single package called ParrotSoft . Since he implemented getters for each of his utilities (see the code below), his package provides easy access to all of them. Furthermore, he annotated his package with @Plugin (but not the individual utilities), so his package can be accessed anywhere. // File: parrotsoft.ss @Plugin object ParrotSoft { matrices = spawn( ParrotMatrices ); complex = spawn( ParrotComplexNumbers ); stringUtils = spawn( ParrotStringUtils ); fun get_Matrices() { return matrices; } fun get_Complex() { return complex; } fun get_StringUtils() { return stringUtils; } } // ... A user of the ParrotSoft package may import Parrot 's utilities simply by importing the plugin. Individual utilities may also be imported. The code below shows a usage example: using ParrotSoft.Matrices.Matrix2; using ParrotSoft.Complex; using ParrotSoft; object Application { state main { identity = Matrix2([[1, 0], [0, 1]]); // 2x2 matrix z = Complex(2, 3); // 2 + 3i neon = ParrotSoft.StringUtils.reverse( noen ); exit(); } } In the example above, writing Complex is equivalent to writing ParrotSoft.Complex , since we imported this utility with using ParrotSoft.Complex . Notice that ParrotSoft implements a getter for Complex . Additionally, ParrotSoft has been annotated with @Plugin , but Complex has not . This means that the statement using Complex will not yield correct results - and it shouldn't, since Complex is a part of the ParrotSoft package that can only be accessed from it. Finally, since we haven't imported StringUtils explicitly, we type ParrotSoft.StringUtils to access it.","title":"Plugins"},{"location":"tutorials/plugins/#plugins","text":"Plugins are objects that allow you to extend the functionalities of the language. Once declared, they can be imported anywhere in the code. They can also be easily shared with others, so everyone benefits. Available since: SurgeScript 0.5.2","title":"Plugins"},{"location":"tutorials/plugins/#basic-example","text":"Suppose you want to extend the language by adding new routines related to string manipulation. The routines you want will be used frequently throughout your project, and you'd like easy access to them. This makes it perfect for implementing them as a plugin. We'll define an object called StringUtils with a reverse() function that reverses a string. We make the object a plugin by annotating it with @Plugin . Take a look at the example below: // File: stringutils.ss @Plugin object StringUtils { fun reverse(str) { buf = ; for(i = str.length - 1; i = 0; i--) buf += str[i]; return buf; } } When you annotate an object definition with @Plugin , SurgeScript will spawn an instance of such an object before spawning the Application . Additionally, the plugin object may be imported anywhere with the using keyword: // File: app.ss using StringUtils; object Application { state main { str = StringUtils.reverse( alucard ); Console.print(str); // will print dracula exit(); } } Note: it's recommended not to include any special characters in the name of your plugins. In the example above, Application and StringUtils are located in two separate files. If you want to test them using the SurgeScript command line utility, pass both files as parameters: surgescript plugin.ss app.ss Spawning order Although plugins are spawned before the Application object, for the time being they are spawned in no particular order. You may not access a plugin from within the constructor of another plugin, as of now there is no dependency resolver implemented. Use the main state.","title":"Basic example"},{"location":"tutorials/plugins/#package-example","text":"You may use the Plugin system to create an independent package that aggregates many functionalities. This lets you separate your code in coherent, logical units and also helps you to distribute it. Suppose that user Parrot , the owner of ParrotSoft , created SurgeScript utilities related to string manipulation, matrix math and complex numbers. He decided to share his code as a single package called ParrotSoft . Since he implemented getters for each of his utilities (see the code below), his package provides easy access to all of them. Furthermore, he annotated his package with @Plugin (but not the individual utilities), so his package can be accessed anywhere. // File: parrotsoft.ss @Plugin object ParrotSoft { matrices = spawn( ParrotMatrices ); complex = spawn( ParrotComplexNumbers ); stringUtils = spawn( ParrotStringUtils ); fun get_Matrices() { return matrices; } fun get_Complex() { return complex; } fun get_StringUtils() { return stringUtils; } } // ... A user of the ParrotSoft package may import Parrot 's utilities simply by importing the plugin. Individual utilities may also be imported. The code below shows a usage example: using ParrotSoft.Matrices.Matrix2; using ParrotSoft.Complex; using ParrotSoft; object Application { state main { identity = Matrix2([[1, 0], [0, 1]]); // 2x2 matrix z = Complex(2, 3); // 2 + 3i neon = ParrotSoft.StringUtils.reverse( noen ); exit(); } } In the example above, writing Complex is equivalent to writing ParrotSoft.Complex , since we imported this utility with using ParrotSoft.Complex . Notice that ParrotSoft implements a getter for Complex . Additionally, ParrotSoft has been annotated with @Plugin , but Complex has not . This means that the statement using Complex will not yield correct results - and it shouldn't, since Complex is a part of the ParrotSoft package that can only be accessed from it. Finally, since we haven't imported StringUtils explicitly, we type ParrotSoft.StringUtils to access it.","title":"Package example"},{"location":"tutorials/properties/","text":"Properties In SurgeScript, object-level variables are private. This means that these variables can only be accessed from the objects that defined them. However, SurgeScript features a syntactic sugar that allows objects to read and/or modify other objects' data in a way that looks like dealing with regular (public) variables. We'll call these \"variables\" properties . Defining properties Suppose you have an object called Animal with an object-level variable called sound and a function named speak() : object Animal { sound = meow! ; fun speak() { Console.print(sound); } } This object can only speak meow! Let's see: object Application { animal = spawn( Animal ); state main { animal.speak(); } } Run this script and you'll see: meow! meow! meow! meow! ... What if an external object could modify the sound of the animal? Trying to access animal.sound externally will trigger an error, unless you add the public specifier to your variable: object Animal { public sound = meow! ; fun speak() { Console.print(sound); } } Now, external objects may access (read and write) the sound variable (or property ): object Application { animal = spawn( Animal ); state main { animal.sound = woof! ; animal.speak(); } } Since SurgeScript 0.5.3, you may add the readonly modifier after the public specifier. Doing so disallows the modification of the property by external objects: object Animal { public readonly sound = meow! ; fun speak() { Console.print(sound); } } object Application { animal = spawn( Animal ); state main { //animal.sound = woof! ; // will trigger an error //Console.print(animal.sound); // this is allowed animal.speak(); } } Using getters and setters In reality, however, there are no public variables in SurgeScript. Behind the scenes, the language defines special functions called getters and setters that will perform the read/write logic for you. Rather than using public , you may want to define the getters and the setters yourself: object Animal { sound = meow! ; fun speak() { Console.print(sound); } fun set_sound(value) { sound = value; } fun get_sound() { return sound; } } This code is semantically the same; it's just a bit longer. An advantage of defining getters and setters by yourself is that you control how the data passes through the objects. You may want to validate the data before changing the internal variables of the objects, for example.","title":"Properties"},{"location":"tutorials/properties/#properties","text":"In SurgeScript, object-level variables are private. This means that these variables can only be accessed from the objects that defined them. However, SurgeScript features a syntactic sugar that allows objects to read and/or modify other objects' data in a way that looks like dealing with regular (public) variables. We'll call these \"variables\" properties .","title":"Properties"},{"location":"tutorials/properties/#defining-properties","text":"Suppose you have an object called Animal with an object-level variable called sound and a function named speak() : object Animal { sound = meow! ; fun speak() { Console.print(sound); } } This object can only speak meow! Let's see: object Application { animal = spawn( Animal ); state main { animal.speak(); } } Run this script and you'll see: meow! meow! meow! meow! ... What if an external object could modify the sound of the animal? Trying to access animal.sound externally will trigger an error, unless you add the public specifier to your variable: object Animal { public sound = meow! ; fun speak() { Console.print(sound); } } Now, external objects may access (read and write) the sound variable (or property ): object Application { animal = spawn( Animal ); state main { animal.sound = woof! ; animal.speak(); } } Since SurgeScript 0.5.3, you may add the readonly modifier after the public specifier. Doing so disallows the modification of the property by external objects: object Animal { public readonly sound = meow! ; fun speak() { Console.print(sound); } } object Application { animal = spawn( Animal ); state main { //animal.sound = woof! ; // will trigger an error //Console.print(animal.sound); // this is allowed animal.speak(); } }","title":"Defining properties"},{"location":"tutorials/properties/#using-getters-and-setters","text":"In reality, however, there are no public variables in SurgeScript. Behind the scenes, the language defines special functions called getters and setters that will perform the read/write logic for you. Rather than using public , you may want to define the getters and the setters yourself: object Animal { sound = meow! ; fun speak() { Console.print(sound); } fun set_sound(value) { sound = value; } fun get_sound() { return sound; } } This code is semantically the same; it's just a bit longer. An advantage of defining getters and setters by yourself is that you control how the data passes through the objects. You may want to validate the data before changing the internal variables of the objects, for example.","title":"Using getters and setters"},{"location":"tutorials/tags/","text":"Tags You may tag objects with as many tags as you want. Tags are a way of attributing categories to different objects. Syntax Tags should be placed right after the object name. Example: object Horse is animal , vehicle { state main { } } object Cat is animal { state main { } } object Car is vehicle { state main { } } Using tags You may check if an object has a particular tag with the hasTag() function (see the Object reference for more details): object Application { horse = spawn( Horse ); cat = spawn( Cat ); car = spawn( Car ); state main { // Horse is both an animal and a vehicle Console.print(horse.hasTag( animal )); // true Console.print(horse.hasTag( vehicle )); // true // Cat is an animal, but not a vehicle Console.print(cat.hasTag( animal )); // true Console.print(cat.hasTag( vehicle )); // false // Car is a vehicle, but not an animal Console.print(car.hasTag( animal )); // false Console.print(car.hasTag( vehicle )); // true } } Emoticons You may also tag objects with emoticons. The syntax is as follows: object Good Day is happy , sunny :) { ... } object Good Night is 3 { ... } The following emoticons are available for your pleasure: Emoticon Meaning $_$ Feelin' Rich 3 Lovin' it :) Happy :( Sad :P D'oh","title":"Tags"},{"location":"tutorials/tags/#tags","text":"You may tag objects with as many tags as you want. Tags are a way of attributing categories to different objects.","title":"Tags"},{"location":"tutorials/tags/#syntax","text":"Tags should be placed right after the object name. Example: object Horse is animal , vehicle { state main { } } object Cat is animal { state main { } } object Car is vehicle { state main { } }","title":"Syntax"},{"location":"tutorials/tags/#using-tags","text":"You may check if an object has a particular tag with the hasTag() function (see the Object reference for more details): object Application { horse = spawn( Horse ); cat = spawn( Cat ); car = spawn( Car ); state main { // Horse is both an animal and a vehicle Console.print(horse.hasTag( animal )); // true Console.print(horse.hasTag( vehicle )); // true // Cat is an animal, but not a vehicle Console.print(cat.hasTag( animal )); // true Console.print(cat.hasTag( vehicle )); // false // Car is a vehicle, but not an animal Console.print(car.hasTag( animal )); // false Console.print(car.hasTag( vehicle )); // true } }","title":"Using tags"},{"location":"tutorials/tags/#emoticons","text":"You may also tag objects with emoticons. The syntax is as follows: object Good Day is happy , sunny :) { ... } object Good Night is 3 { ... } The following emoticons are available for your pleasure: Emoticon Meaning $_$ Feelin' Rich 3 Lovin' it :) Happy :( Sad :P D'oh","title":"Emoticons"},{"location":"tutorials/testing/","text":"Testing your scripts There are two main ways to test your scripts: using the Open Surge game engine; using the SurgeScript standalone runtime (i.e., the version without a game engine). Using Open Surge To test a script on Open Surge, place it on the scripts/ folder and start the engine. Your test script must include an object called Application . Please remove the script after you're done with the testing. As an example, save the following script to scripts/hello.ss and start the engine: // hello.ss: test script // Please remove this file after you're done object Application { state main { Console.print( Hello, world! ); state = done ; } state done { } } You should see the Hello, world! message as a result. Ready to proceed? Let's go to Introduction to objects ! Using the standalone version If you've downloaded the standalone version of the language: First of all, save the following script to a file named hello.ss . For testing purposes, please place the file on the same directory as the surgescript executable. // hello.ss: test script object Application { state main { Console.print( Hello, world! ); Application.exit(); } } Then, open up a Terminal and type: cd /path/to/surgescript ./surgescript hello.ss If you're using Microsoft Windows, open up a Command Prompt and type: cd C:\\path\\to\\surgescript surgescript.exe hello.ss You should see the output of the script as a result: Hello, world! To begin our learning adventure, let's go to Introduction to objects .","title":"Testing your scripts"},{"location":"tutorials/testing/#testing-your-scripts","text":"There are two main ways to test your scripts: using the Open Surge game engine; using the SurgeScript standalone runtime (i.e., the version without a game engine).","title":"Testing your scripts"},{"location":"tutorials/testing/#using-open-surge","text":"To test a script on Open Surge, place it on the scripts/ folder and start the engine. Your test script must include an object called Application . Please remove the script after you're done with the testing. As an example, save the following script to scripts/hello.ss and start the engine: // hello.ss: test script // Please remove this file after you're done object Application { state main { Console.print( Hello, world! ); state = done ; } state done { } } You should see the Hello, world! message as a result. Ready to proceed? Let's go to Introduction to objects !","title":"Using Open Surge"},{"location":"tutorials/testing/#using-the-standalone-version","text":"If you've downloaded the standalone version of the language: First of all, save the following script to a file named hello.ss . For testing purposes, please place the file on the same directory as the surgescript executable. // hello.ss: test script object Application { state main { Console.print( Hello, world! ); Application.exit(); } } Then, open up a Terminal and type: cd /path/to/surgescript ./surgescript hello.ss If you're using Microsoft Windows, open up a Command Prompt and type: cd C:\\path\\to\\surgescript surgescript.exe hello.ss You should see the output of the script as a result: Hello, world! To begin our learning adventure, let's go to Introduction to objects .","title":"Using the standalone version"},{"location":"tutorials/variables/","text":"Variables Variables are used to store data. SurgeScript features five primitive types (number, string, boolean, null and object handle). Variables can also point to more complex data structures (such as arrays and dictionaries), but these are always objects. Types Primitive types Type Description Examples Number A floating-point number 1, 2, 3, 3.14159 String Some text \"Hello, world!\", 'single-quoted' Boolean True or false true, false Object Reference to an object Application, this, [ ] Null An empty value null As an example, the script below features an object with 3 variables that may be accessed throughout the whole object: object Application { name = Surge the Rabbit ; age = 23; underage = false; state main { Console.print(name); // Surge the Rabbit Console.print(age); // 23 } } Abstract types Arrays Arrays are collections of values that you may access using a zero-based index. Example: object Application { // The 'characters' array holds 3 strings characters = [ Surge , Neon , Charge ]; state main { // who are the characters? Console.print( The characters are: ); Console.print(characters[0]); // will print Surge Console.print(characters[1]); // will print Neon Console.print(characters[2]); // will print Charge // how many characters? Console.print( Number of characters: ); Console.print(characters.length); // will print 3 } } Arrays have many interesting properties and operations that you can see in the Language Reference . Dictionaries Dictionaries are collections of key-value pairs. In some programming languages, these are known as associative arrays or hash tables. Here's the syntax: object Application { // A dictionary that stores the weight (kg) of each character weight = { Surge : 35, Neon : 20, Charge : 37.5, Gimacian : 70 }; // print the weights state main { Console.print( Surge weighs + weight[ Surge ] + kg. ); Console.print( Neon weighs + weight[ Neon ] + kg. ); Console.print( Charge weighs + weight[ Charge ] + kg. ); Console.print( Gimacian weighs + weight[ Gimacian ] + kg. ); } } Dictionaries have many interesting properties and operations that you can see in the Language Reference . Cautionary note Whenever you define an array or a dictionary, you spawn a new object. One is advised to NOT define arrays or dictionaries within states, because the code within states run continuously. Therefore, new objects will be created at every frame, not just once. object Application { // arr will be instantiated once the object is created arr = [ 1, 2, 3 ]; // RIGHT! state main { // err is instantiated at every frame of the application, // thus memory is wasted with duplicate objects err = [ don't , do , this ]; // WRONG! } } Casting You can use type-casting to change the type of values from number to string, from string to number, from boolean to string and so on. Casting values is as simple as calling Number(value) , String(value) or Boolean(value) . Example: // Convert string to number str = 2 ; val = Number(str); // val is 2 // Convert number to string val = 123; str = String(val); // str is 123 When converting an object to a string, SurgeScript will implicitly call object.toString() . Scoping Variables that are defined before any state or function are object-level variables. They can be accessed throughout the whole object. On the other hand, variables used exclusively inside states or functions are local variables . This means that their lifespan is restricted to their own locus of code. object ScopeTest { name = Surge the Rabbit ; // object-level variable state main { weight = 35; // local variable state = print-data ; // change the state } state print-data { Console.print(name); // Surge the Rabbit Console.print(weight); // ERROR: weight is not defined } } Furthermore, object-level variables may only be accessed within the object. Other objects may not read or write the variables directly (in other words, variables are private to the objects). You need to define functions or getters and setters to accomplish that.","title":"Variables"},{"location":"tutorials/variables/#variables","text":"Variables are used to store data. SurgeScript features five primitive types (number, string, boolean, null and object handle). Variables can also point to more complex data structures (such as arrays and dictionaries), but these are always objects.","title":"Variables"},{"location":"tutorials/variables/#types","text":"","title":"Types"},{"location":"tutorials/variables/#primitive-types","text":"Type Description Examples Number A floating-point number 1, 2, 3, 3.14159 String Some text \"Hello, world!\", 'single-quoted' Boolean True or false true, false Object Reference to an object Application, this, [ ] Null An empty value null As an example, the script below features an object with 3 variables that may be accessed throughout the whole object: object Application { name = Surge the Rabbit ; age = 23; underage = false; state main { Console.print(name); // Surge the Rabbit Console.print(age); // 23 } }","title":"Primitive types"},{"location":"tutorials/variables/#abstract-types","text":"","title":"Abstract types"},{"location":"tutorials/variables/#arrays","text":"Arrays are collections of values that you may access using a zero-based index. Example: object Application { // The 'characters' array holds 3 strings characters = [ Surge , Neon , Charge ]; state main { // who are the characters? Console.print( The characters are: ); Console.print(characters[0]); // will print Surge Console.print(characters[1]); // will print Neon Console.print(characters[2]); // will print Charge // how many characters? Console.print( Number of characters: ); Console.print(characters.length); // will print 3 } } Arrays have many interesting properties and operations that you can see in the Language Reference .","title":"Arrays"},{"location":"tutorials/variables/#dictionaries","text":"Dictionaries are collections of key-value pairs. In some programming languages, these are known as associative arrays or hash tables. Here's the syntax: object Application { // A dictionary that stores the weight (kg) of each character weight = { Surge : 35, Neon : 20, Charge : 37.5, Gimacian : 70 }; // print the weights state main { Console.print( Surge weighs + weight[ Surge ] + kg. ); Console.print( Neon weighs + weight[ Neon ] + kg. ); Console.print( Charge weighs + weight[ Charge ] + kg. ); Console.print( Gimacian weighs + weight[ Gimacian ] + kg. ); } } Dictionaries have many interesting properties and operations that you can see in the Language Reference . Cautionary note Whenever you define an array or a dictionary, you spawn a new object. One is advised to NOT define arrays or dictionaries within states, because the code within states run continuously. Therefore, new objects will be created at every frame, not just once. object Application { // arr will be instantiated once the object is created arr = [ 1, 2, 3 ]; // RIGHT! state main { // err is instantiated at every frame of the application, // thus memory is wasted with duplicate objects err = [ don't , do , this ]; // WRONG! } }","title":"Dictionaries"},{"location":"tutorials/variables/#casting","text":"You can use type-casting to change the type of values from number to string, from string to number, from boolean to string and so on. Casting values is as simple as calling Number(value) , String(value) or Boolean(value) . Example: // Convert string to number str = 2 ; val = Number(str); // val is 2 // Convert number to string val = 123; str = String(val); // str is 123 When converting an object to a string, SurgeScript will implicitly call object.toString() .","title":"Casting"},{"location":"tutorials/variables/#scoping","text":"Variables that are defined before any state or function are object-level variables. They can be accessed throughout the whole object. On the other hand, variables used exclusively inside states or functions are local variables . This means that their lifespan is restricted to their own locus of code. object ScopeTest { name = Surge the Rabbit ; // object-level variable state main { weight = 35; // local variable state = print-data ; // change the state } state print-data { Console.print(name); // Surge the Rabbit Console.print(weight); // ERROR: weight is not defined } } Furthermore, object-level variables may only be accessed within the object. Other objects may not read or write the variables directly (in other words, variables are private to the objects). You need to define functions or getters and setters to accomplish that.","title":"Scoping"}]}