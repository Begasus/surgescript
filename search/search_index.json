{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to SurgeScript!\n\n\n\n\nSurgeScript is a scripting language for games. It has unique features that make it suitable for games - and it is extremely valuable for empowering users to generate their own content. Built originally for the Open Surge Engine, SurgeScript can be embedded into any C project.\n\n\nThe best way to try SurgeScript for the first time is to get \nOpen Surge\n. Alternatively, a standalone version of the language is also available on \nGitHub\n.\n\n\nIt's such a joy to program in SurgeScript! You and your users will love it.\n\n\n\n\nSurgeScript in a nutshell\n\n\nSurgeScript is:\n\n\n\n\nA scripting language for games\n\n\nEasy for beginners, powerful for experts\n\n\nFree and open-source\n\n\nObject-oriented, dynamically typed and based on state machines\n\n\nThe only programming language in the world that allows you to tag objects with emoticons (natively! ;)\n\n\n\n\nYou can start your learning adventure by checking the \nHello World Tutorial\n.\n\n\nWhy SurgeScript?\n\n\nUnlike other programming languages, SurgeScript is designed for games. In SurgeScript, you have a collection of objects. Objects are units featuring data and code. Each object defines a state machine, as well as a parent-child relationship to other objects. This proves to be hugely valuable for games, specially if you are going to support user-generated content.\n\n\nCreating new things and customizing game behaviors is easier than ever before, yet the language is powerful enough to bring many of the programming constructs that you find in regular object-oriented languages. An infinite amount of flexibility can be achieved through object composition.\n\n\nThe motivation behind SurgeScript is to allow players to unleash their creativity and build their own content with ease, flexibility and massive amounts of power.\n\n\nWho did this?\n\n\nSurgeScript was originally conceived by Alexandre Martins, a developer from Brazil. Many thanks to the Open Surge community for the continued feedback.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#welcome-to-surgescript", 
            "text": "SurgeScript is a scripting language for games. It has unique features that make it suitable for games - and it is extremely valuable for empowering users to generate their own content. Built originally for the Open Surge Engine, SurgeScript can be embedded into any C project.  The best way to try SurgeScript for the first time is to get  Open Surge . Alternatively, a standalone version of the language is also available on  GitHub .  It's such a joy to program in SurgeScript! You and your users will love it.", 
            "title": "Welcome to SurgeScript!"
        }, 
        {
            "location": "/#surgescript-in-a-nutshell", 
            "text": "SurgeScript is:   A scripting language for games  Easy for beginners, powerful for experts  Free and open-source  Object-oriented, dynamically typed and based on state machines  The only programming language in the world that allows you to tag objects with emoticons (natively! ;)   You can start your learning adventure by checking the  Hello World Tutorial .", 
            "title": "SurgeScript in a nutshell"
        }, 
        {
            "location": "/#why-surgescript", 
            "text": "Unlike other programming languages, SurgeScript is designed for games. In SurgeScript, you have a collection of objects. Objects are units featuring data and code. Each object defines a state machine, as well as a parent-child relationship to other objects. This proves to be hugely valuable for games, specially if you are going to support user-generated content.  Creating new things and customizing game behaviors is easier than ever before, yet the language is powerful enough to bring many of the programming constructs that you find in regular object-oriented languages. An infinite amount of flexibility can be achieved through object composition.  The motivation behind SurgeScript is to allow players to unleash their creativity and build their own content with ease, flexibility and massive amounts of power.", 
            "title": "Why SurgeScript?"
        }, 
        {
            "location": "/#who-did-this", 
            "text": "SurgeScript was originally conceived by Alexandre Martins, a developer from Brazil. Many thanks to the Open Surge community for the continued feedback.", 
            "title": "Who did this?"
        }, 
        {
            "location": "/download/", 
            "text": "Download SurgeScript\n\n\nThere are two ways to get SurgeScript:\n\n\n\n\nThe first is to get Open Surge. This is recommended for most users.\n\n\nThe second is to get the standalone version of the language. This is useful if you're a C developer and want to integrate SurgeScript into your own projects.\n\n\n\n\nGet Open Surge\n\n\nTo get Open Surge, go to its website \n(URL SOON)\n and follow the instructions.\n\n\nWhen you get Open Surge, you also get a full game engine featuring SurgeScript. This allows you to create your own scripts and games with plenty of interactivity and ease.\n\n\nOnce you download Open Surge, the next step is to \ncreate your first script\n.\n\n\nGet the standalone version\n\n\nTo get the standalone version, go to the \nSurgeScript page on GitHub\n. There you'll find instructions on how to compile SurgeScript.\n\n\nWhen you compile SurgeScript, you'll end up with a text-only program. There are no graphics and no game engine is attached to it. You can try your scripts using the command line.\n\n\nOnce you get the standalone version, the next step is to \ncreate your first script\n.", 
            "title": "Download"
        }, 
        {
            "location": "/download/#download-surgescript", 
            "text": "There are two ways to get SurgeScript:   The first is to get Open Surge. This is recommended for most users.  The second is to get the standalone version of the language. This is useful if you're a C developer and want to integrate SurgeScript into your own projects.", 
            "title": "Download SurgeScript"
        }, 
        {
            "location": "/download/#get-open-surge", 
            "text": "To get Open Surge, go to its website  (URL SOON)  and follow the instructions.  When you get Open Surge, you also get a full game engine featuring SurgeScript. This allows you to create your own scripts and games with plenty of interactivity and ease.  Once you download Open Surge, the next step is to  create your first script .", 
            "title": "Get Open Surge"
        }, 
        {
            "location": "/download/#get-the-standalone-version", 
            "text": "To get the standalone version, go to the  SurgeScript page on GitHub . There you'll find instructions on how to compile SurgeScript.  When you compile SurgeScript, you'll end up with a text-only program. There are no graphics and no game engine is attached to it. You can try your scripts using the command line.  Once you get the standalone version, the next step is to  create your first script .", 
            "title": "Get the standalone version"
        }, 
        {
            "location": "/tutorials/hello/", 
            "text": "Hello, World!\n\n\nSurgeScript creates automatically an object called \nApplication\n. That object is defined by the user. Let's see how we can use that to make a simple program:\n\n\nobject \nApplication\n\n{\n    state \nmain\n\n    {\n        Console.print(\nHello, world!\n);\n        Application.exit();\n    }\n}\n\n\n\n\nIn SurgeScript, each object defines a state machine (more on that later). The initial state is called \nmain\n. In the code just presented, we display a \nHello, world!\n message and then exit the app.\n\n\nLet's go on and read \nIntroduction to objects\n. Or, alternatively, you may want to \ntest your scripts\n.", 
            "title": "Hello, World!"
        }, 
        {
            "location": "/tutorials/hello/#hello-world", 
            "text": "SurgeScript creates automatically an object called  Application . That object is defined by the user. Let's see how we can use that to make a simple program:  object  Application \n{\n    state  main \n    {\n        Console.print( Hello, world! );\n        Application.exit();\n    }\n}  In SurgeScript, each object defines a state machine (more on that later). The initial state is called  main . In the code just presented, we display a  Hello, world!  message and then exit the app.  Let's go on and read  Introduction to objects . Or, alternatively, you may want to  test your scripts .", 
            "title": "Hello, World!"
        }, 
        {
            "location": "/tutorials/testing/", 
            "text": "Testing your scripts\n\n\nThere are two main ways to test your scripts: using the \nOpen Surge Engine\n or the \nstandalone version\n of SurgeScript (i.e., the version without the game engine).\n\n\nTesting on Open Surge\n\n\nTODO\n\n\nTesting using the standalone version\n\n\nIf you've downloaded the standalone version of the language:\n\n\n\n\nFirst of all, save the following script to a file named \nhello.ss\n. This file should be placed on the same directory as the surgescript executable.\n\n\n\n\nobject \nApplication\n\n{\n    state \nmain\n\n    {\n        Console.print(\nHello, world!\n);\n        Application.exit();\n    }\n}\n\n\n\n\n\n\nThen, open up a Terminal and type:\n\n\n\n\ncd /path/to/surgescript\n./surgescript hello.ss\n\n\n\n\n\n\nIf you're using Microsoft Windows, open up a Command Prompt and type:\n\n\n\n\ncd C:\\path\\to\\surgescript\nsurgescript.exe hello.ss\n\n\n\n\n\n\nYou should see the output of the script as a result:\n\n\n\n\nHello, world!", 
            "title": "Testing your scripts"
        }, 
        {
            "location": "/tutorials/testing/#testing-your-scripts", 
            "text": "There are two main ways to test your scripts: using the  Open Surge Engine  or the  standalone version  of SurgeScript (i.e., the version without the game engine).", 
            "title": "Testing your scripts"
        }, 
        {
            "location": "/tutorials/testing/#testing-on-open-surge", 
            "text": "TODO", 
            "title": "Testing on Open Surge"
        }, 
        {
            "location": "/tutorials/testing/#testing-using-the-standalone-version", 
            "text": "If you've downloaded the standalone version of the language:   First of all, save the following script to a file named  hello.ss . This file should be placed on the same directory as the surgescript executable.   object  Application \n{\n    state  main \n    {\n        Console.print( Hello, world! );\n        Application.exit();\n    }\n}   Then, open up a Terminal and type:   cd /path/to/surgescript\n./surgescript hello.ss   If you're using Microsoft Windows, open up a Command Prompt and type:   cd C:\\path\\to\\surgescript\nsurgescript.exe hello.ss   You should see the output of the script as a result:   Hello, world!", 
            "title": "Testing using the standalone version"
        }, 
        {
            "location": "/tutorials/objects/", 
            "text": "Introduction to objects\n\n\nIn SurgeScript, objects are units of code and data. Each object define a finite state machine, a mathematical construct used to describe the behavior of in-game objects. But what's a finite state machine?\n\n\nState machines\n\n\nA finite state machine is a mathematical abstraction composed of a finite number of \nstates\n and by \ntransitions\n between these states. Only one state can be active at any given time (we'll call it the active state). There must be one \ninitial state\n (i.e., the first one to be active). A transition is a change of the active state that is triggered when a certain condition is met.\n\n\nAs a concrete example, suppose that you want to create a door in your game. You, the developer, may open or close the door at will.\n\n\nThat is said to be an \ninformal\n description of the problem. We need to transform it in something more rigorous. What is a door? We'll show one possible solution here.\n\n\nA door is an object with two states (see the Figure below):\n\n\n\n\nOpened (initial state)\n\n\nClosed\n\n\n\n\n\n\nFrom the Opened state, only one transition is possible: Close. Once the Close transition is called, the door will go to the Closed state. Conversely, from the Closed state, only one transition is available: Open. When the Open transition is executed, the door will return to the Opened state.\n\n\nObjects in SurgeScript\n\n\nIn SurgeScript, each object has a name. Objects may have any number of states you'd like. The initial state is always called \nmain\n. The syntax is as follows:\n\n\nobject \nname of the object\n\n{\n    state \nstate name\n\n    {\n        // code goes here\n    }\n}\n\n\n\n\nThe following code shows an example of a door that opens and closes (it keep changing states) every 2 seconds:\n\n\nobject \nCosmic Door\n\n{\n    state \nmain\n\n    {\n        // the object starts at the main state\n        state = \nopened\n; // go to the opened state\n    }\n\n    state \nopened\n\n    {\n        if(timeout(2)) // if we have been on the opened state for 2+ seconds\n            state = \nclosed\n; // go to the closed state\n    }\n\n    state \nclosed\n\n    {\n        if(timeout(2))\n            state = \nopened\n;\n    }\n}\n\n\n\n\nNotice how the code just shown defines states and transitions between these states. Each state contains its own code.\n\n\nNote:\n once a state is active, its code will be repeated (at every frame) until the state changes or until the object is destroyed.", 
            "title": "Introduction to objects"
        }, 
        {
            "location": "/tutorials/objects/#introduction-to-objects", 
            "text": "In SurgeScript, objects are units of code and data. Each object define a finite state machine, a mathematical construct used to describe the behavior of in-game objects. But what's a finite state machine?", 
            "title": "Introduction to objects"
        }, 
        {
            "location": "/tutorials/objects/#state-machines", 
            "text": "A finite state machine is a mathematical abstraction composed of a finite number of  states  and by  transitions  between these states. Only one state can be active at any given time (we'll call it the active state). There must be one  initial state  (i.e., the first one to be active). A transition is a change of the active state that is triggered when a certain condition is met.  As a concrete example, suppose that you want to create a door in your game. You, the developer, may open or close the door at will.  That is said to be an  informal  description of the problem. We need to transform it in something more rigorous. What is a door? We'll show one possible solution here.  A door is an object with two states (see the Figure below):   Opened (initial state)  Closed    From the Opened state, only one transition is possible: Close. Once the Close transition is called, the door will go to the Closed state. Conversely, from the Closed state, only one transition is available: Open. When the Open transition is executed, the door will return to the Opened state.", 
            "title": "State machines"
        }, 
        {
            "location": "/tutorials/objects/#objects-in-surgescript", 
            "text": "In SurgeScript, each object has a name. Objects may have any number of states you'd like. The initial state is always called  main . The syntax is as follows:  object  name of the object \n{\n    state  state name \n    {\n        // code goes here\n    }\n}  The following code shows an example of a door that opens and closes (it keep changing states) every 2 seconds:  object  Cosmic Door \n{\n    state  main \n    {\n        // the object starts at the main state\n        state =  opened ; // go to the opened state\n    }\n\n    state  opened \n    {\n        if(timeout(2)) // if we have been on the opened state for 2+ seconds\n            state =  closed ; // go to the closed state\n    }\n\n    state  closed \n    {\n        if(timeout(2))\n            state =  opened ;\n    }\n}  Notice how the code just shown defines states and transitions between these states. Each state contains its own code.  Note:  once a state is active, its code will be repeated (at every frame) until the state changes or until the object is destroyed.", 
            "title": "Objects in SurgeScript"
        }, 
        {
            "location": "/tutorials/variables/", 
            "text": "Variables\n\n\nVariables are used to store data. SurgeScript features five primitive types (number, string, boolean, null and object handle). Variables can also point to more complex data structures (such as arrays and dictionaries), but these are always objects.\n\n\nTypes\n\n\nPrimitive types\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nExamples\n\n\n\n\n\n\n\n\n\n\nNumber\n\n\nA floating-point number\n\n\n1, 2, 3, 3.14159\n\n\n\n\n\n\nString\n\n\nSome text\n\n\n\"Hello, world!\", 'single-quoted'\n\n\n\n\n\n\nBoolean\n\n\nTrue or false\n\n\ntrue, false\n\n\n\n\n\n\nObject\n\n\nReference to an object\n\n\nApplication, this, [ ]\n\n\n\n\n\n\nNull\n\n\nAn empty value\n\n\nnull\n\n\n\n\n\n\n\n\nAs an example, the script below features an object with 3 variables that may be accessed throughout the whole object:\n\n\nobject \nSurge\n\n{\n    name = \nSurge the Rabbit\n;\n    age = 23;\n    underage = false;\n\n    state \nmain\n\n    {\n        Console.print(name); // Surge the Rabbit\n        Console.print(age); // 23\n    }\n}\n\n\n\n\nAbstract types\n\n\nArrays\n\n\nArrays are collections of values that you may access using a zero-based index. Example:\n\n\nobject \nApplication\n\n{\n    // The 'characters' array hold 3 strings\n    characters = [ \nSurge\n, \nNeon\n, \nCharge\n ];\n\n    state \nmain\n\n    {\n        // who are the characters?\n        Console.print(\nThe characters are:\n);\n        Console.print(characters[0]); // will print Surge\n        Console.print(characters[1]); // will print Neon\n        Console.print(characters[2]); // will print Charge\n\n        // how many characters?\n        Console.print(\nNumber of characters:\n);\n        Console.print(characters.length); // will print 3\n    }\n}\n\n\n\n\nArrays have many interesting properties and operations that you can see in the \nLanguage Reference\n.\n\n\nDictionaries\n\n\nDictionaries are collections of key-value pairs. In some programming languages, these are known as associative arrays or hash tables. Here's the syntax:\n\n\nobject \nSurge\n\n{\n    // A dictionary that stores the weight (kg) of each character\n    weight = {\n        \nSurge\n: 35,\n        \nNeon\n: 20,\n        \nCharge\n: 37.5,\n        \nGimacian\n: 70\n    };\n\n    // print the weights\n    state \nmain\n\n    {\n        Console.print(\nSurge weighs \n + weight[\nSurge\n] + \n kg.\n);\n        Console.print(\nNeon weighs \n + weight[\nNeon\n] + \n kg.\n);\n        Console.print(\nCharge weighs \n + weight[\nCharge\n] + \n kg.\n);\n        Console.print(\nGimacian weighs \n + weight[\nGimacian\n] + \n kg.\n);\n    }\n}\n\n\n\n\nDictionaries have many interesting properties and operations that you can see in the \nLanguage Reference\n.\n\n\n\n\nCautionary note\n\n\nWhenever you define an array or a dictionary, you spawn a new object. One is advised to \nNOT\n define arrays or dictionaries within states, because the code within states run continuously. Therefore, new objects will be created at every frame, not just once.\n\n\n\n\nobject \nApplication\n\n{\n    // arr will be instantiated once the object is created\n    arr = [ 1, 2, 3 ]; // RIGHT!\n\n    state \nmain\n\n    {\n        // err is instantiated at every frame of the application,\n        // thus memory is wasted with duplicate objects\n        err = [ \ndon't\n, \ndo\n, \nthis\n ]; // WRONG!\n    }\n}\n\n\n\n\nScoping\n\n\nVariables that are defined before any state or function are \nobject-level\n variables. They can be accessed throughout the whole object. On the other hand, variables used exclusively inside states or functions are \nlocal variables\n. This means that their lifespan is restricted to their own block of code.\n\n\nobject \nSurge\n\n{\n    name = \nSurge the Rabbit\n; // object-level variable\n\n    state \nmain\n\n    {\n        weight = 35; // local variable\n        state = \nprint-data\n; // change the state\n    }\n\n    state \nprint-data\n\n    {\n        Console.print(name); // Surge the Rabbit\n        Console.print(weight); // ERROR: weight is not defined\n    }\n}\n\n\n\n\nFurthermore, \nobject-level\n variables may only be accessed within the object. Other objects may not read or write the variables directly (in other words, variables are \nprivate\n to the objects). You need to define \nfunctions\n or \ngetters and setters\n to accomplish that.", 
            "title": "Variables"
        }, 
        {
            "location": "/tutorials/variables/#variables", 
            "text": "Variables are used to store data. SurgeScript features five primitive types (number, string, boolean, null and object handle). Variables can also point to more complex data structures (such as arrays and dictionaries), but these are always objects.", 
            "title": "Variables"
        }, 
        {
            "location": "/tutorials/variables/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/tutorials/variables/#primitive-types", 
            "text": "Type  Description  Examples      Number  A floating-point number  1, 2, 3, 3.14159    String  Some text  \"Hello, world!\", 'single-quoted'    Boolean  True or false  true, false    Object  Reference to an object  Application, this, [ ]    Null  An empty value  null     As an example, the script below features an object with 3 variables that may be accessed throughout the whole object:  object  Surge \n{\n    name =  Surge the Rabbit ;\n    age = 23;\n    underage = false;\n\n    state  main \n    {\n        Console.print(name); // Surge the Rabbit\n        Console.print(age); // 23\n    }\n}", 
            "title": "Primitive types"
        }, 
        {
            "location": "/tutorials/variables/#abstract-types", 
            "text": "", 
            "title": "Abstract types"
        }, 
        {
            "location": "/tutorials/variables/#arrays", 
            "text": "Arrays are collections of values that you may access using a zero-based index. Example:  object  Application \n{\n    // The 'characters' array hold 3 strings\n    characters = [  Surge ,  Neon ,  Charge  ];\n\n    state  main \n    {\n        // who are the characters?\n        Console.print( The characters are: );\n        Console.print(characters[0]); // will print Surge\n        Console.print(characters[1]); // will print Neon\n        Console.print(characters[2]); // will print Charge\n\n        // how many characters?\n        Console.print( Number of characters: );\n        Console.print(characters.length); // will print 3\n    }\n}  Arrays have many interesting properties and operations that you can see in the  Language Reference .", 
            "title": "Arrays"
        }, 
        {
            "location": "/tutorials/variables/#dictionaries", 
            "text": "Dictionaries are collections of key-value pairs. In some programming languages, these are known as associative arrays or hash tables. Here's the syntax:  object  Surge \n{\n    // A dictionary that stores the weight (kg) of each character\n    weight = {\n         Surge : 35,\n         Neon : 20,\n         Charge : 37.5,\n         Gimacian : 70\n    };\n\n    // print the weights\n    state  main \n    {\n        Console.print( Surge weighs   + weight[ Surge ] +   kg. );\n        Console.print( Neon weighs   + weight[ Neon ] +   kg. );\n        Console.print( Charge weighs   + weight[ Charge ] +   kg. );\n        Console.print( Gimacian weighs   + weight[ Gimacian ] +   kg. );\n    }\n}  Dictionaries have many interesting properties and operations that you can see in the  Language Reference .   Cautionary note  Whenever you define an array or a dictionary, you spawn a new object. One is advised to  NOT  define arrays or dictionaries within states, because the code within states run continuously. Therefore, new objects will be created at every frame, not just once.   object  Application \n{\n    // arr will be instantiated once the object is created\n    arr = [ 1, 2, 3 ]; // RIGHT!\n\n    state  main \n    {\n        // err is instantiated at every frame of the application,\n        // thus memory is wasted with duplicate objects\n        err = [  don't ,  do ,  this  ]; // WRONG!\n    }\n}", 
            "title": "Dictionaries"
        }, 
        {
            "location": "/tutorials/variables/#scoping", 
            "text": "Variables that are defined before any state or function are  object-level  variables. They can be accessed throughout the whole object. On the other hand, variables used exclusively inside states or functions are  local variables . This means that their lifespan is restricted to their own block of code.  object  Surge \n{\n    name =  Surge the Rabbit ; // object-level variable\n\n    state  main \n    {\n        weight = 35; // local variable\n        state =  print-data ; // change the state\n    }\n\n    state  print-data \n    {\n        Console.print(name); // Surge the Rabbit\n        Console.print(weight); // ERROR: weight is not defined\n    }\n}  Furthermore,  object-level  variables may only be accessed within the object. Other objects may not read or write the variables directly (in other words, variables are  private  to the objects). You need to define  functions  or  getters and setters  to accomplish that.", 
            "title": "Scoping"
        }, 
        {
            "location": "/tutorials/expressions/", 
            "text": "Expressions\n\n\nSurgeScript supports many kinds of expressions. Expressions may involve strings, numbers or booleans. Let's study each case:\n\n\nConstants\n\n\nConstants are types of expressions. They may be numbers, strings, booleans... You may attribute constant values to variables using the assignment operator (\n=\n):\n\n\n// strings\nname = \nSurge\n; // variable name receives string \nSurge\n\nmessage = \nSurge's home\n;\notherMessage = 'Single-quoted strings are also allowed';\n\n// numbers\nweight = 35;\nspeed = 42.2;\n\n// booleans\nlike = true;\ncrazy = false;\n\n// null\nnext = null;\n\n\n\n\nArithmetic operators\n\n\nSurgeScript can perform basic arithmetic. The operators are as follows:\n\n\n\n\n\n\n\n\nOperator\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n+\n\n\nAddition\n\n\n\n\n\n\n-\n\n\nSubtraction\n\n\n\n\n\n\n*\n\n\nMultiplication\n\n\n\n\n\n\n/\n\n\nDivision\n\n\n\n\n\n\n\n\nExamples:\n\n\ntwo = 1 + 1;\nten = 5 * 2;\neleven = 5 * 2 + 1;\nfour = two * two;\nfifteen = eleven + four;\nthree = fifteen / 5;\npositive = +5;\nnegative = -1;\nzero = 15 - 10 - 5;\none = 15 - (10 + 4);\ntwelve = (2 + 2) * 3;\nprime = -(-15 + 8);\n\n\n\n\nComparison operators\n\n\nComparison operators compare two operands.\n\n\n\n\n\n\n\n\nOperator\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n==\n\n\nEquality operator\n\n\n\n\n\n\n!=\n\n\nInequality operator\n\n\n\n\n\n\n\n\nLess than\n\n\n\n\n\n\n=\n\n\nLess or equal\n\n\n\n\n\n\n>\n\n\nGreater than\n\n\n\n\n\n\n>=\n\n\nGreater or equal\n\n\n\n\n\n\n\n\nExamples:\n\n\nx = 1;\ny = (x == 1); // y is true\nz = (x != 1); // z is false\nw = x \n 1; // w is false\nt = x \n= 1; // t is true\n\n\n\n\n\n\nPay attention!\n\n\nNotice that the equality operator, used for comparing expressions for equality, is \n==\n. Pay attention! Don't confuse the equality operator (\n==\n) with the assignment operator (\n=\n). The expression \n(x = 1)\n always evaluates to 1, whereas \n(x == 1)\n is \ntrue\n only if x equals 1.\n\n\n\n\nLogical operators\n\n\nLogical operators involve booleans (\ntrue\n or \nfalse\n values). While the \nnot\n operator requires only one operand, operators \nand\n and \nor\n require two.\n\n\n\n\n\n\n\n\nOperator\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n\n\nand\n\n\n\n\n\n\n||\n\n\nor\n\n\n\n\n\n\n!\n\n\nnot\n\n\n\n\n\n\n\n\nThe table below summarizes the basic logical expressions:\n\n\n\n\n\n\n\n\nExpression\n\n\nResult\n\n\n\n\n\n\n\n\n\n\na \n b\n\n\ntrue\n only if both a and b are true\n\n\n\n\n\n\na || b\n\n\ntrue\n if either a or b are true (or both)\n\n\n\n\n\n\n!a\n\n\ntrue\n if a is false, \nfalse\n if a is true\n\n\n\n\n\n\n\n\nNotice that \nnot\n has higher precedence than the other two operators. Examples:\n\n\nx = 5 \n 2; // evaluates to false\ny = !x; // evaluates to true\nz = 18 \n 35 || x; // evaluates to true\nw = (z \n x) || true; // evaluates to true\nt = !x \n x; // evaluates to false\n\n\n\n\nTextual expressions\n\n\nYou may concatenate strings with the \n+\n operator. Example:\n\n\nmessage = \nSurge\n + \n rocks!\n; // evaluates to \nSurge rocks!\n\n\n\n\n\nOther data types, such as numbers and booleans, may also be implicitly converted to strings when using this feature. Example:\n\n\ngroup = \nJackson \n + 5; // evaluates to \nJackson 5\n\n\n\n\n\nAssignment operators\n\n\nThe attribution operator (\n=\n) may be used to attribute data to variables. However, there's more to that. The expression \nvariable = \"data\"\n is itself evaluated to string \n\"data\"\n.\n\n\nLikewise, the expression \nvariable = variable + 5\n is evaluated to \nvariable + 5\n and may be shortened to \nvariable += 5\n.\n\n\nLet's see what kind of assignment expressions we have:\n\n\n\n\n\n\n\n\nExpression\n\n\nTranslates to\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nx = value\n\n\nx = value\n\n\nAssigns \nvalue\n to x\n\n\n\n\n\n\nx += value\n\n\nx = x + value\n\n\nAdds \nvalue\n to x\n\n\n\n\n\n\nx -= value\n\n\nx = x - value\n\n\nSubtracts \nvalue\n from x\n\n\n\n\n\n\nx *= value\n\n\nx = x * value\n\n\nMultiplies x by \nvalue\n\n\n\n\n\n\nx /= value\n\n\nx = x / value\n\n\nDivides x by \nvalue\n\n\n\n\n\n\n\n\nExample:\n\n\nlanguage = \nSurge\n;\nlanguage += \nScript\n;\n// language now evaluates to \nSurgeScript\n\n\n\n\n\nIncrement and decrement\n\n\nIncrement and decrement operators should be used only on numeric variables.\n\n\n\n\n\n\n\n\nExpression\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\nx++\n\n\nIncrements x by 1 and returns the old value of x\n\n\n\n\n\n\nx--\n\n\nDecrements x by 1 and returns the old value of x\n\n\n\n\n\n\n++x\n\n\nIncrements x by 1 and returns the new value of x\n\n\n\n\n\n\n--x\n\n\nDecrements x by 1 and returns the new value of x\n\n\n\n\n\n\n\n\nExample:\n\n\nx = 1;   // x is 1\ny = x++; // y is 1\nz = ++x; // z is 3\nw = --x; // w is 2\nt = --x; // t is 1\nConsole.print(x); // prints 1\n\n\n\n\nChained expressions\n\n\nYou may chain assignment operations:\n\n\nx = y = z = 1;\n\n\n\n\nUsing commas will evaluate all expressions between then and return the right-most one:\n\n\nx = 1; // x is 1\ny = x++, 2; // y is 2\nz = y--, --x; // z is 1\n// x, y and z end up equal to 1\n\n\n\n\nOther expressions\n\n\ntypeof\n\n\nThe expression \ntypeof expr\n evaluates to a string informing the type of \nexpr\n. Example:\n\n\nt = typeof 5; // t will hold the string \nnumber\n\n\n\n\n\nThe possible types are: \nnumber\n, \nstring\n, \nboolean\n, \nnull\n, \nobject\n.\n\n\nthis\n\n\nThe keyword \nthis\n represents the object in which it appears. Example:\n\n\nthis.destroy(); // destroys this object", 
            "title": "Expressions"
        }, 
        {
            "location": "/tutorials/expressions/#expressions", 
            "text": "SurgeScript supports many kinds of expressions. Expressions may involve strings, numbers or booleans. Let's study each case:", 
            "title": "Expressions"
        }, 
        {
            "location": "/tutorials/expressions/#constants", 
            "text": "Constants are types of expressions. They may be numbers, strings, booleans... You may attribute constant values to variables using the assignment operator ( = ):  // strings\nname =  Surge ; // variable name receives string  Surge \nmessage =  Surge's home ;\notherMessage = 'Single-quoted strings are also allowed';\n\n// numbers\nweight = 35;\nspeed = 42.2;\n\n// booleans\nlike = true;\ncrazy = false;\n\n// null\nnext = null;", 
            "title": "Constants"
        }, 
        {
            "location": "/tutorials/expressions/#arithmetic-operators", 
            "text": "SurgeScript can perform basic arithmetic. The operators are as follows:     Operator  Meaning      +  Addition    -  Subtraction    *  Multiplication    /  Division     Examples:  two = 1 + 1;\nten = 5 * 2;\neleven = 5 * 2 + 1;\nfour = two * two;\nfifteen = eleven + four;\nthree = fifteen / 5;\npositive = +5;\nnegative = -1;\nzero = 15 - 10 - 5;\none = 15 - (10 + 4);\ntwelve = (2 + 2) * 3;\nprime = -(-15 + 8);", 
            "title": "Arithmetic operators"
        }, 
        {
            "location": "/tutorials/expressions/#comparison-operators", 
            "text": "Comparison operators compare two operands.     Operator  Meaning      ==  Equality operator    !=  Inequality operator     Less than    =  Less or equal    >  Greater than    >=  Greater or equal     Examples:  x = 1;\ny = (x == 1); // y is true\nz = (x != 1); // z is false\nw = x   1; // w is false\nt = x  = 1; // t is true   Pay attention!  Notice that the equality operator, used for comparing expressions for equality, is  == . Pay attention! Don't confuse the equality operator ( == ) with the assignment operator ( = ). The expression  (x = 1)  always evaluates to 1, whereas  (x == 1)  is  true  only if x equals 1.", 
            "title": "Comparison operators"
        }, 
        {
            "location": "/tutorials/expressions/#logical-operators", 
            "text": "Logical operators involve booleans ( true  or  false  values). While the  not  operator requires only one operand, operators  and  and  or  require two.     Operator  Meaning       and    ||  or    !  not     The table below summarizes the basic logical expressions:     Expression  Result      a   b  true  only if both a and b are true    a || b  true  if either a or b are true (or both)    !a  true  if a is false,  false  if a is true     Notice that  not  has higher precedence than the other two operators. Examples:  x = 5   2; // evaluates to false\ny = !x; // evaluates to true\nz = 18   35 || x; // evaluates to true\nw = (z   x) || true; // evaluates to true\nt = !x   x; // evaluates to false", 
            "title": "Logical operators"
        }, 
        {
            "location": "/tutorials/expressions/#textual-expressions", 
            "text": "You may concatenate strings with the  +  operator. Example:  message =  Surge  +   rocks! ; // evaluates to  Surge rocks!   Other data types, such as numbers and booleans, may also be implicitly converted to strings when using this feature. Example:  group =  Jackson   + 5; // evaluates to  Jackson 5", 
            "title": "Textual expressions"
        }, 
        {
            "location": "/tutorials/expressions/#assignment-operators", 
            "text": "The attribution operator ( = ) may be used to attribute data to variables. However, there's more to that. The expression  variable = \"data\"  is itself evaluated to string  \"data\" .  Likewise, the expression  variable = variable + 5  is evaluated to  variable + 5  and may be shortened to  variable += 5 .  Let's see what kind of assignment expressions we have:     Expression  Translates to  Meaning      x = value  x = value  Assigns  value  to x    x += value  x = x + value  Adds  value  to x    x -= value  x = x - value  Subtracts  value  from x    x *= value  x = x * value  Multiplies x by  value    x /= value  x = x / value  Divides x by  value     Example:  language =  Surge ;\nlanguage +=  Script ;\n// language now evaluates to  SurgeScript", 
            "title": "Assignment operators"
        }, 
        {
            "location": "/tutorials/expressions/#increment-and-decrement", 
            "text": "Increment and decrement operators should be used only on numeric variables.     Expression  Meaning      x++  Increments x by 1 and returns the old value of x    x--  Decrements x by 1 and returns the old value of x    ++x  Increments x by 1 and returns the new value of x    --x  Decrements x by 1 and returns the new value of x     Example:  x = 1;   // x is 1\ny = x++; // y is 1\nz = ++x; // z is 3\nw = --x; // w is 2\nt = --x; // t is 1\nConsole.print(x); // prints 1", 
            "title": "Increment and decrement"
        }, 
        {
            "location": "/tutorials/expressions/#chained-expressions", 
            "text": "You may chain assignment operations:  x = y = z = 1;  Using commas will evaluate all expressions between then and return the right-most one:  x = 1; // x is 1\ny = x++, 2; // y is 2\nz = y--, --x; // z is 1\n// x, y and z end up equal to 1", 
            "title": "Chained expressions"
        }, 
        {
            "location": "/tutorials/expressions/#other-expressions", 
            "text": "", 
            "title": "Other expressions"
        }, 
        {
            "location": "/tutorials/expressions/#typeof", 
            "text": "The expression  typeof expr  evaluates to a string informing the type of  expr . Example:  t = typeof 5; // t will hold the string  number   The possible types are:  number ,  string ,  boolean ,  null ,  object .", 
            "title": "typeof"
        }, 
        {
            "location": "/tutorials/expressions/#this", 
            "text": "The keyword  this  represents the object in which it appears. Example:  this.destroy(); // destroys this object", 
            "title": "this"
        }, 
        {
            "location": "/tutorials/conditionals/", 
            "text": "Conditionals\n\n\nConditionals are \nif ... then ...\n expressions. If a certain condition is \ntrue\n, execute a block of code. If not, don't execute it.\n\n\nif(condition) {\n    // this will be executed only if\n    // the condition is true\n}\n\n\n\n\nAlternatively, we may include an \nelse\n statement followed by a block of code that will only be executed if the condition is \nnot\n true:\n\n\nif(condition) {\n    // this will be executed only if\n    // the condition is true\n}\nelse {\n    // this will be executed only if\n    // the condition is false\n}\n\n\n\n\nExample\n\n\nThe following example will print \nunderaged\n if variable \nage\n is less than 18, or \nadult\n otherwise:\n\n\nobject \nApplication\n\n{\n    age = 23;\n\n    state \nmain\n\n    {\n        if(age \n 18) {\n            // variable age is less than 18\n            Console.print(\nunderaged\n);\n        }\n        else {\n            // variable age is not less than 18\n            Console.print(\nadult\n);\n        }\n\n        // we're done!\n        Application.exit();\n    }\n}\n\n\n\n\nInline conditionals\n\n\nJust like other languages with C-based syntax, the expression \ncondition ? true_value : false_value\n evaluates to \ntrue_value\n if \ncondition\n is \ntrue\n and to \nfalse_value\n if \ncondition\n is \nfalse\n.\n\n\nFor example, the script below will print \nunderaged\n if variable \nage\n is less than 18, or \nadult\n otherwise:\n\n\nobject \nApplication\n\n{\n    age = 23;\n    message = age \n 18 ? \nunderaged\n : \nadult\n;\n\n    state \nmain\n\n    {\n        Console.print(message);\n        Application.exit();\n    }\n}", 
            "title": "Conditionals"
        }, 
        {
            "location": "/tutorials/conditionals/#conditionals", 
            "text": "Conditionals are  if ... then ...  expressions. If a certain condition is  true , execute a block of code. If not, don't execute it.  if(condition) {\n    // this will be executed only if\n    // the condition is true\n}  Alternatively, we may include an  else  statement followed by a block of code that will only be executed if the condition is  not  true:  if(condition) {\n    // this will be executed only if\n    // the condition is true\n}\nelse {\n    // this will be executed only if\n    // the condition is false\n}", 
            "title": "Conditionals"
        }, 
        {
            "location": "/tutorials/conditionals/#example", 
            "text": "The following example will print  underaged  if variable  age  is less than 18, or  adult  otherwise:  object  Application \n{\n    age = 23;\n\n    state  main \n    {\n        if(age   18) {\n            // variable age is less than 18\n            Console.print( underaged );\n        }\n        else {\n            // variable age is not less than 18\n            Console.print( adult );\n        }\n\n        // we're done!\n        Application.exit();\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/tutorials/conditionals/#inline-conditionals", 
            "text": "Just like other languages with C-based syntax, the expression  condition ? true_value : false_value  evaluates to  true_value  if  condition  is  true  and to  false_value  if  condition  is  false .  For example, the script below will print  underaged  if variable  age  is less than 18, or  adult  otherwise:  object  Application \n{\n    age = 23;\n    message = age   18 ?  underaged  :  adult ;\n\n    state  main \n    {\n        Console.print(message);\n        Application.exit();\n    }\n}", 
            "title": "Inline conditionals"
        }, 
        {
            "location": "/tutorials/loops/", 
            "text": "Loops\n\n\nWhile loops\n\n\nIn a while loop, you execute a certain block of code while a condition is true. The syntax is as follows:\n\n\nwhile(condition) {\n    // block of code\n    // to be executed\n}\n\n\n\n\nThe example below counts from 1 to 10:\n\n\ni = 1;\nwhile(i \n= 10) {\n    Console.print(i);\n    i = i + 1;\n}\n\n\n\n\nFor loops\n\n\nA for loop is a more controlled repetition structure when compared to the while loop. For loops support an initialization command, a condition and an increment command. The syntax is as follows:\n\n\nfor(initialization; condition; increment) {\n    // block of code\n    // to be executed\n}\n\n\n\n\nThe code just displayed is equivalent to:\n\n\ninitialization;\nwhile(condition) {\n    // block of code\n    // to be executed\n\n    increment;\n}\n\n\n\n\nThe example below counts from 1 to 10:\n\n\nfor(i = 1; i \n= 10; i++) {\n    Console.print(i);\n}\n\n\n\n\nForeach\n\n\nForeach loops are used to iterate throughout collections (such as Arrays). Basically: for each element \nx\n in the collection, do something with \nx\n. The syntax is as follows:\n\n\nforeach(element in collection) {\n    // block of code\n    // to be executed\n}\n\n\n\n\nThe example below counts from 1 to 10:\n\n\ncollection = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nforeach(x in collection) {\n    Console.print(x);\n}", 
            "title": "Loops"
        }, 
        {
            "location": "/tutorials/loops/#loops", 
            "text": "", 
            "title": "Loops"
        }, 
        {
            "location": "/tutorials/loops/#while-loops", 
            "text": "In a while loop, you execute a certain block of code while a condition is true. The syntax is as follows:  while(condition) {\n    // block of code\n    // to be executed\n}  The example below counts from 1 to 10:  i = 1;\nwhile(i  = 10) {\n    Console.print(i);\n    i = i + 1;\n}", 
            "title": "While loops"
        }, 
        {
            "location": "/tutorials/loops/#for-loops", 
            "text": "A for loop is a more controlled repetition structure when compared to the while loop. For loops support an initialization command, a condition and an increment command. The syntax is as follows:  for(initialization; condition; increment) {\n    // block of code\n    // to be executed\n}  The code just displayed is equivalent to:  initialization;\nwhile(condition) {\n    // block of code\n    // to be executed\n\n    increment;\n}  The example below counts from 1 to 10:  for(i = 1; i  = 10; i++) {\n    Console.print(i);\n}", 
            "title": "For loops"
        }, 
        {
            "location": "/tutorials/loops/#foreach", 
            "text": "Foreach loops are used to iterate throughout collections (such as Arrays). Basically: for each element  x  in the collection, do something with  x . The syntax is as follows:  foreach(element in collection) {\n    // block of code\n    // to be executed\n}  The example below counts from 1 to 10:  collection = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nforeach(x in collection) {\n    Console.print(x);\n}", 
            "title": "Foreach"
        }, 
        {
            "location": "/tutorials/functions/", 
            "text": "Functions\n\n\nFunctions are blocks of code that you can reuse throughout your program. They may receive input parameters and they always output something. The syntax is as follows:\n\n\nfun function_name(param_1, param_2, param_3, ..., param_n)\n{\n    // block of code\n    // to be executed\n}\n\n\n\n\nFunctions may be associated to objects. Any function associated to an object may be used (called) by the object itself or by other objects. This means that functions are \npublic\n (they are visible to the outside world).\n\n\nNote:\n in an object, functions should be defined after the states.\n\n\nThe return statement\n\n\nUse the \nreturn\n statement to stop executing the function and to return some value to the caller. Example:\n\n\n// This function will return the double of input parameter x\nfunction double(x)\n{\n    return 2 * x;\n    Console.print(\nThis line will never be executed.\n);\n}\n\n\n\n\nIf no value is specified after the \nreturn\n keyword, the function will be stopped and its return value will be \nnull\n. Additionally, if no \nreturn\n statement is found, then the return value will also be \nnull\n.\n\n\nExample\n\n\nIn the example below, we have an object called \nCalculator\n with two functions: \ngreet()\n and \nsum()\n. \ngreet()\n takes no input parameters and just greets the user. On the other hand, \nsum()\n takes two input parameters, \na\n and \nb\n, and returns the sum \na\n + \nb\n:\n\n\nobject \nCalculator\n\n{\n    fun greet()\n    {\n        Console.print(\nHello! I am a Calculator!\n);\n    }\n\n    fun sum(a, b)\n    {\n        return a + b;\n    }\n}\n\n\n\n\nIn function \nsum()\n, variables \na\n and \nb\n hold the input data and are only visible inside the function.\n\n\nNow, let's create a program that uses this \nCalculator\n. Remember that the functions defined above can be called by any object, including \nApplication\n:\n\n\nobject \nApplication\n\n{\n    calculator = spawn(\nCalculator\n);\n\n    state \nmain\n\n    {\n        // greet the user\n        calculator.greet();\n\n        // do some computation\n        result = calculator.sum(5, 7);\n        Console.print(result);\n\n        // we're done!\n        Application.exit();\n    }\n}\n\n\n\n\nThe output of the above program is:\n\n\nHello! I am a Calculator!\n12\n\n\n\n\nNotice that the \nApplication\n does not need to know \nhow\n the functions of the \nCalculator\n are implemented. It just needs to know \nwhat\n they do. This means that you may change the implementation of the \nCalculator\n without changing the \nApplication\n, and the end-result will stay the same.\n\n\nConstructors and destructors\n\n\nIn SurgeScript, constructors and destructors are special functions that are called whenever objects are created and destroyed, respectivelly. It's not mandatory to define them, but it may be useful to do so (to set up things, for example). Neither may receive any arguments.\n\n\nLet's take our \nCalculator\n again. In the following example, \nconstructor()\n is called automatically whenever a \nCalculator\n object is created. Likewise, \ndestructor()\n is called automatically when the object is destroyed.\n\n\nobject \nCalculator\n\n{\n    fun constructor()\n    {\n        Console.print(\nCreating a Calculator...\n);\n    }\n\n    fun destructor()\n    {\n        Console.print(\nDestroying a Calculator...\n);\n    }\n\n    fun greet()\n    {\n        Console.print(\nHello! I am a Calculator!\n);\n    }\n\n    fun sum(a, b)\n    {\n        return a + b;\n    }\n}\n\n\n\n\nNow, if we run the \nApplication\n of the previous section without any modification, the output of the program will be:\n\n\nCreating a Calculator...\nHello! I am a Calculator!\n12\nDestroying a Calculator...\n\n\n\n\nPlease note that, for any object, its \nconstructor()\n runs \nbefore\n its main state.", 
            "title": "Functions"
        }, 
        {
            "location": "/tutorials/functions/#functions", 
            "text": "Functions are blocks of code that you can reuse throughout your program. They may receive input parameters and they always output something. The syntax is as follows:  fun function_name(param_1, param_2, param_3, ..., param_n)\n{\n    // block of code\n    // to be executed\n}  Functions may be associated to objects. Any function associated to an object may be used (called) by the object itself or by other objects. This means that functions are  public  (they are visible to the outside world).  Note:  in an object, functions should be defined after the states.", 
            "title": "Functions"
        }, 
        {
            "location": "/tutorials/functions/#the-return-statement", 
            "text": "Use the  return  statement to stop executing the function and to return some value to the caller. Example:  // This function will return the double of input parameter x\nfunction double(x)\n{\n    return 2 * x;\n    Console.print( This line will never be executed. );\n}  If no value is specified after the  return  keyword, the function will be stopped and its return value will be  null . Additionally, if no  return  statement is found, then the return value will also be  null .", 
            "title": "The return statement"
        }, 
        {
            "location": "/tutorials/functions/#example", 
            "text": "In the example below, we have an object called  Calculator  with two functions:  greet()  and  sum() .  greet()  takes no input parameters and just greets the user. On the other hand,  sum()  takes two input parameters,  a  and  b , and returns the sum  a  +  b :  object  Calculator \n{\n    fun greet()\n    {\n        Console.print( Hello! I am a Calculator! );\n    }\n\n    fun sum(a, b)\n    {\n        return a + b;\n    }\n}  In function  sum() , variables  a  and  b  hold the input data and are only visible inside the function.  Now, let's create a program that uses this  Calculator . Remember that the functions defined above can be called by any object, including  Application :  object  Application \n{\n    calculator = spawn( Calculator );\n\n    state  main \n    {\n        // greet the user\n        calculator.greet();\n\n        // do some computation\n        result = calculator.sum(5, 7);\n        Console.print(result);\n\n        // we're done!\n        Application.exit();\n    }\n}  The output of the above program is:  Hello! I am a Calculator!\n12  Notice that the  Application  does not need to know  how  the functions of the  Calculator  are implemented. It just needs to know  what  they do. This means that you may change the implementation of the  Calculator  without changing the  Application , and the end-result will stay the same.", 
            "title": "Example"
        }, 
        {
            "location": "/tutorials/functions/#constructors-and-destructors", 
            "text": "In SurgeScript, constructors and destructors are special functions that are called whenever objects are created and destroyed, respectivelly. It's not mandatory to define them, but it may be useful to do so (to set up things, for example). Neither may receive any arguments.  Let's take our  Calculator  again. In the following example,  constructor()  is called automatically whenever a  Calculator  object is created. Likewise,  destructor()  is called automatically when the object is destroyed.  object  Calculator \n{\n    fun constructor()\n    {\n        Console.print( Creating a Calculator... );\n    }\n\n    fun destructor()\n    {\n        Console.print( Destroying a Calculator... );\n    }\n\n    fun greet()\n    {\n        Console.print( Hello! I am a Calculator! );\n    }\n\n    fun sum(a, b)\n    {\n        return a + b;\n    }\n}  Now, if we run the  Application  of the previous section without any modification, the output of the program will be:  Creating a Calculator...\nHello! I am a Calculator!\n12\nDestroying a Calculator...  Please note that, for any object, its  constructor()  runs  before  its main state.", 
            "title": "Constructors and destructors"
        }, 
        {
            "location": "/tutorials/comments/", 
            "text": "Comments\n\n\nComments are used to make your code more human-readable. They are ignored by the computer. SurgeScript allows two kinds of comments: single-line comments and multi-line comments.\n\n\nSingle-line comments\n\n\nSingle-line comments start with a \n//\n. Example:\n\n\n// This line has no effect on the code (it's just for improved readability)\nx = 3 + 4; // x is now 7\n\n\n\n\nMulti-line comments\n\n\nMulti-line comments start with a \n/*\n and end with a \n*/\n. Example:\n\n\n/*\n * Comments can, but don't have to, take\n * multiple lines if you use this form.\n */\nx = 3 + 4; /* x is now 7 */\n\n\n\n\nComments of this form cannot be nested.", 
            "title": "Comments"
        }, 
        {
            "location": "/tutorials/comments/#comments", 
            "text": "Comments are used to make your code more human-readable. They are ignored by the computer. SurgeScript allows two kinds of comments: single-line comments and multi-line comments.", 
            "title": "Comments"
        }, 
        {
            "location": "/tutorials/comments/#single-line-comments", 
            "text": "Single-line comments start with a  // . Example:  // This line has no effect on the code (it's just for improved readability)\nx = 3 + 4; // x is now 7", 
            "title": "Single-line comments"
        }, 
        {
            "location": "/tutorials/comments/#multi-line-comments", 
            "text": "Multi-line comments start with a  /*  and end with a  */ . Example:  /*\n * Comments can, but don't have to, take\n * multiple lines if you use this form.\n */\nx = 3 + 4; /* x is now 7 */  Comments of this form cannot be nested.", 
            "title": "Multi-line comments"
        }, 
        {
            "location": "/tutorials/tags/", 
            "text": "Tags\n\n\nYou may tag objects with as many tags as you want. Tags are a way of attributing categories to different objects.\n\n\nTags should be placed before any definitions of variables, states or functions. Example:\n\n\nobject \nHorse\n\n{\n    tag \nanimal\n;\n    tag \nvehicle\n;\n\n    state \nmain\n\n    {\n    }\n}\n\nobject \nCat\n\n{\n    tag \nanimal\n;\n\n    state \nmain\n\n    {\n    }\n}\n\nobject \nCar\n\n{\n    tag \nvehicle\n;\n\n    state \nmain\n\n    {\n    }\n}\n\n\n\n\nWe may check if an object has a particular tag with the \nhasTag()\n function (see the \nTag System\n for more details):\n\n\nobject \nApplication\n\n{\n    horse = spawn(\nHorse\n);\n    cat = spawn(\nCat\n);\n    car = spawn(\nCar\n);\n\n    state \nmain\n\n    {\n        // Horse is both an animal and a vehicle\n        Console.print(horse.hasTag(\nanimal\n)); // true\n        Console.print(horse.hasTag(\nvehicle\n)); // true\n\n        // Cat is an animal, but not a vehicle\n        Console.print(cat.hasTag(\nanimal\n)); // true\n        Console.print(cat.hasTag(\nvehicle\n)); // false\n\n        // Car is a vehicle, but not an animal\n        Console.print(car.hasTag(\nanimal\n)); // false\n        Console.print(car.hasTag(\nvehicle\n)); // true\n    }\n}\n\n\n\n\nYou may also convey emotional states to objects using the following syntax:\n\n\nobject \nGood Day\n :)\n{\n    state \nmain\n\n    {\n    }\n}\n\n\n\n\nThe object will then be tagged with the specified emoticon(s). The following emoticons are available for your pleasure:\n\n\n\n\n\n\n\n\nEmoticon\n\n\nMeaning\n\n\n\n\n\n\n\n\n\n\n$_$\n\n\nFeelin' Rich\n\n\n\n\n\n\n3\n\n\nLovin' it\n\n\n\n\n\n\n:)\n\n\nHappy\n\n\n\n\n\n\n:(\n\n\nSad\n\n\n\n\n\n\n:P\n\n\nD'oh", 
            "title": "Tags"
        }, 
        {
            "location": "/tutorials/tags/#tags", 
            "text": "You may tag objects with as many tags as you want. Tags are a way of attributing categories to different objects.  Tags should be placed before any definitions of variables, states or functions. Example:  object  Horse \n{\n    tag  animal ;\n    tag  vehicle ;\n\n    state  main \n    {\n    }\n}\n\nobject  Cat \n{\n    tag  animal ;\n\n    state  main \n    {\n    }\n}\n\nobject  Car \n{\n    tag  vehicle ;\n\n    state  main \n    {\n    }\n}  We may check if an object has a particular tag with the  hasTag()  function (see the  Tag System  for more details):  object  Application \n{\n    horse = spawn( Horse );\n    cat = spawn( Cat );\n    car = spawn( Car );\n\n    state  main \n    {\n        // Horse is both an animal and a vehicle\n        Console.print(horse.hasTag( animal )); // true\n        Console.print(horse.hasTag( vehicle )); // true\n\n        // Cat is an animal, but not a vehicle\n        Console.print(cat.hasTag( animal )); // true\n        Console.print(cat.hasTag( vehicle )); // false\n\n        // Car is a vehicle, but not an animal\n        Console.print(car.hasTag( animal )); // false\n        Console.print(car.hasTag( vehicle )); // true\n    }\n}  You may also convey emotional states to objects using the following syntax:  object  Good Day  :)\n{\n    state  main \n    {\n    }\n}  The object will then be tagged with the specified emoticon(s). The following emoticons are available for your pleasure:     Emoticon  Meaning      $_$  Feelin' Rich    3  Lovin' it    :)  Happy    :(  Sad    :P  D'oh", 
            "title": "Tags"
        }, 
        {
            "location": "/tutorials/object_tree/", 
            "text": "Object tree\n\n\nIn SurgeScript, objects have a hierarchical relationship. Suppose that object P spawns (or \ninstantiates\n) object C. We say that object P is the \nparent\n of C. Similarly, object C is a \nchild\n of P.\n\n\nAn object may spawn many children. However, all objects have only one parent. This relationship between objects form a hierarchy (or a tree). The Figure below shows an example:\n\n\n\n\nIn this example, Level is the parent of GameItem1 and GameItem2. Components A and B are children of GameItem1, but not of GameItem2. Level has two children and GameItem2 has zero.\n\n\nIn SurgeScript, the root of the hierarchy is a predefined object called \nSystem\n. Its parent is itself. All other objects are descendants of \nSystem\n.\n\n\nSpawning objects\n\n\nYou can use \nspawn()\n to instantiate an object. Example:\n\n\nobject \nParent\n\n{\n    child = spawn(\nChild\n);\n\n    state \nmain\n\n    {\n    }\n}\n\nobject \nChild\n\n{\n    state \nmain\n\n    {\n    }\n}\n\n\n\n\nFunction \nspawn()\n may be invoked on objects other than the caller. In this case, the caller won't be the parent of the newly created object:\n\n\nobject \nParent\n\n{\n    child = spawn(\nChild\n);\n    grandChild = child.spawn(\nChild\n);\n\n    state \nmain\n\n    {\n    }\n}\n\n\n\n\n\n\nAutomatic Garbage Collection\n\n\nWhen you spawn an object, make sure you store a reference to it somewhere.\n\n\nIf an object cannot be reached from the root (no reachable object has any references to it), it will be automatically destroyed by SurgeScript's Garbage Collector.\n\n\n\n\nDestroying objects\n\n\nObjects can be destroyed manually by calling \ndestroy()\n. Whenever an object is destroyed, its children are destroyed as well.\n\n\nobject \nFoo\n\n{\n    state \nmain\n\n    {\n        Console.print(\nThis object does nothing.\n);\n        destroy();\n    }\n}\n\n\n\n\nTraversing the hierarchy\n\n\nRelevant data about the object hierarchy can be obtained using the following properties and functions:\n\n\n\n\n\n\n\n\nFunction / property\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nobj.parent\n (read-only)\n\n\nThe parent object\n\n\n\n\n\n\nobj.childCount\n (read-only)\n\n\nNumber of immediate children\n\n\n\n\n\n\nobj.child(name)\n\n\nGets a child object named \nname\n\n\n\n\n\n\nobj.findChild(name)\n\n\nFinds* a descendant named \nname\n\n\n\n\n\n\nobj.children()\n\n\nReturns an Array with all the children of the object\n\n\n\n\n\n\nobj.sibling(name)\n\n\nGets a sibling** named \nname\n\n\n\n\n\n\n\n\n\n\nNotes:\n\n\n* findChild() may be slow, as it performs a deep search within the object tree. One is encouraged to cache the result of this function (for example, in the object constructor) and to avoid using it in states or loops.\n\n\n** We say that two distinct objects are siblings if they share the same parent.\n\n\n\n\nExample:\n\n\nobject \nParent\n\n{\n    child = spawn(\nChild\n);\n    otherChild = spawn(\nChild\n);\n\n    state \nmain\n\n    {\n        Console.print(\nThis object has \n + childCount + \n children.\n);\n        destroy();\n    }\n}\n\n\n\n\nThe output is as follows:\n\n\nThis object has 2 children.", 
            "title": "Object tree"
        }, 
        {
            "location": "/tutorials/object_tree/#object-tree", 
            "text": "In SurgeScript, objects have a hierarchical relationship. Suppose that object P spawns (or  instantiates ) object C. We say that object P is the  parent  of C. Similarly, object C is a  child  of P.  An object may spawn many children. However, all objects have only one parent. This relationship between objects form a hierarchy (or a tree). The Figure below shows an example:   In this example, Level is the parent of GameItem1 and GameItem2. Components A and B are children of GameItem1, but not of GameItem2. Level has two children and GameItem2 has zero.  In SurgeScript, the root of the hierarchy is a predefined object called  System . Its parent is itself. All other objects are descendants of  System .", 
            "title": "Object tree"
        }, 
        {
            "location": "/tutorials/object_tree/#spawning-objects", 
            "text": "You can use  spawn()  to instantiate an object. Example:  object  Parent \n{\n    child = spawn( Child );\n\n    state  main \n    {\n    }\n}\n\nobject  Child \n{\n    state  main \n    {\n    }\n}  Function  spawn()  may be invoked on objects other than the caller. In this case, the caller won't be the parent of the newly created object:  object  Parent \n{\n    child = spawn( Child );\n    grandChild = child.spawn( Child );\n\n    state  main \n    {\n    }\n}   Automatic Garbage Collection  When you spawn an object, make sure you store a reference to it somewhere.  If an object cannot be reached from the root (no reachable object has any references to it), it will be automatically destroyed by SurgeScript's Garbage Collector.", 
            "title": "Spawning objects"
        }, 
        {
            "location": "/tutorials/object_tree/#destroying-objects", 
            "text": "Objects can be destroyed manually by calling  destroy() . Whenever an object is destroyed, its children are destroyed as well.  object  Foo \n{\n    state  main \n    {\n        Console.print( This object does nothing. );\n        destroy();\n    }\n}", 
            "title": "Destroying objects"
        }, 
        {
            "location": "/tutorials/object_tree/#traversing-the-hierarchy", 
            "text": "Relevant data about the object hierarchy can be obtained using the following properties and functions:     Function / property  Description      obj.parent  (read-only)  The parent object    obj.childCount  (read-only)  Number of immediate children    obj.child(name)  Gets a child object named  name    obj.findChild(name)  Finds* a descendant named  name    obj.children()  Returns an Array with all the children of the object    obj.sibling(name)  Gets a sibling** named  name      Notes:  * findChild() may be slow, as it performs a deep search within the object tree. One is encouraged to cache the result of this function (for example, in the object constructor) and to avoid using it in states or loops.  ** We say that two distinct objects are siblings if they share the same parent.   Example:  object  Parent \n{\n    child = spawn( Child );\n    otherChild = spawn( Child );\n\n    state  main \n    {\n        Console.print( This object has   + childCount +   children. );\n        destroy();\n    }\n}  The output is as follows:  This object has 2 children.", 
            "title": "Traversing the hierarchy"
        }, 
        {
            "location": "/tutorials/components/", 
            "text": "Components\n\n\nEntity Component System (ECS) is a software pattern used in game development. The idea is that in-game objects (called \nentities\n) can be customized by adding or removing objects (called \ncomponents\n) in runtime. Components add functionalities or behaviors to the entities to which they are attached to. In SurgeScript, both entities and components are objects - the difference is conceptual.\n\n\nAs an example, consider an in-game object called \nParrot\n. Objects by themselves are empty; they do nothing. However, an interesting behavior of parrots is that they are blabbers: they keep repeating the same thing over and over again. So, let's create an empty object \nParrot\n and spawn on it the \nBlabber\n component:\n\n\nobject \nParrot\n\n{\n    blabber = spawn(\nBlabber\n);\n\n    state \nmain\n\n    {\n    }\n}\n\nobject \nBlabber\n\n{\n    state \nmain\n\n    {\n        if(timeout(2)) // blab every 2 seconds\n            state = \nblab\n;\n    }\n\n    state \nblab\n\n    {\n        Console.print(\nHello!\n);\n        state = \nmain\n;\n    }\n}\n\n\n\n\nNow, whenever you spawn a Parrot, it will keep blabbing unceasingly:\n\n\nHello!\nHello!\nHello!\n...\n\n\n\n\nSuppose now that your Parrot is a Kamikaze Robot: it blabs so much that it will explode itself after some time. We'll attach a \nTime Bomb\n to the parroting robot, so that it will stop blabbing after a while:\n\n\nobject \nTime Bomb\n\n{\n    state \nmain\n\n    {\n        if(timeout(15)) // explode after 15 seconds\n            state = \nexplode\n;\n    }\n\n    state \nexplode\n\n    {\n        Console.print(\nBOOOM!\n);\n        parent.destroy(); // destroy the parent object\n    }\n}\n\nobject \nParrot\n\n{\n    blabber = spawn(\nBlabber\n);\n    bomb = spawn(\nTime Bomb\n);\n\n    state \nmain\n\n    {\n    }\n}\n\n\n\n\nNow, here's the result:\n\n\nHello!\nHello!\nHello!\nHello!\nHello!\nHello!\nHello!\nBOOOM!\n\n\n\n\nIn this example, \nParrot\n is an entity and \nBlabber\n and \nTime Bomb\n are its components. Once the entity is destroyed, its components (its children) are also destroyed automatically.\n\n\nDesign considerations\n\n\nIn some implementations of ECS, entities are implemented as integers and components consist of raw data only. The game logic is executed by the System layer, which iterates throughout all entities continuously and executes the logic according to the components attached to them.\n\n\nIn SurgeScript, components execute their own code and can be attached to entities simply by spawning them as children. Still, you can use the former approach if you wish to do so.\n\n\nComposition over inheritance\n\n\nSurgeScript does not support inheritance, a feature found in many object-oriented languages. The usage of components is encouraged instead. SurgeScript favors composition over inheritance, allowing for greater flexibility when defining in-game objects.", 
            "title": "Components"
        }, 
        {
            "location": "/tutorials/components/#components", 
            "text": "Entity Component System (ECS) is a software pattern used in game development. The idea is that in-game objects (called  entities ) can be customized by adding or removing objects (called  components ) in runtime. Components add functionalities or behaviors to the entities to which they are attached to. In SurgeScript, both entities and components are objects - the difference is conceptual.  As an example, consider an in-game object called  Parrot . Objects by themselves are empty; they do nothing. However, an interesting behavior of parrots is that they are blabbers: they keep repeating the same thing over and over again. So, let's create an empty object  Parrot  and spawn on it the  Blabber  component:  object  Parrot \n{\n    blabber = spawn( Blabber );\n\n    state  main \n    {\n    }\n}\n\nobject  Blabber \n{\n    state  main \n    {\n        if(timeout(2)) // blab every 2 seconds\n            state =  blab ;\n    }\n\n    state  blab \n    {\n        Console.print( Hello! );\n        state =  main ;\n    }\n}  Now, whenever you spawn a Parrot, it will keep blabbing unceasingly:  Hello!\nHello!\nHello!\n...  Suppose now that your Parrot is a Kamikaze Robot: it blabs so much that it will explode itself after some time. We'll attach a  Time Bomb  to the parroting robot, so that it will stop blabbing after a while:  object  Time Bomb \n{\n    state  main \n    {\n        if(timeout(15)) // explode after 15 seconds\n            state =  explode ;\n    }\n\n    state  explode \n    {\n        Console.print( BOOOM! );\n        parent.destroy(); // destroy the parent object\n    }\n}\n\nobject  Parrot \n{\n    blabber = spawn( Blabber );\n    bomb = spawn( Time Bomb );\n\n    state  main \n    {\n    }\n}  Now, here's the result:  Hello!\nHello!\nHello!\nHello!\nHello!\nHello!\nHello!\nBOOOM!  In this example,  Parrot  is an entity and  Blabber  and  Time Bomb  are its components. Once the entity is destroyed, its components (its children) are also destroyed automatically.", 
            "title": "Components"
        }, 
        {
            "location": "/tutorials/components/#design-considerations", 
            "text": "In some implementations of ECS, entities are implemented as integers and components consist of raw data only. The game logic is executed by the System layer, which iterates throughout all entities continuously and executes the logic according to the components attached to them.  In SurgeScript, components execute their own code and can be attached to entities simply by spawning them as children. Still, you can use the former approach if you wish to do so.", 
            "title": "Design considerations"
        }, 
        {
            "location": "/tutorials/components/#composition-over-inheritance", 
            "text": "SurgeScript does not support inheritance, a feature found in many object-oriented languages. The usage of components is encouraged instead. SurgeScript favors composition over inheritance, allowing for greater flexibility when defining in-game objects.", 
            "title": "Composition over inheritance"
        }, 
        {
            "location": "/tutorials/getters_and_setters/", 
            "text": "Getters and setters\n\n\nIn SurgeScript, variables are private. This means that variables may only be accessed from the objects that defined them. However, SurgeScript features a \nsyntactic sugar\n that allows objects to modify other objects' data in a way that looks like dealing with regular (public) variables.\n\n\nSuppose you have an object called \nAnimal\n with a variable called \nsound\n and a function called \ntalk()\n:\n\n\nobject \nAnimal\n\n{\n    sound = \nmeow!\n;\n\n    fun talk()\n    {\n        Console.print(sound);\n    }\n}\n\n\n\n\nThis object can only say \nmeow!\n Let's see:\n\n\nobject \nApplication\n\n{\n    animal = spawn(\nAnimal\n);\n\n    state \nmain\n\n    {\n        animal.talk();\n    }\n}\n\n\n\n\nRun this script and you'll see:\n\n\nmeow!\n\n\n\n\nWhat if an external object could modify the sound of the animal? Trying to access \nanimal.sound\n externally will trigger an error, unless you add the \npublic\n keyword to your variable:\n\n\nobject \nAnimal\n\n{\n    public sound = \nmeow!\n;\n\n    fun talk()\n    {\n        Console.print(sound);\n    }\n}\n\n\n\n\nNow, external objects may modify (and read) the \nsound\n variable:\n\n\nobject \nApplication\n\n{\n    animal = spawn(\nAnimal\n);\n\n    state \nmain\n\n    {\n        animal.sound = 'rrrrgh!!!';\n        animal.talk();\n    }\n}\n\n\n\n\nIn reality, however, there are no public variables in SurgeScript. Behind the scenes, the language defines special functions called \ngetters and setters\n that will perform the read/write logic for you. Rather than typing public, you may want to define the getters and the setters yourself:\n\n\nobject \nAnimal\n\n{\n    sound = \nmeow!\n;\n\n    fun talk()\n    {\n        Console.print(sound);\n    }\n\n    fun setSound(value)\n    {\n        sound = value;\n    }\n\n    fun getSound()\n    {\n        return sound;\n    }\n}\n\n\n\n\nThis code is the same (semantically); it's just a bit longer.\n\n\nAn advantage of defining getters and setters yourself is that you control how the data passes through the objects. You may want to validate the data before changing the internal variables of the objects, for example.", 
            "title": "Getters & setters"
        }, 
        {
            "location": "/tutorials/getters_and_setters/#getters-and-setters", 
            "text": "In SurgeScript, variables are private. This means that variables may only be accessed from the objects that defined them. However, SurgeScript features a  syntactic sugar  that allows objects to modify other objects' data in a way that looks like dealing with regular (public) variables.  Suppose you have an object called  Animal  with a variable called  sound  and a function called  talk() :  object  Animal \n{\n    sound =  meow! ;\n\n    fun talk()\n    {\n        Console.print(sound);\n    }\n}  This object can only say  meow!  Let's see:  object  Application \n{\n    animal = spawn( Animal );\n\n    state  main \n    {\n        animal.talk();\n    }\n}  Run this script and you'll see:  meow!  What if an external object could modify the sound of the animal? Trying to access  animal.sound  externally will trigger an error, unless you add the  public  keyword to your variable:  object  Animal \n{\n    public sound =  meow! ;\n\n    fun talk()\n    {\n        Console.print(sound);\n    }\n}  Now, external objects may modify (and read) the  sound  variable:  object  Application \n{\n    animal = spawn( Animal );\n\n    state  main \n    {\n        animal.sound = 'rrrrgh!!!';\n        animal.talk();\n    }\n}  In reality, however, there are no public variables in SurgeScript. Behind the scenes, the language defines special functions called  getters and setters  that will perform the read/write logic for you. Rather than typing public, you may want to define the getters and the setters yourself:  object  Animal \n{\n    sound =  meow! ;\n\n    fun talk()\n    {\n        Console.print(sound);\n    }\n\n    fun setSound(value)\n    {\n        sound = value;\n    }\n\n    fun getSound()\n    {\n        return sound;\n    }\n}  This code is the same (semantically); it's just a bit longer.  An advantage of defining getters and setters yourself is that you control how the data passes through the objects. You may want to validate the data before changing the internal variables of the objects, for example.", 
            "title": "Getters and setters"
        }, 
        {
            "location": "/tutorials/advanced_features/", 
            "text": "Advanced Features\n\n\nThis section describes advanced features of SurgeScript.\n\n\nLookup operator\n\n\nSome programming languages, such as C++, have a feature called \noperator overloading\n. It's a \nsyntactic sugar\n that allows the programmer to attribute custom implementations to different operators.\n\n\nIn SurgeScript, the \n[ ]\n operator (also called the \nlookup operator\n), used by Arrays and Dictionaries, is used to \nget\n and \nset\n values from/to the data structure. Still, the \n[ ]\n operator can be used by any object, for any purpose. It is necessary to define, in your object, functions \nget()\n and \nset()\n with the following signature:\n\n\nfun get(key)\n{\n    // custom implementation\n}\n\nfun set(key, value)\n{\n    // custom implementation\n}\n\n\n\n\nGiven an object \nobj\n, the expression \nx = obj[key]\n is equivalent to \nx = obj.get(key)\n. Similarly, \nobj[key] = value\n is equivalent to \nobj.set(key, value)\n.\n\n\nFunctors\n\n\nIn SurgeScript, objects can be made to behave like functions. We call these objects \nfunctors\n. To make an object behave like a function, you have to overload the \n( )\n operator (also known as the \nfunction operator\n). This is done by defining function \ncall()\n in your object:\n\n\nfun call()\n{\n    // custom implementation\n}\n\n\n\n\nFunction \ncall()\n may take any number of parameters. Given an object \nf\n, the expression \ny = f(x)\n is equivalent to \ny = f.call(x)\n. Notice that, since \nf\n is an object, you may exchange its implementation during runtime.\n\n\nIterators\n\n\nAs seen in the \nloops\n section, the foreach loop may be used to iterate through a collection. In SurgeScript, a collection is an object (but the opposite is not always true). You may implement your own collections by implementing function \niterator()\n. If you have ever used Java, you'll find this to be familiar.\n\n\nobject \nMyCollection\n\n{\n    fun iterator()\n    {\n        // function iterator() takes no arguments and \n        // should return a new iterator object\n    }\n}\n\n\n\n\nFor each collection you define, you should also define its iterator object. The iterator object should implement functions \nnext()\n and \nhasNext()\n (both take no arguments):\n\n\nobject \nMyIterator\n\n{\n    fun next()\n    {\n        // returns the next element of the collection\n        // and advances the iteration pointer\n        // the collection is usually the parent object\n    }\n\n    function hasNext()\n    {\n        // returns true if the enumeration isn't over\n        // returns false if there are no more elements\n    }\n}\n\n\n\n\nYou may iterate through a collection using the following code:\n\n\nit = collection.iterator();\nwhile(it.hasNext()) {\n    x = it.next();\n\n    // do something with x\n    // x is an element of the collection\n    Console.print(x);\n}\n\n\n\n\nOr, alternatively, using the compact foreach:\n\n\nforeach(x in collection) {\n    Console.print(x);\n}\n\n\n\n\nFor the sake of completion, the following code demonstrates how to implement a custom collection that hold even numbers from 0 up to 20.\n\n\nobject \nApplication\n\n{\n    evenNumbers = spawn(\nEvenNumbers\n);\n\n    state \nmain\n\n    {\n        // iterate through the collection\n        foreach(number in evenNumbers)\n            Console.print(number);\n\n        // exit the app\n        Application.exit();\n    }\n}\n\nobject \nEvenNumbers\n\n{\n    fun iterator()\n    {\n        return spawn(\nEvenIterator\n);\n    }\n}\n\nobject \nEvenIterator\n\n{\n    nextNumber = 0;\n\n    fun next()\n    {\n        currentNumber = nextNumber;\n        nextNumber += 2;\n        return currentNumber;\n    }\n\n    fun hasNext()\n    {\n        return nextNumber \n= 20;\n    }\n}\n\n\n\n\nThe result of this code is:\n\n\n0\n2\n4\n6\n8\n10\n12\n14\n16\n18\n20", 
            "title": "Advanced Features"
        }, 
        {
            "location": "/tutorials/advanced_features/#advanced-features", 
            "text": "This section describes advanced features of SurgeScript.", 
            "title": "Advanced Features"
        }, 
        {
            "location": "/tutorials/advanced_features/#lookup-operator", 
            "text": "Some programming languages, such as C++, have a feature called  operator overloading . It's a  syntactic sugar  that allows the programmer to attribute custom implementations to different operators.  In SurgeScript, the  [ ]  operator (also called the  lookup operator ), used by Arrays and Dictionaries, is used to  get  and  set  values from/to the data structure. Still, the  [ ]  operator can be used by any object, for any purpose. It is necessary to define, in your object, functions  get()  and  set()  with the following signature:  fun get(key)\n{\n    // custom implementation\n}\n\nfun set(key, value)\n{\n    // custom implementation\n}  Given an object  obj , the expression  x = obj[key]  is equivalent to  x = obj.get(key) . Similarly,  obj[key] = value  is equivalent to  obj.set(key, value) .", 
            "title": "Lookup operator"
        }, 
        {
            "location": "/tutorials/advanced_features/#functors", 
            "text": "In SurgeScript, objects can be made to behave like functions. We call these objects  functors . To make an object behave like a function, you have to overload the  ( )  operator (also known as the  function operator ). This is done by defining function  call()  in your object:  fun call()\n{\n    // custom implementation\n}  Function  call()  may take any number of parameters. Given an object  f , the expression  y = f(x)  is equivalent to  y = f.call(x) . Notice that, since  f  is an object, you may exchange its implementation during runtime.", 
            "title": "Functors"
        }, 
        {
            "location": "/tutorials/advanced_features/#iterators", 
            "text": "As seen in the  loops  section, the foreach loop may be used to iterate through a collection. In SurgeScript, a collection is an object (but the opposite is not always true). You may implement your own collections by implementing function  iterator() . If you have ever used Java, you'll find this to be familiar.  object  MyCollection \n{\n    fun iterator()\n    {\n        // function iterator() takes no arguments and \n        // should return a new iterator object\n    }\n}  For each collection you define, you should also define its iterator object. The iterator object should implement functions  next()  and  hasNext()  (both take no arguments):  object  MyIterator \n{\n    fun next()\n    {\n        // returns the next element of the collection\n        // and advances the iteration pointer\n        // the collection is usually the parent object\n    }\n\n    function hasNext()\n    {\n        // returns true if the enumeration isn't over\n        // returns false if there are no more elements\n    }\n}  You may iterate through a collection using the following code:  it = collection.iterator();\nwhile(it.hasNext()) {\n    x = it.next();\n\n    // do something with x\n    // x is an element of the collection\n    Console.print(x);\n}  Or, alternatively, using the compact foreach:  foreach(x in collection) {\n    Console.print(x);\n}  For the sake of completion, the following code demonstrates how to implement a custom collection that hold even numbers from 0 up to 20.  object  Application \n{\n    evenNumbers = spawn( EvenNumbers );\n\n    state  main \n    {\n        // iterate through the collection\n        foreach(number in evenNumbers)\n            Console.print(number);\n\n        // exit the app\n        Application.exit();\n    }\n}\n\nobject  EvenNumbers \n{\n    fun iterator()\n    {\n        return spawn( EvenIterator );\n    }\n}\n\nobject  EvenIterator \n{\n    nextNumber = 0;\n\n    fun next()\n    {\n        currentNumber = nextNumber;\n        nextNumber += 2;\n        return currentNumber;\n    }\n\n    fun hasNext()\n    {\n        return nextNumber  = 20;\n    }\n}  The result of this code is:  0\n2\n4\n6\n8\n10\n12\n14\n16\n18\n20", 
            "title": "Iterators"
        }, 
        {
            "location": "/tutorials/best_practices/", 
            "text": "Best Practices\n\n\n\n\nRead the \nComponents\n section. It's crucial that you understand it.\n\n\nFollow the golden rule: objects should \nnot\n mess with each others' internals!\n\n\nObjects should \nnot\n change other objects' variables or states directly (won't allow it!)\n\n\nObjects should define \nfunctions\n that can be operated upon by the external world (API)\n\n\n\n\n\n\nUse \ncamelCase\n names for both variables and functions.\n\n\nUse \n4 spaces\n for indenting your code.\n\n\nRead this documentation often.", 
            "title": "Best practices"
        }, 
        {
            "location": "/tutorials/best_practices/#best-practices", 
            "text": "Read the  Components  section. It's crucial that you understand it.  Follow the golden rule: objects should  not  mess with each others' internals!  Objects should  not  change other objects' variables or states directly (won't allow it!)  Objects should define  functions  that can be operated upon by the external world (API)    Use  camelCase  names for both variables and functions.  Use  4 spaces  for indenting your code.  Read this documentation often.", 
            "title": "Best Practices"
        }, 
        {
            "location": "/reference/application/", 
            "text": "", 
            "title": "Application"
        }, 
        {
            "location": "/reference/application/", 
            "text": "", 
            "title": "Application"
        }
    ]
}